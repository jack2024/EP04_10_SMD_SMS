CCS PCH C Compiler, Version 4.104, 5967               26-àÁ.Â.-21 16:49

               Filename: D:\jobESP\ESPAN-04\Firmware\SPAN-04\ESPAN04_10 - Delay - SP - SMD\ESPAN-04_test_faultDelayTime.lst

               ROM used: 20750 bytes (63%)
                         Largest free fragment is 12014
               RAM used: 427 (28%) at main() level
                         447 (29%) worst case
               Stack:    6 worst case (4 in main + 2 for interrupts)

*
0000:  GOTO   49AE
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  00,0E
003C:  MOVFF  01,0F
0040:  MOVFF  02,10
0044:  MOVFF  03,11
0048:  BTFSS  F9D.0
004A:  GOTO   0054
004E:  BTFSC  F9E.0
0050:  GOTO   052A
0054:  BTFSS  F9D.1
0056:  GOTO   0060
005A:  BTFSC  F9E.1
005C:  GOTO   0530
0060:  BTFSS  F9D.5
0062:  GOTO   006C
0066:  BTFSC  F9E.5
0068:  GOTO   0518
006C:  MOVFF  0E,00
0070:  MOVFF  0F,01
0074:  MOVFF  10,02
0078:  MOVFF  11,03
007C:  MOVFF  0C,FE9
0080:  MOVFF  07,FEA
0084:  BSF    07.7
0086:  MOVFF  08,FE1
008A:  MOVFF  09,FE2
008E:  MOVFF  0A,FD9
0092:  MOVFF  0B,FDA
0096:  MOVFF  12,FF3
009A:  MOVFF  13,FF4
009E:  MOVFF  14,FFA
00A2:  MOVF   04,W
00A4:  MOVFF  06,FE0
00A8:  MOVFF  05,FD8
00AC:  RETFIE 0
....................  
.................... #include "D:\jobESP\ESPAN-04\Firmware\SPAN-04\ESPAN04_20 - Delay - SP - SMD - PIC18F252\ESPAN-04.h" 
.................... #include <18F252.h> 
.................... //////// Standard Header file for the PIC18F252 device //////////////// 
.................... #device PIC18F252 
.................... #list 
....................  
.................... //#device adc=8 
.................... #FUSES WDT 
.................... #FUSES WDT64                    //Watch Dog Timer uses 1:64 Postscale 
.................... #FUSES HS                       //High speed Osc (> 4mhz) 
.................... #FUSES PROTECT                //Code not protected from reading 
.................... //#FUSES IESO                     //Internal External Switch Over mode enabled 
.................... #FUSES BROWNOUT                 //Reset when brownout detected 
.................... //#FUSES BORV20                   //Brownout reset at 2.0V 
.................... #FUSES NOPUT                    //No Power Up Timer 
.................... #FUSES NOCPD                    //No EE protection 
.................... //#FUSES STVREN                   //Stack full/underflow will cause reset 
.................... #FUSES NODEBUG                  //No Debug mode for ICD 
.................... //#FUSES LVP                      //Low Voltage Programming on B3(PIC16) or B5(PIC18) 
.................... //#FUSES NOWRT                    //Program memory not write protected 
.................... //#FUSES NOWRTD                   //Data EEPROM not write protected 
.................... #FUSES NOEBTR                   //Memory not protected from table reads 
.................... #FUSES NOCPB                    //No Boot Block code protection 
.................... #FUSES NOEBTRB                  //Boot block not protected from table reads 
.................... #FUSES NOWRTC                   //configuration not registers write protected 
.................... #FUSES NOWRTB                   //Boot block not write protected 
.................... //#FUSES FCMEN                    //Fail-safe clock monitor enabled 
....................  
.................... /* //jj 
.................... #FUSES NOXINST                  //Extended set extension and Indexed Addressing mode disabled (Legacy mode) 
.................... #FUSES PBADEN                   //PORTB pins are configured as analog input channels on RESET 
.................... #FUSES LPT1OSC                  //Timer1 configured for low-power operation 
.................... #FUSES MCLR                     //Master Clear pin enabled 
.................... */ 
....................  
.................... #define CLOCK_SP   20000000   //Clock Speed 20MHz 
....................  
.................... //23S17 Define 
.................... #define IO_MULTIPLE_DEVICES 
.................... #define IO_CS_PIN PIN_A5 
....................  
.................... #use delay(clock=20000000,RESTART_WDT) 
*
05C4:  MOVLW  01
05C6:  MOVWF  FEA
05C8:  MOVLW  B3
05CA:  MOVWF  FE9
05CC:  MOVF   FEF,W
05CE:  BZ    05F2
05D0:  MOVLW  06
05D2:  MOVWF  01
05D4:  MOVLW  BF
05D6:  MOVWF  00
05D8:  CLRWDT
05DA:  DECFSZ 00,F
05DC:  BRA    05D8
05DE:  DECFSZ 01,F
05E0:  BRA    05D4
05E2:  MOVLW  7A
05E4:  MOVWF  00
05E6:  DECFSZ 00,F
05E8:  BRA    05E6
05EA:  BRA    05EC
05EC:  CLRWDT
05EE:  DECFSZ FEF,F
05F0:  BRA    05D0
05F2:  RETLW  00
.................... //#use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8) 
....................  
.................... /* 
.................... #include <16F886.h> 
.................... #device adc=10 
....................  
.................... #FUSES WDT                      //Watch Dog Timer 
.................... #FUSES HS                       //High speed Osc (> 4mhz) 
.................... #FUSES NOPUT                    //No Power Up Timer 
.................... //#FUSES MCLR                     //Master Clear pin enabled 
.................... #FUSES PROTECT                  //Code protected from reads 
.................... //#FUSES CPD                      //Data EEPROM Code Protected 
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... //#FUSES IESO                     //Internal External Switch Over mode enabled 
.................... //#FUSES FCMEN                    //Fail-safe clock monitor enabled 
.................... //#FUSES LVP                      //Low Voltage Programming on B3(PIC16) or B5(PIC18) 
.................... #FUSES NODEBUG                  //No Debug mode for ICD 
.................... //#FUSES BORV21                   //Brownout reset at 2.1V 
.................... //#FUSES WRT                      //Program Memory Write Protected 
....................  
.................... #use delay(clock=20000000,RESTART_WDT) 
.................... #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,restart_wdt) 
.................... */ 
....................  
....................  
.................... #include "D:\jobESP\ESPAN-04\Firmware\SPAN-04\ESPAN04_20 - Delay - SP - SMD - PIC18F252\23S17.c" // 16 bit I/O Expander 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                        23S17.c                                      //// 
.................... ////                                                                   //// 
.................... ////   Library for a MicroChip MCP23S17 SPI Port Expansion Chip        //// 
.................... ////                                                                   //// 
.................... //// The MCP23S17 device provides 16-bit, general purpose parallel I/O //// 
.................... //// expansion for SPI applications. The 16-bit I/O port functionally  //// 
.................... //// consists of two 8-bit ports (PORTA and PORTB). There are two      //// 
.................... //// interrupt pins, INTA and INTB, that can be associated with their  //// 
.................... //// respective ports, or can be logically OR’ed together so that both //// 
.................... //// pins will activate if either port causes an interrupt. The        //// 
.................... //// hardware address pins are used to determine the device address.   ////                                                 //// 
.................... ////                                                                   //// 
.................... ////  A #use spi must be provided by the main program.                 //// 
.................... ////                                                                   //// 
.................... ////  -------------------------------------------------------------    //// 
.................... ////  PIN LAYOUT                                                       //// 
.................... ////  -------------------------------------------------------------    //// 
.................... ////                                                                    //// 
.................... ////        -------------------------------------------                //// 
.................... ////        | 1 : GPB0          | 28: GPA7            |                //// 
.................... ////        |                   |                     |                //// 
.................... ////        | 2 : GPB1          | 27: GPA6            |                //// 
.................... ////        |                   |                     |                //// 
.................... ////        | 3 : GPB2          | 26: GPA5            |                //// 
.................... ////        |                   |                     |                //// 
.................... ////        | 4 : GPB3          | 25: GPA4            |                //// 
.................... ////        |                   |                     |                //// 
.................... ////        | 5 : GPB4          | 24: GPA3            |                //// 
.................... ////        |                   |                     |                //// 
.................... ////        | 6 : GPB5          | 23: GPA2            |                //// 
.................... ////        |                   |                     |                //// 
.................... ////        | 7 : GPB6          | 22: GPA1            |                //// 
.................... ////        |                   |                     |                //// 
.................... ////        | 8 : GPB7          | 21: GPA0            |                //// 
.................... ////        |                   |                     |                //// 
.................... ////        | 9 : Vdd           | 20: INTA            |                //// 
.................... ////        |                   |                     |                //// 
.................... ////        | 10: Vss           | 19: INTB            |                //// 
.................... ////        |     __            |     _____           |                //// 
.................... ////        | 11: CS            | 18: RESET           |                //// 
.................... ////        |                   |                     |                //// 
.................... ////        | 12: SCK           | 17: A2              |                //// 
.................... ////        |                   |                     |                //// 
.................... ////        | 13: SI            | 16: A1              |                //// 
.................... ////        |                   |                     |                //// 
.................... ////        | 14: SO            | 15: A0              |                //// 
.................... ////        -------------------------------------------                //// 
.................... ////                                                                   //// 
.................... ////  -------------------------------------------------------------    //// 
.................... ////  FUNCTIONS                                                        //// 
.................... ////  -------------------------------------------------------------    //// 
.................... ////                                                                   //// 
.................... ////   void IO_INIT()                                                   ////                    
.................... ////     Initializes the 23S17 chips on the SPI bus                      ////                                                  
.................... ////                                                                   ////   
.................... ////  void IO_WRITE_REGISTER(int8 address, int8 reg, int8 data)        //// 
.................... ////     Writes the value to the specified register and device          ////                                                             
.................... ////                                                                   ////   
.................... ////  int8 IO_READ_REGISTER(int8 address, int8 reg);                    //// 
.................... ////     Reads the value of the specified register and device          ////                                                            
.................... ////                                                                   ////   
.................... ////  void IO_OUTPUT_A(int8 address, int8 data);                       //// 
.................... ////     Outputs the value to PORTA on the specified device. Doesn't   //// 
.................... ////     change the direction of the port.                             //// 
.................... ////                                                                   ////       
.................... ////  void IO_OUTPUT_B(int8 address, int8 data);                       //// 
.................... ////     Outputs the value to PORTB on the specified device. Doesn't   //// 
.................... ////     change the direction of the port.                             //// 
.................... ////                                                                   ////       
.................... ////  int8 IO_INPUT_A(int8 address)                                    //// 
.................... ////     Returns the value of PORTA on the specified device. Doesn't   //// 
.................... ////     change the direction of the port.                             //// 
.................... ////                                                                   ////       
.................... ////  int8 IO_INPUT_B(int8 address)                                    //// 
.................... ////     Returns the value of PORTB on the specified device. Doesn't   //// 
.................... ////     change the direction of the port.                             //// 
.................... ////                                                                   ////       
.................... ////  void IO_OUTPUT_BIT(int8 address, int8 pin, int1 state)           //// 
.................... ////     Outputs the value to specified pin and device. Doesn't change //// 
.................... ////      the direction of the pin.                                     //// 
.................... ////                                                                   ////       
.................... ////  void IO_OUTPUT_HIGH(int8 address, int8 pin)                      //// 
.................... ////     Sets the output high on the specified pin and device. Doesn't //// 
.................... ////     change the direction of the pin.                              //// 
.................... ////                                                                   ////       
.................... ////  void IO_OUTPUT_LOW(int8 address, int8 pin)                       //// 
.................... ////     Sets the output low on the specified pin and device. Doesn't  //// 
.................... ////     change the direction of the pin.                              //// 
.................... ////                                                                   ////    
.................... ////  void IO_OUTPUT_FLOAT(int8 address, int8 pin)                     //// 
.................... ////     Sets the pin to an input on the specified device.             //// 
.................... ////                                                                   //// 
.................... ////  void IO_OUTPUT_TOGGLE(int8 address, int8 pin)                    //// 
.................... ////     Toggles the output on the specified pin and device. Doesn't   //// 
.................... ////     change the direction of the pin.                              //// 
.................... ////                                                                   ////       
.................... ////  void IO_OUTPUT_DRIVE(int8 address, int8 pin)                     //// 
.................... ////     Sets the pin to an output on the specified device.            //// 
.................... ////                                                                   ////       
.................... ////  int1 IO_INPUT(int8 address, int8 pin)                            //// 
.................... ////     Gets the current value on the specified pin and device.       //// 
.................... ////                                                                   ////       
.................... ////  int1 IO_INPUT_STATE(int8 address, int8 pin)                      //// 
.................... ////     Gets the current value on the specified pin and device.       ////  
.................... ////     Doesn't change the direction of the pin.                      //// 
.................... ////                                                                   ////       
.................... ////  int8 IO_GET_TRIS_A(int8 address)                                 //// 
.................... ////     Gets the data direction register for PORTA on the specified   ////  
.................... ////      device.                                                       //// 
.................... ////                                                                   ////       
.................... ////  void IO_SET_TRIS_A(int8 address, int8 data)                      //// 
.................... ////     Sets the data direction register for PORTA on the specified   ////  
.................... ////      device.                                                       //// 
.................... ////                                                                   ////       
.................... ////  int8 IO_GET_TRIS_B(int8 address)                                 //// 
.................... ////     Gets the data direction register for PORTB on the specified   ////  
.................... ////      device.                                                       //// 
.................... ////                                                                   ////       
.................... ////  void IO_SET_TRIS_B(int8 address, int8 data)                      //// 
.................... ////     Sets the data direction register for PORTB on the specified   ////  
.................... ////      device.                                                       //// 
.................... ////                                                                   ////                                                                    //// 
.................... ////  NOTE: address is only valid if IO_MULTIPLE_DEVICES is defined    //// 
.................... ////        in your main program. Use the provided #defines as         //// 
.................... ////        parameters for the address, pin, and reg fields.           //// 
.................... ////                                                                    //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// VERSION HISTORY:                                                  //// 
.................... ////                                                                   //// 
.................... //// Author Date        Comments                                       //// 
.................... //// -----  -------     ----------------------------------             //// 
.................... //// TMH    Jul-29-2009 File Created                                   //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2009 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #ifndef MCP23S17 
.................... #define MCP23S17 
....................  
.................... /****************************************************************************** 
.................... **** DEFINES 
.................... ******************************************************************************/ 
....................  
.................... //This is the device address mask. Device supports up to 8 of the chips on the 
.................... //same bus. If multiple devices are to be used on the same bus, define  
.................... //IO_MULTIPLE_DEVICES in your program. This will add an address field to all  
.................... //functions. If IO_MULTIPLE_DEVICE is not defined, an address of 0 will be  
.................... //assumed (i.e. ground A2, A1, A0) 
.................... #define IO_DEVICE_ADDRESS_READ   0b01000001 
.................... #define IO_DEVICE_ADDRESS_WRITE  0b01000000 
....................  
.................... //User must define a CS pin in main. This pin can be connected to all similar 
.................... //devices on the bus. 
.................... //!#ifndef IO_CS_PIN 
.................... //!#error Must define a chip select pin. 
.................... //!#endif 
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// Address Defines 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// Use these in the address field if using multiple 23S17 devices. If bit 3 
.................... //// in IOCON is cleared these no longer work and only device 0 can be operated 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... #ifdef IO_MULTIPLE_DEVICES 
....................  
.................... #define IO_DEVICE_0   0b00000000 
.................... #define IO_DEVICE_1   0b00000010 
.................... #define IO_DEVICE_2   0b00000100 
.................... #define IO_DEVICE_3   0b00000110 
.................... #define IO_DEVICE_4   0b00001000 
.................... #define IO_DEVICE_5   0b00001010 
.................... #define IO_DEVICE_6   0b00001100 
.................... #define IO_DEVICE_7   0b00001110 
....................  
.................... #endif 
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// Device Register Defines 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// Used in the reg field. If IOCON bit 7 is cleared these no longer are  
.................... //// correct, use values to right. Refer to data sheet for more information 
.................... //// on their use. 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... #define IODIRA      0x00     //0x00   Data Direction Register for PORTA 
.................... #define IPOLA     0x01     //0x02   Input Polarity Register for PORTA 
.................... #define GPINTENA    0x02     //0x04     Interrupt-on-change enable Register for PORTA                         
.................... #define DEFVALA   0x03     //0x06   Default Value Register for PORTA 
.................... #define INTCONA   0x04     //0x08   Interrupt-on-change control Register for PORTA                           
.................... #define IOCON      0x05     //0x0A   Configuration register for device                       
.................... #define GPPUA      0x06     //0x0C   100kOhm pullup resistor register for PORTA (sets pin to input when set)                            
.................... #define INTFA      0x07     //0x0E   Interrupt flag Register for PORTA                              
.................... #define INTCAPA   0x08     //0x10   Interrupt captured value Register for PORTA                   
.................... #define GPIOA      0x09     //0x12   General purpose I/O Register for PORTA                             
.................... #define OLATA      0x0A     //0x14   Output latch Register for PORTA 
....................  
.................... #define IODIRB    0x10     //0x01   Data Direction Register for PORTB 
.................... #define IPOLB     0x11     //0x03   Input Polarity Register for PORTB 
.................... #define GPINTENB    0x12     //0x05     Interrupt-on-change enable Register for PORTB 
.................... #define DEFVALB   0x13     //0x07   Default Value Register for PORTB 
.................... #define INTCONB   0x14     //0x09   Interrupt-on-change control Register for PORTB 
.................... //#define IOCON      0x15     //0x0B   //IOCON has 2 different addresses, both write to same register                               
.................... #define GPPUB      0x16     //0x0D   100kOhm pullup resistor register for PORTB (sets pin to input when set) 
.................... #define INTFB      0x17     //0x0F   Interrupt flag Register for PORTB  
.................... #define INTCAPB   0x18     //0x11   Interrupt captured value Register for PORTB 
.................... #define GPIOB      0x19     //0x13   General purpose I/O Register for PORTB 
.................... #define OLATB      0x1A     //0x15   Output latch Register for PORTB 
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// Pin Defines 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// Use in the Pin field. 
.................... /////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #define IO_PIN_A0      0x80 
.................... #define IO_PIN_A1      0x81 
.................... #define IO_PIN_A2      0x82 
.................... #define IO_PIN_A3      0x83 
.................... #define IO_PIN_A4      0x84 
.................... #define IO_PIN_A5      0x85 
.................... #define IO_PIN_A6      0x86 
.................... #define IO_PIN_A7      0x87 
....................  
.................... #define IO_PIN_B0      0x00 
.................... #define IO_PIN_B1      0x01 
.................... #define IO_PIN_B2      0x02 
.................... #define IO_PIN_B3      0x03 
.................... #define IO_PIN_B4      0x04 
.................... #define IO_PIN_B5      0x05 
.................... #define IO_PIN_B6      0x06 
.................... #define IO_PIN_B7      0x07 
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// IOCON Bits 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// OR wanted options together when setting the IOCON register. 
.................... /////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #define IO_IOCON_BANK      0x80   //Sets register addresses. Initialized to 1.                             
.................... #define IO_IOCON_MIRROR    0x40   //Internally connect interrupt PINs.  
.................... #define IO_IOCON_SEQOP     0x20   //Sets ~Sequential/Byte mode. Driver only uses byte mode. 
.................... #define IO_IOCON_DISSLW    0x10    //Enables slew rate for SDA output                              
.................... #define IO_IOCON_HAEN      0x08   //Enables hardware address pins. If 0 only one device can be used. 
.................... #define IO_IOCON_ODR       0x04   //Open drain/~active drive interrupt pin outputs 
.................... #define IO_IOCON_INTPOL    0x02   //Sets INT output as active high/~low 
....................  
.................... /****************************************************************************** 
.................... **** FUNCTION PROTOTYPES 
.................... ******************************************************************************/ 
....................  
.................... void IO_INIT();   //don't need multiple inits because all devices are assumed 0 before HAEN is set 
....................  
.................... #ifndef IO_MULTIPLE_DEVICES 
.................... void IO_WRITE_REGISTER(int8 reg, int8 data); 
.................... int8 IO_READ_REGISTER(int8 reg); 
.................... void IO_OUTPUT_A(int8 data); 
.................... void IO_OUTPUT_B(int8 data); 
.................... int8 IO_INPUT_A(); 
.................... int8 IO_INPUT_B(); 
.................... void IO_OUTPUT_BIT(int8 pin, int1 state); 
.................... void IO_OUTPUT_HIGH(int8 pin); 
.................... void IO_OUTPUT_LOW(int8 pin); 
.................... void IO_OUTPUT_FLOAT(int8 pin); 
.................... void IO_OUTPUT_TOGGLE(int8 pin); 
.................... void IO_OUTPUT_DRIVE(int8 pin); 
.................... int1 IO_INPUT(int8 pin); 
.................... int1 IO_INPUT_STATE(int8 pin); 
.................... int8 IO_GET_TRIS_A(); 
.................... void IO_SET_TRIS_A(int8 data); 
.................... int8 IO_GET_TRIS_B(); 
.................... void IO_SET_TRIS_B(int8 data); 
.................... #else 
.................... void IO_WRITE_REGISTER(int8 address, int8 reg, int8 data); 
.................... int8 IO_READ_REGISTER(int8 address, int8 reg); 
.................... void IO_OUTPUT_A(int8 address, int8 data); 
.................... void IO_OUTPUT_B(int8 address, int8 data); 
.................... int8 IO_INPUT_A(int8 address); 
.................... int8 IO_INPUT_B(int8 address); 
.................... void IO_OUTPUT_BIT(int8 address, int8 pin, int1 state); 
.................... void IO_OUTPUT_HIGH(int8 address, int8 pin); 
.................... void IO_OUTPUT_LOW(int8 address, int8 pin); 
.................... void IO_OUTPUT_FLOAT(int8 address, int8 pin); 
.................... void IO_OUTPUT_TOGGLE(int8 address, int8 pin); 
.................... void IO_OUTPUT_DRIVE(int8 address, int8 pin); 
.................... int1 IO_INPUT(int8 address, int8 pin); 
.................... int1 IO_INPUT_STATE(int8 address, int8 pin); 
.................... int8 IO_GET_TRIS_A(int8 address); 
.................... void IO_SET_TRIS_A(int8 address, int8 data); 
.................... int8 IO_GET_TRIS_B(int8 address); 
.................... void IO_SET_TRIS_B(int8 address, int8 data); 
.................... #endif 
....................  
.................... /****************************************************************************** 
.................... **** FUNCTIONS 
.................... ******************************************************************************/ 
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// IO_INIT 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// Must be called before anything else. Enables the MCP23S17 chip to have  
.................... //// the following settings: 
.................... ////      IO_IOCON_BANK    = 1    Sets addresses to align with the #defines 
.................... ////      IO_IOCON_MIRROR  = 0      INT pins are not internally connected 
.................... ////      IO_IOCON_SEQOP     = 1      Operating in Byte mode    
.................... ////      IO_IOCON_DISSLW  = 0      SDA output slew rate is enabled                              
.................... ////      IO_IOCON_HAEN     = x      A2, A1, A0 enabled only if IO_MULTIPLE_DEVICES is defined    
.................... ////      IO_IOCON_ODR      = 0      Interrupt will drive its level    
.................... ////      IO_IOCON_INTPOL  = 1      Interrupt is active-high 
.................... //// 
.................... //// If different settings are required, use an IO_WRITE_REGISTER() with IOCON 
.................... //// as the reg parameter. Note: if IO_IOCON_BANK is cleared then the #defines 
.................... //// for the register values are no longer valid. 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... void IO_INIT(){ 
....................  
....................    output_high(IO_CS_PIN); 
*
0626:  BCF    F92.5
0628:  BSF    F89.5
....................    output_drive(IO_CS_PIN); 
062A:  BCF    F92.5
....................    #ifndef IO_MULTIPLE_DEVICES 
....................    IO_WRITE_REGISTER(0x0A, 0xA2);   //IOCON's address is 0xA until IOCON.Bank is set                          
....................    #else 
....................    IO_WRITE_REGISTER(IO_DEVICE_0, 0x0A, 0xAA); 
062C:  MOVLB  1
062E:  CLRF   xB5
0630:  MOVLW  0A
0632:  MOVWF  xB6
0634:  MOVLW  AA
0636:  MOVWF  xB7
0638:  MOVLB  0
063A:  RCALL  05F4
....................    IO_WRITE_REGISTER(IO_DEVICE_1, 0x0A, 0xAA);  //Edit by Jack 
063C:  MOVLW  02
063E:  MOVLB  1
0640:  MOVWF  xB5
0642:  MOVLW  0A
0644:  MOVWF  xB6
0646:  MOVLW  AA
0648:  MOVWF  xB7
064A:  MOVLB  0
064C:  RCALL  05F4
....................    IO_WRITE_REGISTER(IO_DEVICE_2, 0x0A, 0xAA);  //Edit by Jack 
064E:  MOVLW  04
0650:  MOVLB  1
0652:  MOVWF  xB5
0654:  MOVLW  0A
0656:  MOVWF  xB6
0658:  MOVLW  AA
065A:  MOVWF  xB7
065C:  MOVLB  0
065E:  RCALL  05F4
....................    IO_WRITE_REGISTER(IO_DEVICE_3, 0x0A, 0xAA);  //Edit by Jack 
0660:  MOVLW  06
0662:  MOVLB  1
0664:  MOVWF  xB5
0666:  MOVLW  0A
0668:  MOVWF  xB6
066A:  MOVLW  AA
066C:  MOVWF  xB7
066E:  MOVLB  0
0670:  RCALL  05F4
....................    IO_WRITE_REGISTER(IO_DEVICE_4, 0x0A, 0xAA);  //Edit by Jack 
0672:  MOVLW  08
0674:  MOVLB  1
0676:  MOVWF  xB5
0678:  MOVLW  0A
067A:  MOVWF  xB6
067C:  MOVLW  AA
067E:  MOVWF  xB7
0680:  MOVLB  0
0682:  RCALL  05F4
....................    IO_WRITE_REGISTER(IO_DEVICE_5, 0x0A, 0xAA);  //Edit by Jack 
0684:  MOVLW  0A
0686:  MOVLB  1
0688:  MOVWF  xB5
068A:  MOVWF  xB6
068C:  MOVLW  AA
068E:  MOVWF  xB7
0690:  MOVLB  0
0692:  RCALL  05F4
....................    IO_WRITE_REGISTER(IO_DEVICE_6, 0x0A, 0xAA);  //Edit by Jack 
0694:  MOVLW  0C
0696:  MOVLB  1
0698:  MOVWF  xB5
069A:  MOVLW  0A
069C:  MOVWF  xB6
069E:  MOVLW  AA
06A0:  MOVWF  xB7
06A2:  MOVLB  0
06A4:  RCALL  05F4
....................    IO_WRITE_REGISTER(IO_DEVICE_7, 0x0A, 0xAA);  //Edit by Jack 
06A6:  MOVLW  0E
06A8:  MOVLB  1
06AA:  MOVWF  xB5
06AC:  MOVLW  0A
06AE:  MOVWF  xB6
06B0:  MOVLW  AA
06B2:  MOVWF  xB7
06B4:  MOVLB  0
06B6:  RCALL  05F4
....................    #endif 
.................... } 
06B8:  GOTO   4A6C (RETURN)
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// IO_WRITE_REGISTER 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// Sets the value of the specified register. 
.................... //// 
.................... //// Parameters: 
.................... ////      reg - the register to be written. use provided defines. 
.................... ////      data - the data to be written. 
.................... ////     address - address of the device. use provided defines. 
.................... //// 
.................... //// Returns: 
.................... ////      void 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... #ifndef IO_MULTIPLE_DEVICES 
.................... void IO_WRITE_REGISTER(int8 reg, int8 data){ 
.................... #else 
.................... void IO_WRITE_REGISTER(int8 address, int8 reg, int8 data){ 
.................... #endif 
....................     
....................    output_low(IO_CS_PIN); 
*
05F4:  BCF    F92.5
05F6:  BCF    F89.5
....................     
....................    #ifndef IO_MULTIPLE_DEVICES 
....................    spi_write(IO_DEVICE_ADDRESS_WRITE); 
....................    #else 
....................    spi_write(IO_DEVICE_ADDRESS_WRITE | address); 
05F8:  MOVLB  1
05FA:  MOVF   xB5,W
05FC:  IORLW  40
05FE:  MOVWF  xB8
0600:  MOVF   FC9,W
0602:  MOVFF  1B8,FC9
0606:  RRCF   FC7,W
0608:  BNC   0606
....................    #endif 
....................     
....................    spi_write(reg); 
060A:  MOVF   FC9,W
060C:  MOVFF  1B6,FC9
0610:  RRCF   FC7,W
0612:  BNC   0610
....................    spi_write(data); 
0614:  MOVF   FC9,W
0616:  MOVFF  1B7,FC9
061A:  RRCF   FC7,W
061C:  BNC   061A
....................     
....................    output_high(IO_CS_PIN); 
061E:  BCF    F92.5
0620:  BSF    F89.5
....................  
.................... } 
0622:  MOVLB  0
0624:  RETLW  00
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// IO_READ_REGISTER 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// Gets the current value of the specified register. 
.................... //// 
.................... //// Parameters: 
.................... ////      reg - the register to be read. use provided defines. 
.................... ////     address - address of the device. use provided defines. 
.................... //// 
.................... //// Returns: 
.................... ////      int8 - the current value of the requested register 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... #ifndef IO_MULTIPLE_DEVICES 
.................... int8 IO_READ_REGISTER(int8 reg){ 
.................... #else 
.................... int8 IO_READ_REGISTER(int8 address, int8 reg){ 
.................... #endif 
....................    int8 retVal; 
....................  
....................    output_low(IO_CS_PIN); 
*
0EA8:  BCF    F92.5
0EAA:  BCF    F89.5
....................     
....................    #ifndef IO_MULTIPLE_DEVICES 
....................    spi_write(IO_DEVICE_ADDRESS_READ); 
....................    #else 
....................    spi_write(IO_DEVICE_ADDRESS_READ | address); 
0EAC:  MOVLB  1
0EAE:  MOVF   xAE,W
0EB0:  IORLW  41
0EB2:  MOVWF  xB1
0EB4:  MOVF   FC9,W
0EB6:  MOVFF  1B1,FC9
0EBA:  RRCF   FC7,W
0EBC:  BNC   0EBA
....................    #endif 
....................     
....................    spi_write(reg); 
0EBE:  MOVF   FC9,W
0EC0:  MOVFF  1AF,FC9
0EC4:  RRCF   FC7,W
0EC6:  BNC   0EC4
....................    retVal = spi_read(0); 
0EC8:  MOVF   FC9,W
0ECA:  CLRF   FC9
0ECC:  RRCF   FC7,W
0ECE:  BNC   0ECC
0ED0:  MOVFF  FC9,1B0
....................     
....................    output_high(IO_CS_PIN); 
0ED4:  BCF    F92.5
0ED6:  BSF    F89.5
....................     
....................    return retVal; 
0ED8:  MOVFF  1B0,01
....................  
.................... } 
0EDC:  MOVLB  0
0EDE:  RETLW  00
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// IO_OUTPUT_A 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// Sets the current output value of Port A. Does NOT change the PORT's  
.................... //// direction 
.................... //// 
.................... //// Parameters: 
.................... ////      data - the value to be written to Port A 
.................... ////     address - address of the device. use provided defines. 
.................... //// 
.................... //// Returns: 
.................... ////      void 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... #ifndef IO_MULTIPLE_DEVICES 
.................... void IO_OUTPUT_A(int8 data){ 
.................... #else 
.................... void IO_OUTPUT_A(int8 address, int8 data){ 
.................... #endif 
....................  
....................    #ifndef IO_MULTIPLE_DEVICES 
....................    IO_WRITE_REGISTER(OLATA, data); 
....................    #else 
....................    IO_WRITE_REGISTER(address, OLATA, data); 
*
17E6:  MOVFF  1B3,1B5
17EA:  MOVLW  0A
17EC:  MOVLB  1
17EE:  MOVWF  xB6
17F0:  MOVFF  1B4,1B7
17F4:  MOVLB  0
17F6:  CALL   05F4
....................    #endif 
....................  
.................... } 
17FA:  RETLW  00
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// IO_OUTPUT_B 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// Sets the current output value of Port B. Does NOT change the PORT's  
.................... //// direction 
.................... //// 
.................... //// Parameters: 
.................... ////      data - the value to be written to Port B 
.................... ////     address - address of the device. use provided defines. 
.................... //// 
.................... //// Returns: 
.................... ////      void 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... #ifndef IO_MULTIPLE_DEVICES 
.................... void IO_OUTPUT_B(int8 data){ 
.................... #else 
.................... void IO_OUTPUT_B(int8 address, int8 data){ 
.................... #endif 
....................  
....................    #ifndef IO_MULTIPLE_DEVICES 
....................    IO_WRITE_REGISTER(OLATB, data); 
....................    #else 
....................    IO_WRITE_REGISTER(address, OLATB, data); 
17FC:  MOVFF  1B3,1B5
1800:  MOVLW  1A
1802:  MOVLB  1
1804:  MOVWF  xB6
1806:  MOVFF  1B4,1B7
180A:  MOVLB  0
180C:  CALL   05F4
....................    #endif 
....................  
.................... } 
1810:  RETLW  00
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// IO_INPUT_A 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// Gets the current input value of Port A. Does NOT change the PORT's  
.................... //// direction 
.................... //// 
.................... //// Parameters: 
.................... ////     address - address of the device. use provided defines. 
.................... //// 
.................... //// Returns: 
.................... ////      int8 - PORTA's input value 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... #ifndef IO_MULTIPLE_DEVICES 
.................... int8 IO_INPUT_A(){ 
.................... #else 
.................... int8 IO_INPUT_A(int8 address){ 
.................... #endif 
....................  
....................    int8 retVal; 
....................     
....................    #ifndef IO_MULTIPLE_DEVICES 
....................    retVal = IO_READ_REGISTER(GPIOA); 
....................    #else 
....................    retVal = IO_READ_REGISTER(address, GPIOA); 
*
0EE0:  MOVFF  1AC,1AE
0EE4:  MOVLW  09
0EE6:  MOVLB  1
0EE8:  MOVWF  xAF
0EEA:  MOVLB  0
0EEC:  RCALL  0EA8
0EEE:  MOVFF  01,1AD
....................    #endif 
....................     
....................    return retVal; 
0EF2:  MOVLB  1
0EF4:  MOVFF  1AD,01
....................  
.................... } 
0EF8:  MOVLB  0
0EFA:  RETLW  00
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// IO_INPUT_B 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// Gets the current input value of Port B. Does NOT change the PORT's  
.................... //// direction 
.................... //// 
.................... //// Parameters: 
.................... ////     address - address of the device. use provided defines. 
.................... //// 
.................... //// Returns: 
.................... ////      int8 - PORTB's input value 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... #ifndef IO_MULTIPLE_DEVICES 
.................... int8 IO_INPUT_B(){ 
.................... #else 
.................... int8 IO_INPUT_B(int8 address){ 
.................... #endif 
....................  
....................    int8 retVal; 
....................     
....................    #ifndef IO_MULTIPLE_DEVICES 
....................    retVal = IO_READ_REGISTER(GPIOB); 
....................    #else 
....................    retVal = IO_READ_REGISTER(address, GPIOB); 
0EFC:  MOVFF  1AC,1AE
0F00:  MOVLW  19
0F02:  MOVLB  1
0F04:  MOVWF  xAF
0F06:  MOVLB  0
0F08:  RCALL  0EA8
0F0A:  MOVFF  01,1AD
....................    #endif 
....................     
....................    return retVal; 
0F0E:  MOVLB  1
0F10:  MOVFF  1AD,01
....................  
.................... } 
0F14:  MOVLB  0
0F16:  RETLW  00
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// IO_OUTPUT_BIT 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// Sets the specified PIN to the desired state. Does NOT change the PIN's  
.................... //// direction 
.................... //// 
.................... //// Parameters: 
.................... ////      pin - pin to be changed. use provided defines. 
.................... ////     address - address of the device. use provided defines. 
.................... //// 
.................... //// Returns: 
.................... ////      void 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... #ifndef IO_MULTIPLE_DEVICES 
.................... void IO_OUTPUT_BIT(int8 pin, int1 state){ 
.................... #else 
.................... void IO_OUTPUT_BIT(int8 address, int8 pin, int1 state){ 
.................... #endif 
....................     
....................    int8 tempReg; 
....................     
....................    if(bit_test(pin, 7)){ //PIN A 
....................       #ifndef IO_MULTIPLE_DEVICES 
....................       tempReg = IO_READ_REGISTER(OLATA); 
....................       #else 
....................       tempReg = IO_READ_REGISTER(address, OLATA); 
....................       #endif 
....................       if(state){    //set high                       
....................          bit_set(tempReg, pin &0x0F);      
....................       }else{        //set low                       
....................          bit_clear(tempReg, pin &0x0F); 
....................       } 
....................       #ifndef IO_MULTIPLE_DEVICES 
....................       IO_WRITE_REGISTER(OLATA, tempReg); 
....................       #else 
....................       IO_WRITE_REGISTER(address, OLATA, tempReg); 
....................       #endif 
....................    }else{    //PIN B    
....................       #ifndef IO_MULTIPLE_DEVICES 
....................       tempReg = IO_READ_REGISTER(OLATB); 
....................       #else 
....................       tempReg = IO_READ_REGISTER(address, OLATB); 
....................       #endif 
....................       if(state){    //set high                       
....................          bit_set(tempReg, pin);       
....................       }else{        //set low                       
....................          bit_clear(tempReg, pin); 
....................       } 
....................       #ifndef IO_MULTIPLE_DEVICES 
....................       IO_WRITE_REGISTER(OLATB, tempReg); 
....................       #else 
....................       IO_WRITE_REGISTER(address, OLATB, tempReg); 
....................       #endif 
....................    } 
....................  
.................... } 
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// IO_OUTPUT_HIGH 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// Sets the specified PIN to output high. Does NOT change the PIN's direction 
.................... //// 
.................... //// Parameters: 
.................... ////      pin - pin to be set. use provided defines. 
.................... ////     address - address of the device. use provided defines. 
.................... //// 
.................... //// Returns: 
.................... ////      void 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... #ifndef IO_MULTIPLE_DEVICES 
.................... void IO_OUTPUT_HIGH(int8 pin){ 
.................... #else 
.................... void IO_OUTPUT_HIGH(int8 address, int8 pin){ 
.................... #endif 
....................  
....................    int8 tempReg; 
....................     
....................    if(bit_test(pin, 7)){ //PIN A 
....................       #ifndef IO_MULTIPLE_DEVICES 
....................       tempReg = IO_READ_REGISTER(OLATA); 
....................       #else 
....................       tempReg = IO_READ_REGISTER(address, OLATA); 
....................       #endif 
....................       bit_set(tempReg, pin &0x0F);  
....................       #ifndef IO_MULTIPLE_DEVICES 
....................       IO_WRITE_REGISTER(OLATA, tempReg); 
....................       #else 
....................       IO_WRITE_REGISTER(address, OLATA, tempReg); 
....................       #endif 
....................    }else{    //PIN B    
....................       #ifndef IO_MULTIPLE_DEVICES 
....................       tempReg = IO_READ_REGISTER(OLATB); 
....................       #else 
....................       tempReg = IO_READ_REGISTER(address, OLATB); 
....................       #endif 
....................       bit_set(tempReg, pin);  
....................       #ifndef IO_MULTIPLE_DEVICES 
....................       IO_WRITE_REGISTER(OLATB, tempReg); 
....................       #else 
....................       IO_WRITE_REGISTER(address, OLATB, tempReg); 
....................       #endif 
....................    } 
....................  
.................... } 
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// IO_OUTPUT_LOW 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// Sets the specified PIN to output low. Does NOT change the PIN's direction 
.................... //// 
.................... //// Parameters: 
.................... ////      pin - pin to be cleared. use provided defines. 
.................... ////     address - address of the device. use provided defines. 
.................... //// 
.................... //// Returns: 
.................... ////      void 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... #ifndef IO_MULTIPLE_DEVICES 
.................... void IO_OUTPUT_LOW(int8 pin){ 
.................... #else 
.................... void IO_OUTPUT_LOW(int8 address, int8 pin){ 
.................... #endif 
....................  
....................    int8 tempReg; 
....................     
....................    if(bit_test(pin, 7)){ //PIN A 
....................       #ifndef IO_MULTIPLE_DEVICES 
....................       tempReg = IO_READ_REGISTER(OLATA); 
....................       #else 
....................       tempReg = IO_READ_REGISTER(address, OLATA); 
....................       #endif 
....................       bit_clear(tempReg, pin &0x0F); 
....................       #ifndef IO_MULTIPLE_DEVICES 
....................       IO_WRITE_REGISTER(OLATA, tempReg); 
....................       #else 
....................       IO_WRITE_REGISTER(address, OLATA, tempReg); 
....................       #endif 
....................    }else{    //PIN B    
....................       #ifndef IO_MULTIPLE_DEVICES 
....................       tempReg = IO_READ_REGISTER(OLATB); 
....................       #else 
....................       tempReg = IO_READ_REGISTER(address, OLATB); 
....................       #endif 
....................       bit_clear(tempReg, pin); 
....................       #ifndef IO_MULTIPLE_DEVICES 
....................       IO_WRITE_REGISTER(OLATB, tempReg); 
....................       #else 
....................       IO_WRITE_REGISTER(address, OLATB, tempReg); 
....................       #endif 
....................    } 
....................  
.................... } 
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// IO_OUTPUT_FLOAT 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// Sets the specified PIN to an input. 
.................... //// 
.................... //// Parameters: 
.................... ////      pin - pin to be changed. use provided defines. 
.................... ////     address - address of the device. use provided defines. 
.................... //// 
.................... //// Returns: 
.................... ////      void 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... #ifndef IO_MULTIPLE_DEVICES 
.................... void IO_OUTPUT_FLOAT(int8 pin){ 
.................... #else 
.................... void IO_OUTPUT_FLOAT(int8 address, int8 pin){ 
.................... #endif 
....................  
....................    int8 tempReg; 
....................     
....................    if(bit_test(pin, 7)){ //PIN A 
....................       #ifndef IO_MULTIPLE_DEVICES 
....................       tempReg = IO_GET_TRIS_A(); 
....................       #else 
....................       tempReg = IO_GET_TRIS_A(address); 
....................       #endif 
....................       bit_set(tempReg, pin &0x0F);  
....................       #ifndef IO_MULTIPLE_DEVICES 
....................       IO_SET_TRIS_A(tempReg); 
....................       #else 
....................       IO_SET_TRIS_A(address, tempReg); 
....................       #endif 
....................    }else{    //PIN B    
....................       #ifndef IO_MULTIPLE_DEVICES 
....................       tempReg = IO_GET_TRIS_B(); 
....................       #else 
....................       tempReg = IO_GET_TRIS_B(address); 
....................       #endif 
....................       bit_set(tempReg, pin);       
....................       #ifndef IO_MULTIPLE_DEVICES 
....................       IO_SET_TRIS_B(tempReg); 
....................       #else 
....................       IO_SET_TRIS_B(address, tempReg); 
....................       #endif 
....................    } 
....................  
.................... } 
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// IO_OUTPUT_TOGGLE 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// Toggles the specified PIN's output. 
.................... //// 
.................... //// Parameters: 
.................... ////      pin - pin to be toggled. use provided defines. 
.................... ////     address - address of the device. use provided defines. 
.................... //// 
.................... //// Returns: 
.................... ////      void 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... #ifndef IO_MULTIPLE_DEVICES 
.................... void IO_OUTPUT_TOGGLE(int8 pin){ 
.................... #else 
.................... void IO_OUTPUT_TOGGLE(int8 address, int8 pin){ 
.................... #endif 
....................  
....................    int8 tempReg; 
....................     
....................    if(bit_test(pin, 7)){ //PIN A 
....................       #ifndef IO_MULTIPLE_DEVICES 
....................       tempReg = IO_READ_REGISTER(OLATA); 
....................       #else 
....................       tempReg = IO_READ_REGISTER(address, OLATA); 
....................       #endif 
....................       tempReg ^= (1<< (pin&0x0F)); 
....................       #ifndef IO_MULTIPLE_DEVICES 
....................       IO_WRITE_REGISTER(OLATA, tempReg); 
....................       #else 
....................       IO_WRITE_REGISTER(address, OLATA, tempReg); 
....................       #endif 
....................    }else{    //PIN B    
....................       #ifndef IO_MULTIPLE_DEVICES 
....................       tempReg = IO_READ_REGISTER(OLATB); 
....................       #else 
....................       tempReg = IO_READ_REGISTER(address, OLATB); 
....................       #endif 
....................       tempReg ^= (1<< (pin&0x0F)); 
....................       #ifndef IO_MULTIPLE_DEVICES 
....................       IO_WRITE_REGISTER(OLATB, tempReg); 
....................       #else 
....................       IO_WRITE_REGISTER(address, OLATB, tempReg); 
....................       #endif 
....................    } 
....................  
.................... } 
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// IO_OUTPUT_DRIVE 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// Sets the specified PIN to an output. 
.................... //// 
.................... //// Parameters: 
.................... ////      pin - pin to be changed. use provided defines. 
.................... ////     address - address of the device. use provided defines. 
.................... //// 
.................... //// Returns: 
.................... ////      void 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... #ifndef IO_MULTIPLE_DEVICES 
.................... void IO_OUTPUT_DRIVE(int8 pin){ 
.................... #else 
.................... void IO_OUTPUT_DRIVE(int8 address, int8 pin){ 
.................... #endif 
....................  
....................    int8 tempReg; 
....................     
....................    if(bit_test(pin, 7)){ //PIN A 
....................       #ifndef IO_MULTIPLE_DEVICES 
....................       tempReg = IO_GET_TRIS_A(); 
....................       #else 
....................       tempReg = IO_GET_TRIS_A(address); 
....................       #endif 
....................       bit_clear(tempReg, pin &0x0F); 
....................       #ifndef IO_MULTIPLE_DEVICES 
....................       IO_SET_TRIS_A(tempReg); 
....................       #else 
....................       IO_SET_TRIS_A(address, tempReg); 
....................       #endif 
....................    }else{    //PIN B    
....................       #ifndef IO_MULTIPLE_DEVICES 
....................       tempReg = IO_GET_TRIS_B(); 
....................       #else 
....................       tempReg = IO_GET_TRIS_B(address); 
....................       #endif 
....................       bit_clear(tempReg, pin);       
....................       #ifndef IO_MULTIPLE_DEVICES 
....................       IO_SET_TRIS_B(tempReg); 
....................       #else 
....................       IO_SET_TRIS_B(address, tempReg); 
....................       #endif 
....................    } 
....................  
.................... } 
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// IO_INPUT 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// Gets the specified PIN's current input. Changes the PIN's direction to an 
.................... //// input. 
.................... //// 
.................... //// Parameters: 
.................... ////      pin - pin to be read. use provided defines. 
.................... ////     address - address of the device. use provided defines. 
.................... //// 
.................... //// Returns: 
.................... ////      int1 - the state of the pin 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... #ifndef IO_MULTIPLE_DEVICES 
.................... int1 IO_INPUT(int8 pin){ 
.................... #else 
.................... int1 IO_INPUT(int8 address, int8 pin){ 
.................... #endif 
....................    int1 retVal; 
....................    int8 tempReg; 
....................     
....................    #ifndef IO_MULTIPLE_DEVICES 
....................    IO_OUTPUT_FLOAT(pin); 
....................    #else 
....................    IO_OUTPUT_FLOAT(address, pin); 
....................    #endif 
....................     
....................    if(bit_test(pin, 7)){ 
....................       #ifndef IO_MULTIPLE_DEVICES 
....................       tempReg = IO_READ_REGISTER(GPIOA); 
....................       #else 
....................       tempReg = IO_READ_REGISTER(address, GPIOA); 
....................       #endif 
....................    }else{ 
....................       #ifndef IO_MULTIPLE_DEVICES 
....................       tempReg = IO_READ_REGISTER(GPIOB); 
....................       #else 
....................       tempReg = IO_READ_REGISTER(address, GPIOB); 
....................       #endif 
....................    } 
....................    retVal = bit_test(tempReg, pin&0x0F); 
....................     
....................    return retVal; 
....................  
.................... } 
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// IO_INPUT_STATE 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// Gets the specified PIN's current input. Does NOT change the PIN's direction 
.................... //// 
.................... //// Parameters: 
.................... ////      pin - pin to be read. use provided defines. 
.................... ////     address - address of the device. use provided defines. 
.................... //// 
.................... //// Returns: 
.................... ////      int1 - the state of the pin 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... #ifndef IO_MULTIPLE_DEVICES 
.................... int1 IO_INPUT_STATE(int8 pin){ 
.................... #else 
.................... int1 IO_INPUT_STATE(int8 address, int8 pin){ 
.................... #endif 
....................    int1 retVal; 
....................    int8 tempReg; 
....................     
....................    if(bit_test(pin, 7)){ 
....................       #ifndef IO_MULTIPLE_DEVICES 
....................       tempReg = IO_READ_REGISTER(GPIOA); 
....................       #else 
....................       tempReg = IO_READ_REGISTER(address, GPIOA); 
....................       #endif 
....................    }else{ 
....................       #ifndef IO_MULTIPLE_DEVICES 
....................       tempReg = IO_READ_REGISTER(GPIOB); 
....................       #else 
....................       tempReg = IO_READ_REGISTER(address, GPIOB); 
....................       #endif 
....................    } 
....................    retVal = bit_test(tempReg, pin&0x0F); 
....................     
....................    return retVal; 
....................  
.................... } 
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// IO_GET_TRIS_A 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// Gets the device's port A data direction register. 
.................... //// 
.................... //// Parameters: 
.................... ////     address - address of the device. use provided defines. 
.................... //// 
.................... //// Returns: 
.................... ////      The device's IODIRB register value 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... #ifndef IO_MULTIPLE_DEVICES 
.................... int8 IO_GET_TRIS_A(){ 
.................... #else 
.................... int8 IO_GET_TRIS_A(int8 address){ 
.................... #endif 
....................  
....................    int8 retVal; 
....................     
....................    #ifndef IO_MULTIPLE_DEVICES 
....................    retVal = IO_READ_REGISTER(IODIRA); 
....................    #else 
....................    retVal = IO_READ_REGISTER(address, IODIRA); 
....................    #endif 
....................     
....................    return retVal; 
....................  
.................... } 
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// IO_SET_TRIS_A 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// Sets the device's port A data direction register to the specified value. 
.................... //// 
.................... //// Parameters: 
.................... ////      data - value to be written to the register 
.................... ////     address - address of the device. use provided defines. 
.................... //// 
.................... //// Returns: 
.................... ////      void 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... #ifndef IO_MULTIPLE_DEVICES 
.................... void IO_SET_TRIS_A(int8 data){ 
.................... #else 
.................... void IO_SET_TRIS_A(int8 address, int8 data){ 
.................... #endif 
....................     
....................    #ifndef IO_MULTIPLE_DEVICES 
....................    IO_WRITE_REGISTER(IODIRA, data); 
....................    #else 
....................    IO_WRITE_REGISTER(address, IODIRA, data); 
*
06BC:  MOVFF  1AB,1B5
06C0:  MOVLB  1
06C2:  CLRF   xB6
06C4:  MOVFF  1AC,1B7
06C8:  MOVLB  0
06CA:  RCALL  05F4
....................    #endif 
....................  
.................... } 
06CC:  RETLW  00
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// IO_GET_TRIS_B 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// Gets the device's port B data direction register. 
.................... //// 
.................... //// Parameters: 
.................... ////     address - address of the device. use provided defines. 
.................... //// 
.................... //// Returns: 
.................... ////      The device's IODIRB register value 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... #ifndef IO_MULTIPLE_DEVICES 
.................... int8 IO_GET_TRIS_B(){ 
.................... #else 
.................... int8 IO_GET_TRIS_B(int8 address){ 
.................... #endif 
....................  
....................    int8 retVal; 
....................     
....................    #ifndef IO_MULTIPLE_DEVICES 
....................    retVal = IO_READ_REGISTER(IODIRB); 
....................    #else 
....................    retVal = IO_READ_REGISTER(address, IODIRB); 
....................    #endif 
....................     
....................    return retVal; 
....................  
.................... } 
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// IO_SET_TRIS_B 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// Sets the device's port B data direction register to the specified value. 
.................... //// 
.................... //// Parameters: 
.................... ////      data - value to be written to the register 
.................... ////     address - address of the device. use provided defines. 
.................... //// 
.................... //// Returns: 
.................... ////      void 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... #ifndef IO_MULTIPLE_DEVICES 
.................... void IO_SET_TRIS_B(int8 data){ 
.................... #else 
.................... void IO_SET_TRIS_B(int8 address, int8 data){ 
.................... #endif 
....................  
....................    #ifndef IO_MULTIPLE_DEVICES 
....................    IO_WRITE_REGISTER(IODIRB, data); 
....................    #else 
....................    IO_WRITE_REGISTER(address, IODIRB, data); 
06CE:  MOVFF  1AB,1B5
06D2:  MOVLW  10
06D4:  MOVLB  1
06D6:  MOVWF  xB6
06D8:  MOVFF  1AC,1B7
06DC:  MOVLB  0
06DE:  RCALL  05F4
....................    #endif 
....................  
.................... } 
06E0:  RETLW  00
....................  
.................... #endif 
....................  
....................  
.................... #define Pled        PIN_B5 
.................... #define I2C_SDA     PIN_C4 
.................... #define I2C_SCL     PIN_C3 
....................  
.................... #define Pack        PIN_C0 
.................... #define Preset      PIN_C1 
.................... #define Ptest       PIN_C2 
....................  
.................... #define Pbell       PIN_A3 
.................... #define Pbuzzer     PIN_A4 
....................  
.................... #define P485ctrl    PIN_B3       // ---jj 
.................... #define PTxD        PIN_C6 
.................... #define PRxD        PIN_C7 
....................  
.................... //#define PsyncR      PIN_B3 
.................... //#define PsyncS      PIN_B4 
....................  
.................... #define EXP_OUT_ENABLE  PIN_B0 
.................... #define EXP_OUT_CLOCK   PIN_B1 
.................... #define EXP_OUT_DO      PIN_B2 
....................  
.................... #define Red       0 
.................... #define Green     1 
.................... #define Ambian    2 
....................  
.................... //#define NUMBER_OF_595 8 
....................  
.................... #use rs232(baud=9600,parity=N,xmit=PTxD,rcv=PRxD,bits=8,restart_wdt) 
*
1AB4:  CLRWDT
1AB6:  BTFSS  F9E.4
1AB8:  BRA    1AB4
1ABA:  MOVWF  FAD
1ABC:  RETLW  00
....................  
.................... //#USE SPI (  FORCE_HW, BITS=16, ENABLE=IO_CS_PIN, SAMPLE_RISE, stream=SPI_STREAM)  
.................... //#USE SPI (  FORCE_HW, BITS=16, ENABLE=IO_CS_PIN, SAMPLE_RISE, stream=SPI_STREAM2) 
....................  
.................... //#use spi(MASTER, MODE=0, SPI1, FORCE_HW) 
.................... //#use spi(MASTER, MSB_FIRST, BITS=8, MODE=0, BAUD=100000) 
.................... //#use spi(DI=PIN_B1, DO=PIN_B0, CLK=PIN_B2, ENABLE=PIN_B4, BITS=8) 
....................  
.................... void check_ack(void); 
.................... void check_test(void); 
.................... void check_reset(void); 
.................... int1 CheckAutoReset(unsigned char DatType); 
.................... void Read_Config(void); 
.................... void ForceAllAlarm(void); 
.................... void Read_input(void); 
....................  
.................... int8 StatusTime = 0;         //Hearth beat LED Timer 
.................... int1 HearthbeatInd = 0;      //Hearth beat Indicator 
.................... int8 FlashingRateTime = 25; 
.................... int1 FlashingFlag = 0; 
.................... int8 TimeBase1s = 100; 
.................... int8 AutoAckDelayTime = 0; 
....................  
.................... int8 Input1_8_Send; 
.................... int8 Input9_16_Send; 
.................... int8 Input17_24_Send; 
.................... int8 Input25_32_Send; 
.................... int8 Input33_40_Send; 
.................... int8 Input41_48_Send; 
.................... int8 Input49_56_Send; 
.................... int8 Input57_64_Send; 
....................  
.................... int8 Ack1_8_Send; 
.................... int8 Ack9_16_Send; 
.................... int8 Ack17_24_Send; 
.................... int8 Ack25_32_Send; 
.................... int8 Ack33_40_Send; 
.................... int8 Ack41_48_Send; 
.................... int8 Ack49_56_Send; 
.................... int8 Ack57_64_Send; 
....................  
.................... int1 AutoAckFlag = 0; 
.................... int1 AutoResetFlag = 0; 
.................... int1 AutoTestFlag = 0; 
....................  
.................... int8 SBUF = 0x00; 
....................  
.................... int1 Test_fault = 0; 
.................... int8 T_test = 0x00; 
....................  
.................... int1 Test = 0; 
.................... int1 Ack_F = 0; 
.................... int1 Reset_F = 0; 
....................  
.................... int1 SyncStatus = 0;   //"0" -> No Sync signal 
.................... int1 SyncFlag = 0;     //use for debounce sync signal 
.................... int8 Synctimer = 0x00; //use for debounce sync signal 
....................  
.................... //int8 Input1_8; 
.................... int8 Input9_16; 
....................  
....................  
.................... int8 Output1_8; 
.................... int8 Output9_16; 
....................  
.................... int8 Output595[4]; 
....................  
.................... int8 tempdata; 
.................... //int8 EEP_Config = 0x00;   // 
.................... //int8 NUMBER_OF_595 ; 
....................  
.................... int8 EEpDat; 
....................  
.................... ///////// Data from EEProm /////// 
.................... //int Device_Addr; 
....................  
.................... int8 InputType1_8; 
.................... int8 InputType9_16; 
.................... int8 InputType17_24; 
....................  
.................... int8 FaultType1_8; 
.................... int8 FaultType9_16; 
.................... int8 FaultType17_24; 
....................  
....................  
.................... int8 OutputType1_8; 
.................... int8 OutputType9_16; 
.................... int8 OutputType17_24; 
....................  
.................... int8 OutputBoth1_8; 
.................... int8 OutputBoth9_16; 
.................... int8 OutputBoth17_24; 
....................  
.................... int8 Alarm_Indicator1_8; 
.................... int8 Alarm_Indicator9_16; 
.................... int8 Alarm_Indicator17_24; 
....................  
.................... int8 Input1_8; 
.................... int8 Input9_10; 
.................... int8 Input11_18; 
.................... int8 Input19_20; 
....................  
.................... int8 Red1_8; 
.................... int8 Red9_10 ; 
.................... int8 Red11_18 ; 
.................... int8 Red19_20 ; 
.................... int8 Green1_8 ; 
.................... int8 Green9_10 ; 
.................... int8 Green11_18 ; 
.................... int8 Green19_20 ; 
....................  
.................... int8 OUTRed1_8; 
.................... int8 OUTRed9_10 ; 
.................... int8 OUTRed11_18 ; 
.................... int8 OUTRed19_20 ; 
.................... int8 OUTGreen1_8 ; 
.................... int8 OUTGreen9_10 ; 
.................... int8 OUTGreen11_18 ; 
.................... int8 OUTGreen19_20 ; 
....................  
.................... int8 AutoAck; 
.................... int8 AutoAckTime; 
.................... int8 FlashingRate; 
.................... int8 NoOfPoint; 
.................... int8 MasterSlaveSync; 
....................  
.................... volatile int1 RefreshConfigData =0; 
.................... //////////////////////////////// 
.................... ///////// tempolary register ////////// 
.................... //int8 temp; 
.................... //int1 RxDreceive = 0; 
....................  
.................... ////////////////////////////////////// 
.................... unsigned char const addr_sq = 0x10,end_sq = 0x11,code_sq = 0x12,start_addr_hi_sq = 0x13,start_addr_lo_sq = 0x14;         //serial sequnce 
.................... unsigned char const ubyte_hi_sq = 0x15,ubyte_lo_sq = 0x16,crc_hi_sq = 0x17,byte_count_sq = 0x19,data_sq = 0x20;      //serial sequnce 
....................  
....................  
.................... int1 recieve_completed = 0; 
.................... unsigned char sequence;         //keep sequence use for RxD 
.................... unsigned char Address; 
.................... unsigned char RxD_DataLen = 0x00; 
.................... unsigned char TxD_Buff[60]; 
.................... unsigned char RxD_Buff[60]; 
.................... unsigned char CRC_Lo; 
.................... unsigned char CRC_Hi; 
.................... int16 Send_check_Time = 500; //if no send reset buffer every 5 second 
....................  
.................... int16 Start_Address = 0x0000; 
.................... int16 No_PointCount = 0x0000; 
.................... unsigned char Data_ByteCount = 0x00; 
.................... unsigned char Data_Buff[25]; 
.................... //unsigned char DataTemp; 
.................... //unsigned char TxD_DataLen; 
....................  
.................... int8 MCP23s17_Ip_dat; 
....................  
....................  
.................... int8 MCP23s17_Op_dat; 
....................  
.................... unsigned char T_timeout;   //use for calculate RxD timeout 
.................... unsigned char index = 0x00;         //use for Loop 
....................  
.................... int8 outmcp23 = 0; 
....................  
.................... unsigned char const CRC_Table_Hi[] = { 
.................... 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 
.................... 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 
.................... 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 
.................... 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 
.................... 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 
.................... 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 
.................... 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 
.................... 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 
.................... 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 
.................... 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 
.................... 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 
.................... 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 
.................... 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81,  
.................... 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 
.................... 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01,  
.................... 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 
.................... 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 
.................... 0x40 
.................... } ;  
....................  
.................... unsigned  char const CRC_Table_Lo[] = { 
.................... 0x00, 0xC0, 0xC1, 0x01, 0xC3, 0x03, 0x02, 0xC2, 0xC6, 0x06, 0x07, 0xC7, 0x05, 0xC5, 0xC4, 
.................... 0x04, 0xCC, 0x0C, 0x0D, 0xCD, 0x0F, 0xCF, 0xCE, 0x0E, 0x0A, 0xCA, 0xCB, 0x0B, 0xC9, 0x09, 
.................... 0x08, 0xC8, 0xD8, 0x18, 0x19, 0xD9, 0x1B, 0xDB, 0xDA, 0x1A, 0x1E, 0xDE, 0xDF, 0x1F, 0xDD, 
.................... 0x1D, 0x1C, 0xDC, 0x14, 0xD4, 0xD5, 0x15, 0xD7, 0x17, 0x16, 0xD6, 0xD2, 0x12, 0x13, 0xD3, 
.................... 0x11, 0xD1, 0xD0, 0x10, 0xF0, 0x30, 0x31, 0xF1, 0x33, 0xF3, 0xF2, 0x32, 0x36, 0xF6, 0xF7, 
.................... 0x37, 0xF5, 0x35, 0x34, 0xF4, 0x3C, 0xFC, 0xFD, 0x3D, 0xFF, 0x3F, 0x3E, 0xFE, 0xFA, 0x3A, 
.................... 0x3B, 0xFB, 0x39, 0xF9, 0xF8, 0x38, 0x28, 0xE8, 0xE9, 0x29, 0xEB, 0x2B, 0x2A, 0xEA, 0xEE, 
.................... 0x2E, 0x2F, 0xEF, 0x2D, 0xED, 0xEC, 0x2C, 0xE4, 0x24, 0x25, 0xE5, 0x27, 0xE7, 0xE6, 0x26,  
.................... 0x22, 0xE2, 0xE3, 0x23, 0xE1, 0x21, 0x20, 0xE0, 0xA0, 0x60, 0x61, 0xA1, 0x63, 0xA3, 0xA2, 
.................... 0x62, 0x66, 0xA6, 0xA7, 0x67, 0xA5, 0x65, 0x64, 0xA4, 0x6C, 0xAC, 0xAD, 0x6D, 0xAF, 0x6F,  
.................... 0x6E, 0xAE, 0xAA, 0x6A, 0x6B, 0xAB, 0x69, 0xA9, 0xA8, 0x68, 0x78, 0xB8, 0xB9, 0x79, 0xBB, 
.................... 0x7B, 0x7A, 0xBA, 0xBE, 0x7E, 0x7F, 0xBF, 0x7D, 0xBD, 0xBC, 0x7C, 0xB4, 0x74, 0x75, 0xB5,  
.................... 0x77, 0xB7, 0xB6, 0x76, 0x72, 0xB2, 0xB3, 0x73, 0xB1, 0x71, 0x70, 0xB0, 0x50, 0x90, 0x91, 
.................... 0x51, 0x93, 0x53, 0x52, 0x92, 0x96, 0x56, 0x57, 0x97, 0x55, 0x95, 0x94, 0x54, 0x9C, 0x5C, 
.................... 0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E, 0x5A, 0x9A, 0x9B, 0x5B, 0x99, 0x59, 0x58, 0x98, 0x88, 
.................... 0x48, 0x49, 0x89, 0x4B, 0x8B, 0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C, 
.................... 0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83, 0x41, 0x81, 0x80, 
.................... 0x40 
.................... } ; 
....................  
.................... ///////////// Define Bit register //////////////////////////// 
....................  
.................... struct Bit64    // Input 
.................... { 
....................    int1 B1,B2,B3,B4,B5,B6,B7,B8,B9,B10; 
....................    //int1 B11,B12,B13,B14,B15,B16,B17,B18,B19,B20; 
....................    //int1 B21,B22,B23,B24,B25,B26,B27,B28,B29,B30; 
....................    //int1 B31,B32,B33,B34,B35,B36,B37,B38,B39,B40; 
....................    //int1 B41,B42,B43,B44,B45,B46,B47,B48,B49,B50; 
....................    //int1 B51,B52,B53,B54,B55,B56,B57,B58,B59,B60; 
....................    //int1 B61,B62,B63,B64; 
.................... }; 
....................  
....................  
....................    //Output   (LED Lit = "0") 
....................    //Input Type NO/NC (NO = "1" , NC = "0") 
....................    //Fault Type Manual/Auto (Manual = "1" , Auto = "0") 
....................    //Output Type Buz/Bell (Buzzer = "1" , Bell = "0") 
....................    //Output Both (Normal = "1" , Both = "0") 
....................    //Acknowledge flag (Acked = "1" , non Ack = "0") 
....................  
.................... struct Bit64 Inputt,Output,InputType,FaultType,OutputType,OutputBoth; 
.................... struct Bit64 AlarmIndicator,Ack,In,In2; 
.................... struct Bit64 LED_Colour,AckSend,RED_Colour,GREEN_Colour; 
....................  
.................... int1 FaultAgo[30]; 
.................... int1 FaultNow[30]; 
.................... int16 ReleaseTime[30]; 
.................... int16 FaultDelayTime[30]; 
....................  
.................... int1 FaultNCNO[11]; 
.................... #define NO 1 
.................... #define NC 0 
....................  
.................... //////////////////////////////--Function--///////////////////////////////////////////////// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ///////////////////////////////MODBUS Routine////////////////////////////////// 
.................... /////////////////////////////////////////////////////////////////////////////// 
....................  
.................... void StoreReleaseFault() 
.................... { 
*
0FAE:  MOVLB  1
0FB0:  CLRF   xAC
....................    Signed int8 i=0; 
....................    for(i=0;i<=10;i++) 
0FB2:  CLRF   xAC
0FB4:  BTFSC  xAC.7
0FB6:  BRA    0FBE
0FB8:  MOVF   xAC,W
0FBA:  SUBLW  0A
0FBC:  BNC   0FEC
....................    { 
....................       FaultAgo[i] = FaultNow[i]; 
0FBE:  CLRF   xAE
0FC0:  CLRF   xAE
0FC2:  MOVFF  1AC,1AD
0FC6:  MOVLW  01
0FC8:  MOVWF  xAF
0FCA:  MOVLW  2A
0FCC:  MOVWF  xAE
0FCE:  MOVLB  0
0FD0:  RCALL  0F18
0FD2:  MOVLB  1
0FD4:  CLRF   xAE
0FD6:  BTFSC  01.0
0FD8:  INCF   xAE,F
0FDA:  MOVLW  01
0FDC:  MOVWF  xB0
0FDE:  MOVLW  26
0FE0:  MOVWF  xAF
0FE2:  MOVLB  0
0FE4:  RCALL  0F6C
....................    } 
0FE6:  MOVLB  1
0FE8:  INCF   xAC,F
0FEA:  BRA    0FB4
.................... } 
0FEC:  MOVLB  0
0FEE:  GOTO   166C (RETURN)
....................  
....................  
.................... void CRC(unsigned char *puchMsg , unsigned char usDataLen) 
.................... {  
....................    unsigned char uIndex ;                   /* fill index into CRC lookup table */ 
....................    unsigned char i ; 
....................  
....................    CRC_Hi = 0xFF ;                      /* high byte of CRC initialized */ 
*
1A46:  MOVLW  FF
1A48:  MOVWF  xE4
....................    CRC_Lo = 0xFF ;                      /* low byte of CRC initialized */ 
1A4A:  MOVWF  xE3
....................  
....................    for(i = 0;i < usDataLen;i++) 
1A4C:  MOVLB  1
1A4E:  CLRF   xB0
1A50:  MOVF   xAE,W
1A52:  SUBWF  xB0,W
1A54:  BC    1AB0
....................    { 
....................       restart_wdt(); 
1A56:  CLRWDT
....................       uIndex = CRC_Hi ^ (unsigned char) puchMsg[i] ; 
1A58:  CLRF   03
1A5A:  MOVF   xB0,W
1A5C:  ADDWF  xAC,W
1A5E:  MOVWF  FE9
1A60:  MOVF   xAD,W
1A62:  ADDWFC 03,W
1A64:  MOVWF  FEA
1A66:  MOVF   FEF,W
1A68:  MOVLB  0
1A6A:  XORWF  xE4,W
1A6C:  MOVLB  1
1A6E:  MOVWF  xAF
....................       CRC_Hi = CRC_Lo ^ CRC_Table_Hi[uIndex] ; 
1A70:  CLRF   03
1A72:  MOVF   xAF,W
1A74:  MOVFF  FF2,1B1
1A78:  BCF    FF2.7
1A7A:  MOVLB  0
1A7C:  CALL   00AE
1A80:  MOVLB  1
1A82:  BTFSC  xB1.7
1A84:  BSF    FF2.7
1A86:  MOVWF  01
1A88:  MOVLB  0
1A8A:  MOVF   xE3,W
1A8C:  XORWF  01,W
1A8E:  MOVWF  xE4
....................       CRC_Lo = CRC_Table_Lo[uIndex] ; 
1A90:  CLRF   03
1A92:  MOVLB  1
1A94:  MOVF   xAF,W
1A96:  MOVFF  FF2,1B1
1A9A:  BCF    FF2.7
1A9C:  MOVLB  0
1A9E:  CALL   01C8
1AA2:  MOVLB  1
1AA4:  BTFSC  xB1.7
1AA6:  BSF    FF2.7
1AA8:  MOVFF  FE8,E3
....................    } 
1AAC:  INCF   xB0,F
1AAE:  BRA    1A50
.................... } 
1AB0:  MOVLB  0
1AB2:  RETLW  00
....................  
.................... /********************************6B595 Driver*********************************/ 
.................... void Driver595() 
.................... { 
*
489C:  MOVLB  1
489E:  CLRF   xAB
....................    Signed int8 j=0; 
....................    int8 data_out ; 
....................  
....................    restart_wdt(); 
48A0:  CLRWDT
....................     
....................     data_out = (~Input19_20); 
48A2:  MOVFF  4A,1AC
48A6:  COMF   xAC,F
....................     for(j=7;j>=0;j--) 
48A8:  MOVLW  07
48AA:  MOVWF  xAB
48AC:  BTFSC  xAB.7
48AE:  BRA    48E0
....................     { 
....................      //output_bit(EXP_OUT_DO,bit_test(Output595[i],j)); 
....................      output_bit(EXP_OUT_DO,bit_test(data_out,j)); 
48B0:  MOVFF  1AC,00
48B4:  MOVF   xAB,W
48B6:  MOVWF  01
48B8:  BZ    48C2
48BA:  BCF    FD8.0
48BC:  RRCF   00,F
48BE:  DECFSZ 01,F
48C0:  BRA    48BA
48C2:  BTFSC  00.0
48C4:  BRA    48CA
48C6:  BCF    F8A.2
48C8:  BRA    48CC
48CA:  BSF    F8A.2
48CC:  BCF    F93.2
....................      output_high(EXP_OUT_CLOCK); 
48CE:  BCF    F93.1
48D0:  BSF    F8A.1
....................      delay_us(1); 
48D2:  CLRWDT
48D4:  BRA    48D6
48D6:  BRA    48D8
....................      output_low(EXP_OUT_CLOCK); 
48D8:  BCF    F93.1
48DA:  BCF    F8A.1
....................     } 
48DC:  DECF   xAB,F
48DE:  BRA    48AC
....................      
....................     data_out = (~Input11_18); 
48E0:  MOVFF  49,1AC
48E4:  COMF   xAC,F
....................     for(j=7;j>=0;j--) 
48E6:  MOVLW  07
48E8:  MOVWF  xAB
48EA:  BTFSC  xAB.7
48EC:  BRA    491E
....................     { 
....................      //output_bit(EXP_OUT_DO,bit_test(Output595[i],j)); 
....................      output_bit(EXP_OUT_DO,bit_test(data_out,j)); 
48EE:  MOVFF  1AC,00
48F2:  MOVF   xAB,W
48F4:  MOVWF  01
48F6:  BZ    4900
48F8:  BCF    FD8.0
48FA:  RRCF   00,F
48FC:  DECFSZ 01,F
48FE:  BRA    48F8
4900:  BTFSC  00.0
4902:  BRA    4908
4904:  BCF    F8A.2
4906:  BRA    490A
4908:  BSF    F8A.2
490A:  BCF    F93.2
....................      output_high(EXP_OUT_CLOCK); 
490C:  BCF    F93.1
490E:  BSF    F8A.1
....................      delay_us(1); 
4910:  CLRWDT
4912:  BRA    4914
4914:  BRA    4916
....................      output_low(EXP_OUT_CLOCK); 
4916:  BCF    F93.1
4918:  BCF    F8A.1
....................     } 
491A:  DECF   xAB,F
491C:  BRA    48EA
....................      
....................     data_out = (~Input9_10); 
491E:  MOVFF  48,1AC
4922:  COMF   xAC,F
....................     for(j=7;j>=0;j--) 
4924:  MOVLW  07
4926:  MOVWF  xAB
4928:  BTFSC  xAB.7
492A:  BRA    495C
....................     { 
....................      //output_bit(EXP_OUT_DO,bit_test(Output595[i],j)); 
....................      output_bit(EXP_OUT_DO,bit_test(data_out,j)); 
492C:  MOVFF  1AC,00
4930:  MOVF   xAB,W
4932:  MOVWF  01
4934:  BZ    493E
4936:  BCF    FD8.0
4938:  RRCF   00,F
493A:  DECFSZ 01,F
493C:  BRA    4936
493E:  BTFSC  00.0
4940:  BRA    4946
4942:  BCF    F8A.2
4944:  BRA    4948
4946:  BSF    F8A.2
4948:  BCF    F93.2
....................      output_high(EXP_OUT_CLOCK); 
494A:  BCF    F93.1
494C:  BSF    F8A.1
....................      delay_us(1); 
494E:  CLRWDT
4950:  BRA    4952
4952:  BRA    4954
....................      output_low(EXP_OUT_CLOCK); 
4954:  BCF    F93.1
4956:  BCF    F8A.1
....................     } 
4958:  DECF   xAB,F
495A:  BRA    4928
....................      
....................     data_out = (~Input1_8); 
495C:  MOVFF  47,1AC
4960:  COMF   xAC,F
....................     for(j=7;j>=0;j--) 
4962:  MOVLW  07
4964:  MOVWF  xAB
4966:  BTFSC  xAB.7
4968:  BRA    499A
....................     { 
....................      //output_bit(EXP_OUT_DO,bit_test(Output595[i],j)); 
....................      output_bit(EXP_OUT_DO,bit_test(data_out,j)); 
496A:  MOVFF  1AC,00
496E:  MOVF   xAB,W
4970:  MOVWF  01
4972:  BZ    497C
4974:  BCF    FD8.0
4976:  RRCF   00,F
4978:  DECFSZ 01,F
497A:  BRA    4974
497C:  BTFSC  00.0
497E:  BRA    4984
4980:  BCF    F8A.2
4982:  BRA    4986
4984:  BSF    F8A.2
4986:  BCF    F93.2
....................      output_high(EXP_OUT_CLOCK); 
4988:  BCF    F93.1
498A:  BSF    F8A.1
....................      delay_us(1); 
498C:  CLRWDT
498E:  BRA    4990
4990:  BRA    4992
....................      output_low(EXP_OUT_CLOCK); 
4992:  BCF    F93.1
4994:  BCF    F8A.1
....................     } 
4996:  DECF   xAB,F
4998:  BRA    4966
....................  // }  
....................    output_high(EXP_OUT_ENABLE); 
499A:  BCF    F93.0
499C:  BSF    F8A.0
....................    delay_us(1); 
499E:  CLRWDT
49A0:  BRA    49A2
49A2:  BRA    49A4
....................    output_low(EXP_OUT_ENABLE); 
49A4:  BCF    F93.0
49A6:  BCF    F8A.0
.................... } 
49A8:  MOVLB  0
49AA:  GOTO   4F94 (RETURN)
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... /////////////////////////////////////////////////////////////////////////////// 
....................  
.................... void Alarmtosend(void) 
.................... { 
....................    Input1_8_Send = 0x00; 
*
1ABE:  CLRF   1B
....................    Input9_16_Send = 0x00; 
1AC0:  CLRF   1C
....................     
....................     
....................    Ack1_8_Send = 0x00; 
1AC2:  CLRF   23
....................    Ack9_16_Send = 0x00; 
1AC4:  CLRF   24
....................  
....................     
....................    ///////////////////////////////////////////////////// 
....................    
....................    if((In.B1 == 0) && (Output.B1 ==0)) 
1AC6:  MOVLB  1
1AC8:  BTFSC  x1A.0
1ACA:  BRA    1AD4
1ACC:  BTFSC  x0C.0
1ACE:  BRA    1AD4
....................       AckSend.B1 = 1; 
1AD0:  BSF    x20.0
....................    else 
1AD2:  BRA    1AD6
....................       AckSend.B1 = 0; 
1AD4:  BCF    x20.0
....................    if((In.B2 == 0) && (Output.B2 ==0)) 
1AD6:  BTFSC  x1A.1
1AD8:  BRA    1AE2
1ADA:  BTFSC  x0C.1
1ADC:  BRA    1AE2
....................       AckSend.B2 = 1; 
1ADE:  BSF    x20.1
....................    else 
1AE0:  BRA    1AE4
....................       AckSend.B2 = 0; 
1AE2:  BCF    x20.1
....................    if((In.B3 == 0) && (Output.B3 ==0)) 
1AE4:  BTFSC  x1A.2
1AE6:  BRA    1AF0
1AE8:  BTFSC  x0C.2
1AEA:  BRA    1AF0
....................       AckSend.B3 = 1; 
1AEC:  BSF    x20.2
....................    else 
1AEE:  BRA    1AF2
....................       AckSend.B3 = 0; 
1AF0:  BCF    x20.2
....................    if((In.B4 == 0) && (Output.B4 ==0)) 
1AF2:  BTFSC  x1A.3
1AF4:  BRA    1AFE
1AF6:  BTFSC  x0C.3
1AF8:  BRA    1AFE
....................       AckSend.B4 = 1; 
1AFA:  BSF    x20.3
....................    else 
1AFC:  BRA    1B00
....................       AckSend.B4 = 0; 
1AFE:  BCF    x20.3
....................    if((In.B5 == 0) && (Output.B5 ==0)) 
1B00:  BTFSC  x1A.4
1B02:  BRA    1B0C
1B04:  BTFSC  x0C.4
1B06:  BRA    1B0C
....................       AckSend.B5 = 1; 
1B08:  BSF    x20.4
....................    else 
1B0A:  BRA    1B0E
....................       AckSend.B5 = 0; 
1B0C:  BCF    x20.4
....................    if((In.B6 == 0) && (Output.B6 ==0)) 
1B0E:  BTFSC  x1A.5
1B10:  BRA    1B1A
1B12:  BTFSC  x0C.5
1B14:  BRA    1B1A
....................       AckSend.B6 = 1; 
1B16:  BSF    x20.5
....................    else 
1B18:  BRA    1B1C
....................       AckSend.B6 = 0; 
1B1A:  BCF    x20.5
....................    if((In.B7 == 0) && (Output.B7 ==0)) 
1B1C:  BTFSC  x1A.6
1B1E:  BRA    1B28
1B20:  BTFSC  x0C.6
1B22:  BRA    1B28
....................       AckSend.B7 = 1; 
1B24:  BSF    x20.6
....................    else 
1B26:  BRA    1B2A
....................       AckSend.B7 = 0; 
1B28:  BCF    x20.6
....................    if((In.B8 == 0) && (Output.B8 ==0)) 
1B2A:  BTFSC  x1A.7
1B2C:  BRA    1B36
1B2E:  BTFSC  x0C.7
1B30:  BRA    1B36
....................       AckSend.B8 = 1; 
1B32:  BSF    x20.7
....................    else 
1B34:  BRA    1B38
....................       AckSend.B8 = 0; 
1B36:  BCF    x20.7
....................    if((In.B9 == 0) && (Output.B9 ==0)) 
1B38:  BTFSC  x1B.0
1B3A:  BRA    1B44
1B3C:  BTFSC  x0D.0
1B3E:  BRA    1B44
....................       AckSend.B9 = 1; 
1B40:  BSF    x21.0
....................    else 
1B42:  BRA    1B46
....................       AckSend.B9 = 0; 
1B44:  BCF    x21.0
....................    if((In.B10 == 0) && (Output.B10 ==0)) 
1B46:  BTFSC  x1B.1
1B48:  BRA    1B52
1B4A:  BTFSC  x0D.1
1B4C:  BRA    1B52
....................       AckSend.B10 = 1; 
1B4E:  BSF    x21.1
....................    else 
1B50:  BRA    1B54
....................       AckSend.B10 = 0; 
1B52:  BCF    x21.1
....................  
....................     
....................     
....................     
....................    ///////////////////Ack///////////////////////////////// 
....................    Ack1_8_Send = Ack1_8_Send | AckSend.B8; 
1B54:  MOVLW  00
1B56:  BTFSC  x20.7
1B58:  MOVLW  01
1B5A:  IORWF  23,F
....................    Ack1_8_Send = (Ack1_8_Send << 1) | AckSend.B7; 
1B5C:  BCF    FD8.0
1B5E:  RLCF   23,W
1B60:  MOVWF  xAB
1B62:  MOVLW  00
1B64:  BTFSC  x20.6
1B66:  MOVLW  01
1B68:  IORWF  xAB,W
1B6A:  MOVWF  23
....................    Ack1_8_Send = (Ack1_8_Send << 1) | AckSend.B6; 
1B6C:  BCF    FD8.0
1B6E:  RLCF   23,W
1B70:  MOVWF  xAB
1B72:  MOVLW  00
1B74:  BTFSC  x20.5
1B76:  MOVLW  01
1B78:  IORWF  xAB,W
1B7A:  MOVWF  23
....................    Ack1_8_Send = (Ack1_8_Send << 1) | AckSend.B5; 
1B7C:  BCF    FD8.0
1B7E:  RLCF   23,W
1B80:  MOVWF  xAB
1B82:  MOVLW  00
1B84:  BTFSC  x20.4
1B86:  MOVLW  01
1B88:  IORWF  xAB,W
1B8A:  MOVWF  23
....................    Ack1_8_Send = (Ack1_8_Send << 1) | AckSend.B4; 
1B8C:  BCF    FD8.0
1B8E:  RLCF   23,W
1B90:  MOVWF  xAB
1B92:  MOVLW  00
1B94:  BTFSC  x20.3
1B96:  MOVLW  01
1B98:  IORWF  xAB,W
1B9A:  MOVWF  23
....................    Ack1_8_Send = (Ack1_8_Send << 1) | AckSend.B3; 
1B9C:  BCF    FD8.0
1B9E:  RLCF   23,W
1BA0:  MOVWF  xAB
1BA2:  MOVLW  00
1BA4:  BTFSC  x20.2
1BA6:  MOVLW  01
1BA8:  IORWF  xAB,W
1BAA:  MOVWF  23
....................    Ack1_8_Send = (Ack1_8_Send << 1) | AckSend.B2; 
1BAC:  BCF    FD8.0
1BAE:  RLCF   23,W
1BB0:  MOVWF  xAB
1BB2:  MOVLW  00
1BB4:  BTFSC  x20.1
1BB6:  MOVLW  01
1BB8:  IORWF  xAB,W
1BBA:  MOVWF  23
....................    Ack1_8_Send = (Ack1_8_Send << 1) | AckSend.B1; 
1BBC:  BCF    FD8.0
1BBE:  RLCF   23,W
1BC0:  MOVWF  xAB
1BC2:  MOVLW  00
1BC4:  BTFSC  x20.0
1BC6:  MOVLW  01
1BC8:  IORWF  xAB,W
1BCA:  MOVWF  23
....................     
....................    Ack9_16_Send = Ack9_16_Send | AckSend.B10; 
1BCC:  MOVLW  00
1BCE:  BTFSC  x21.1
1BD0:  MOVLW  01
1BD2:  IORWF  24,F
....................    Ack9_16_Send = (Ack9_16_Send << 1) | AckSend.B9; 
1BD4:  BCF    FD8.0
1BD6:  RLCF   24,W
1BD8:  MOVWF  xAB
1BDA:  MOVLW  00
1BDC:  BTFSC  x21.0
1BDE:  MOVLW  01
1BE0:  IORWF  xAB,W
1BE2:  MOVWF  24
....................    
....................    ///////////////////Fault///////////////////////////////// 
....................    Input1_8_Send = Input1_8_Send | In.B8; 
1BE4:  MOVLW  00
1BE6:  BTFSC  x1A.7
1BE8:  MOVLW  01
1BEA:  IORWF  1B,F
....................    Input1_8_Send = (Input1_8_Send << 1) | In.B7; 
1BEC:  BCF    FD8.0
1BEE:  RLCF   1B,W
1BF0:  MOVWF  xAB
1BF2:  MOVLW  00
1BF4:  BTFSC  x1A.6
1BF6:  MOVLW  01
1BF8:  IORWF  xAB,W
1BFA:  MOVWF  1B
....................    Input1_8_Send = (Input1_8_Send << 1) | In.B6; 
1BFC:  BCF    FD8.0
1BFE:  RLCF   1B,W
1C00:  MOVWF  xAB
1C02:  MOVLW  00
1C04:  BTFSC  x1A.5
1C06:  MOVLW  01
1C08:  IORWF  xAB,W
1C0A:  MOVWF  1B
....................    Input1_8_Send = (Input1_8_Send << 1) | In.B5; 
1C0C:  BCF    FD8.0
1C0E:  RLCF   1B,W
1C10:  MOVWF  xAB
1C12:  MOVLW  00
1C14:  BTFSC  x1A.4
1C16:  MOVLW  01
1C18:  IORWF  xAB,W
1C1A:  MOVWF  1B
....................    Input1_8_Send = (Input1_8_Send << 1) | In.B4; 
1C1C:  BCF    FD8.0
1C1E:  RLCF   1B,W
1C20:  MOVWF  xAB
1C22:  MOVLW  00
1C24:  BTFSC  x1A.3
1C26:  MOVLW  01
1C28:  IORWF  xAB,W
1C2A:  MOVWF  1B
....................    Input1_8_Send = (Input1_8_Send << 1) | In.B3; 
1C2C:  BCF    FD8.0
1C2E:  RLCF   1B,W
1C30:  MOVWF  xAB
1C32:  MOVLW  00
1C34:  BTFSC  x1A.2
1C36:  MOVLW  01
1C38:  IORWF  xAB,W
1C3A:  MOVWF  1B
....................    Input1_8_Send = (Input1_8_Send << 1) | In.B2; 
1C3C:  BCF    FD8.0
1C3E:  RLCF   1B,W
1C40:  MOVWF  xAB
1C42:  MOVLW  00
1C44:  BTFSC  x1A.1
1C46:  MOVLW  01
1C48:  IORWF  xAB,W
1C4A:  MOVWF  1B
....................    Input1_8_Send = (Input1_8_Send << 1) | In.B1; 
1C4C:  BCF    FD8.0
1C4E:  RLCF   1B,W
1C50:  MOVWF  xAB
1C52:  MOVLW  00
1C54:  BTFSC  x1A.0
1C56:  MOVLW  01
1C58:  IORWF  xAB,W
1C5A:  MOVWF  1B
....................     
....................    Input9_16_Send = Input9_16_Send | In.B10; 
1C5C:  MOVLW  00
1C5E:  BTFSC  x1B.1
1C60:  MOVLW  01
1C62:  IORWF  1C,F
....................    Input9_16_Send = (Input9_16_Send << 1) | In.B9; 
1C64:  BCF    FD8.0
1C66:  RLCF   1C,W
1C68:  MOVWF  xAB
1C6A:  MOVLW  00
1C6C:  BTFSC  x1B.0
1C6E:  MOVLW  01
1C70:  IORWF  xAB,W
1C72:  MOVWF  1C
....................  
.................... } 
1C74:  MOVLB  0
1C76:  GOTO   25A6 (RETURN)
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... void checkCommand(void) 
.................... { 
....................    restart_wdt(); 
*
02E2:  CLRWDT
....................  
....................    //if(sequence == end_sq && Address == SBUF)     //check Address 
....................    if(sequence == end_sq )     //check Address 
02E4:  MOVF   60,W
02E6:  SUBWF  68,W
02E8:  BNZ   0310
....................    { 
....................      RxD_DataLen = 0x00 ; 
02EA:  CLRF   6A
....................      RxD_Buff[RxD_DataLen] = SBUF ;      //Byte 1   Address 
02EC:  CLRF   03
02EE:  MOVF   6A,W
02F0:  ADDLW  A7
02F2:  MOVWF  FE9
02F4:  MOVLW  00
02F6:  ADDWFC 03,W
02F8:  MOVWF  FEA
02FA:  MOVFF  2B,FEF
....................      restart_wdt(); 
02FE:  CLRWDT
....................      RxD_DataLen ++ ; 
0300:  INCF   6A,F
....................      sequence = addr_sq; 
0302:  MOVLW  10
0304:  MOVWF  68
....................      T_timeout = 0x14; //200ms 
0306:  MOVLW  14
0308:  MOVLB  1
030A:  MOVWF  x07
....................    } 
....................    else if(sequence == addr_sq) 
030C:  BRA    0512
030E:  MOVLB  0
0310:  MOVF   68,W
0312:  SUBLW  10
0314:  BNZ   03AA
....................    { 
....................       RxD_Buff[RxD_DataLen] = SBUF ;      //Byte 2   Function Code 
0316:  CLRF   03
0318:  MOVF   6A,W
031A:  ADDLW  A7
031C:  MOVWF  FE9
031E:  MOVLW  00
0320:  ADDWFC 03,W
0322:  MOVWF  FEA
0324:  MOVFF  2B,FEF
....................       restart_wdt(); 
0328:  CLRWDT
....................       RxD_DataLen ++ ; 
032A:  INCF   6A,F
....................  
....................        if(RxD_Buff[RxD_DataLen - 1] < 0x17)   //Function Code Must be less than 0x20 
032C:  MOVLW  01
032E:  SUBWF  6A,W
0330:  CLRF   03
0332:  ADDLW  A7
0334:  MOVWF  FE9
0336:  MOVLW  00
0338:  ADDWFC 03,W
033A:  MOVWF  FEA
033C:  MOVF   FEF,W
033E:  SUBLW  16
0340:  BNC   0350
....................        { 
....................            sequence = code_sq; 
0342:  MOVFF  61,68
....................            T_timeout = 0x14; //200ms 
0346:  MOVLW  14
0348:  MOVLB  1
034A:  MOVWF  x07
....................        } 
....................        else if(RxD_Buff[RxD_DataLen - 1] == 0x20)   /////Read Setting////// 
034C:  BRA    03A6
034E:  MOVLB  0
0350:  MOVLW  01
0352:  SUBWF  6A,W
0354:  CLRF   03
0356:  ADDLW  A7
0358:  MOVWF  FE9
035A:  MOVLW  00
035C:  ADDWFC 03,W
035E:  MOVWF  FEA
0360:  MOVF   FEF,W
0362:  SUBLW  20
0364:  BNZ   0374
....................        { 
....................           sequence = ubyte_lo_sq; 
0366:  MOVFF  64,68
....................           T_timeout = 0x14; //200ms 
036A:  MOVLW  14
036C:  MOVLB  1
036E:  MOVWF  x07
....................        } 
....................        else if(RxD_Buff[RxD_DataLen - 1] == 0x21)   /////Write setting///// 
0370:  BRA    03A6
0372:  MOVLB  0
0374:  MOVLW  01
0376:  SUBWF  6A,W
0378:  CLRF   03
037A:  ADDLW  A7
037C:  MOVWF  FE9
037E:  MOVLW  00
0380:  ADDWFC 03,W
0382:  MOVWF  FEA
0384:  MOVF   FEF,W
0386:  SUBLW  21
0388:  BNZ   0398
....................        { 
....................           sequence = byte_count_sq ; 
038A:  MOVFF  66,68
....................           T_timeout = 0x14; //200ms 
038E:  MOVLW  14
0390:  MOVLB  1
0392:  MOVWF  x07
....................        } 
....................        else                           // Invalid Code 
0394:  BRA    03A6
0396:  MOVLB  0
....................        { 
....................           RxD_DataLen = 0x00; 
0398:  CLRF   6A
....................           sequence = end_sq; 
039A:  MOVFF  60,68
....................           T_timeout = 0x00;  
039E:  MOVLB  1
03A0:  CLRF   x07
....................           output_bit(P485ctrl,0); 
03A2:  BCF    F8A.3
03A4:  BCF    F93.3
....................        } 
....................    } 
....................    else if(sequence == byte_count_sq) 
03A6:  BRA    0512
03A8:  MOVLB  0
03AA:  MOVF   66,W
03AC:  SUBWF  68,W
03AE:  BNZ   03E8
....................    { 
....................       RxD_Buff[RxD_DataLen] = SBUF ;      //Byte 3   Data Byte Count 
03B0:  CLRF   03
03B2:  MOVF   6A,W
03B4:  ADDLW  A7
03B6:  MOVWF  FE9
03B8:  MOVLW  00
03BA:  ADDWFC 03,W
03BC:  MOVWF  FEA
03BE:  MOVFF  2B,FEF
....................       restart_wdt(); 
03C2:  CLRWDT
....................       RxD_DataLen ++ ; 
03C4:  INCF   6A,F
....................       index = RxD_Buff[RxD_DataLen - 1] ;    //Data Byte Count 
03C6:  MOVLW  01
03C8:  SUBWF  6A,W
03CA:  CLRF   03
03CC:  ADDLW  A7
03CE:  MOVWF  FE9
03D0:  MOVLW  00
03D2:  ADDWFC 03,W
03D4:  MOVWF  FEA
03D6:  MOVFF  FEF,108
03DA:  MOVLB  1
....................       T_timeout = 0x14; //200ms 
03DC:  MOVLW  14
03DE:  MOVWF  x07
....................       sequence = data_sq ; 
03E0:  MOVFF  67,68
....................    } 
....................    else if(sequence == data_sq) 
03E4:  BRA    0512
03E6:  MOVLB  0
03E8:  MOVF   67,W
03EA:  SUBWF  68,W
03EC:  BNZ   0418
....................    { 
....................       RxD_Buff[RxD_DataLen] = SBUF ;      // 
03EE:  CLRF   03
03F0:  MOVF   6A,W
03F2:  ADDLW  A7
03F4:  MOVWF  FE9
03F6:  MOVLW  00
03F8:  ADDWFC 03,W
03FA:  MOVWF  FEA
03FC:  MOVFF  2B,FEF
....................       restart_wdt(); 
0400:  CLRWDT
....................       RxD_DataLen ++ ; 
0402:  INCF   6A,F
....................       index -- ;                     //Data Byte Count 
0404:  MOVLB  1
0406:  DECF   x08,F
....................       if(index == 0x00) 
0408:  MOVF   x08,F
040A:  BNZ   0410
....................       { 
....................          sequence = ubyte_lo_sq ;      //next CRC 
040C:  MOVFF  64,68
....................       } 
....................       T_timeout = 0x14; //200ms 
0410:  MOVLW  14
0412:  MOVWF  x07
....................    } 
....................    else if(sequence == code_sq) 
0414:  BRA    0512
0416:  MOVLB  0
0418:  MOVF   61,W
041A:  SUBWF  68,W
041C:  BNZ   0442
....................    { 
....................       RxD_Buff[RxD_DataLen] = SBUF ;      //Byte 3   Start address High Byte 
041E:  CLRF   03
0420:  MOVF   6A,W
0422:  ADDLW  A7
0424:  MOVWF  FE9
0426:  MOVLW  00
0428:  ADDWFC 03,W
042A:  MOVWF  FEA
042C:  MOVFF  2B,FEF
....................       restart_wdt(); 
0430:  CLRWDT
....................       RxD_DataLen ++ ; 
0432:  INCF   6A,F
....................       sequence = start_addr_hi_sq; 
0434:  MOVFF  62,68
....................       T_timeout = 0x14; //200ms 
0438:  MOVLW  14
043A:  MOVLB  1
043C:  MOVWF  x07
....................  
....................    } 
....................    else if(sequence == start_addr_hi_sq) 
043E:  BRA    0512
0440:  MOVLB  0
0442:  MOVF   62,W
0444:  SUBWF  68,W
0446:  BNZ   046C
....................    { 
....................       RxD_Buff[RxD_DataLen] = SBUF ;         //Byte 4   Start address Low Byte 
0448:  CLRF   03
044A:  MOVF   6A,W
044C:  ADDLW  A7
044E:  MOVWF  FE9
0450:  MOVLW  00
0452:  ADDWFC 03,W
0454:  MOVWF  FEA
0456:  MOVFF  2B,FEF
....................       restart_wdt(); 
045A:  CLRWDT
....................       RxD_DataLen ++ ; 
045C:  INCF   6A,F
....................       sequence = start_addr_lo_sq; 
045E:  MOVFF  63,68
....................       T_timeout = 0x14; //200ms 
0462:  MOVLW  14
0464:  MOVLB  1
0466:  MOVWF  x07
....................    } 
....................    else if(sequence == start_addr_lo_sq) 
0468:  BRA    0512
046A:  MOVLB  0
046C:  MOVF   63,W
046E:  SUBWF  68,W
0470:  BNZ   0496
....................    { 
....................       RxD_Buff[RxD_DataLen] = SBUF ;         //Byte 5   No. of point/force data High Byte 
0472:  CLRF   03
0474:  MOVF   6A,W
0476:  ADDLW  A7
0478:  MOVWF  FE9
047A:  MOVLW  00
047C:  ADDWFC 03,W
047E:  MOVWF  FEA
0480:  MOVFF  2B,FEF
....................       restart_wdt(); 
0484:  CLRWDT
....................       RxD_DataLen ++ ; 
0486:  INCF   6A,F
....................       sequence = ubyte_hi_sq; 
0488:  MOVLW  15
048A:  MOVWF  68
....................       T_timeout = 0x14; //200ms 
048C:  MOVLW  14
048E:  MOVLB  1
0490:  MOVWF  x07
....................    } 
....................    else if(sequence == ubyte_hi_sq) 
0492:  BRA    0512
0494:  MOVLB  0
0496:  MOVF   68,W
0498:  SUBLW  15
049A:  BNZ   04C0
....................    { 
....................       RxD_Buff[RxD_DataLen] = SBUF ;         //Byte 6   No. of point/force data Low Byte 
049C:  CLRF   03
049E:  MOVF   6A,W
04A0:  ADDLW  A7
04A2:  MOVWF  FE9
04A4:  MOVLW  00
04A6:  ADDWFC 03,W
04A8:  MOVWF  FEA
04AA:  MOVFF  2B,FEF
....................       restart_wdt(); 
04AE:  CLRWDT
....................       RxD_DataLen ++ ; 
04B0:  INCF   6A,F
....................       sequence = ubyte_lo_sq; 
04B2:  MOVFF  64,68
....................       T_timeout = 0x14; //200ms 
04B6:  MOVLW  14
04B8:  MOVLB  1
04BA:  MOVWF  x07
....................    } 
....................    else if(sequence == ubyte_lo_sq) 
04BC:  BRA    0512
04BE:  MOVLB  0
04C0:  MOVF   64,W
04C2:  SUBWF  68,W
04C4:  BNZ   04EA
....................    { 
....................       RxD_Buff[RxD_DataLen] = SBUF ;         //Byte 7   CRC High Byte 
04C6:  CLRF   03
04C8:  MOVF   6A,W
04CA:  ADDLW  A7
04CC:  MOVWF  FE9
04CE:  MOVLW  00
04D0:  ADDWFC 03,W
04D2:  MOVWF  FEA
04D4:  MOVFF  2B,FEF
....................       restart_wdt(); 
04D8:  CLRWDT
....................       RxD_DataLen ++ ; 
04DA:  INCF   6A,F
....................       sequence = crc_hi_sq; 
04DC:  MOVFF  65,68
....................       T_timeout = 0x14; //200ms 
04E0:  MOVLW  14
04E2:  MOVLB  1
04E4:  MOVWF  x07
....................    } 
....................    else if(sequence == crc_hi_sq) 
04E6:  BRA    0512
04E8:  MOVLB  0
04EA:  MOVF   65,W
04EC:  SUBWF  68,W
04EE:  BNZ   0512
....................    { 
....................       RxD_Buff[RxD_DataLen] = SBUF ;         //Byte 8   CRC Low Byte 
04F0:  CLRF   03
04F2:  MOVF   6A,W
04F4:  ADDLW  A7
04F6:  MOVWF  FE9
04F8:  MOVLW  00
04FA:  ADDWFC 03,W
04FC:  MOVWF  FEA
04FE:  MOVFF  2B,FEF
....................       restart_wdt(); 
0502:  CLRWDT
....................       sequence = end_sq; 
0504:  MOVFF  60,68
....................       T_timeout = 0x00; 
0508:  MOVLB  1
050A:  CLRF   x07
....................       //T_timeout = 0x14; //200ms 
....................       recieve_completed = 1 ;            //Recieve completed then translate 
050C:  BSF    2D.4
....................       output_bit(P485ctrl,0); 
050E:  BCF    F8A.3
0510:  BCF    F93.3
0512:  MOVLB  0
....................    } 
.................... } 
0514:  GOTO   0524 (RETURN)
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... ///////////////////// MODBUS FUNCTION ////////////////////////////////////////// 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void Modbus_Function(void) 
.................... { 
....................    restart_wdt(); 
*
1E88:  CLRWDT
....................    CRC(RxD_Buff , RxD_DataLen - 1); 
1E8A:  MOVLW  01
1E8C:  SUBWF  6A,W
1E8E:  MOVLB  1
1E90:  MOVWF  xAB
1E92:  CLRF   xAD
1E94:  MOVLW  A7
1E96:  MOVWF  xAC
1E98:  MOVFF  1AB,1AE
1E9C:  MOVLB  0
1E9E:  RCALL  1A46
....................  
....................    if(CRC_Hi == RxD_Buff[RxD_DataLen - 1] && CRC_Lo == RxD_Buff[RxD_DataLen]) 
1EA0:  MOVLW  01
1EA2:  SUBWF  6A,W
1EA4:  CLRF   03
1EA6:  ADDLW  A7
1EA8:  MOVWF  FE9
1EAA:  MOVLW  00
1EAC:  ADDWFC 03,W
1EAE:  MOVWF  FEA
1EB0:  MOVF   FEF,W
1EB2:  SUBWF  xE4,W
1EB4:  BTFSS  FD8.2
1EB6:  GOTO   34A0
1EBA:  CLRF   03
1EBC:  MOVF   6A,W
1EBE:  ADDLW  A7
1EC0:  MOVWF  FE9
1EC2:  MOVLW  00
1EC4:  ADDWFC 03,W
1EC6:  MOVWF  FEA
1EC8:  MOVF   FEF,W
1ECA:  SUBWF  xE3,W
1ECC:  BTFSS  FD8.2
1ECE:  GOTO   34A0
....................    { 
....................     
....................           
....................       if((RxD_Buff[0] == 0xAA)&&(RxD_Buff[1] == 0x20)) //Read Setting//0xAA Is Any Address  
1ED2:  MOVF   xA7,W
1ED4:  SUBLW  AA
1ED6:  BTFSS  FD8.2
1ED8:  BRA    2176
1EDA:  MOVF   xA8,W
1EDC:  SUBLW  20
1EDE:  BTFSS  FD8.2
1EE0:  BRA    2176
....................       { 
....................          TxD_Buff[0] = Address ;         //Address 
1EE2:  MOVFF  69,6B
....................          TxD_Buff[1] = 0x20 ;            //function code 
1EE6:  MOVLW  20
1EE8:  MOVWF  6C
....................          TxD_Buff[2] = 0x1C ;           //28 Byte  //Data Byte count 
1EEA:  MOVLW  1C
1EEC:  MOVWF  6D
....................          TxD_Buff[3] = InputType1_8 ;    //1 
1EEE:  MOVFF  38,6E
....................          TxD_Buff[4] = InputType9_16 ;  //2 
1EF2:  MOVFF  39,6F
....................          TxD_Buff[5] = InputType17_24 ;//3 
1EF6:  MOVFF  3A,70
....................           
....................          TxD_Buff[6] = FaultType1_8 ;  //4 
1EFA:  MOVFF  3B,71
....................          TxD_Buff[7] = FaultType9_16 ; //5 
1EFE:  MOVFF  3C,72
....................          TxD_Buff[8] = FaultType17_24 ;   //6 
1F02:  MOVFF  3D,73
....................          
....................          TxD_Buff[9] = OutputType1_8 ; //7 
1F06:  MOVFF  3E,74
....................          TxD_Buff[10] = OutputType9_16 ;  //8 
1F0A:  MOVFF  3F,75
....................          TxD_Buff[11] = OutputType17_24 ; //9 
1F0E:  MOVFF  40,76
....................          
....................          TxD_Buff[12] = OutputBoth1_8 ;   //10 
1F12:  MOVFF  41,77
....................          TxD_Buff[13] = OutputBoth9_16 ;  //11 
1F16:  MOVFF  42,78
....................          TxD_Buff[14] = OutputBoth17_24 ; //12 
1F1A:  MOVFF  43,79
....................          
....................          TxD_Buff[15] = Alarm_Indicator1_8 ; //13 
1F1E:  MOVFF  44,7A
....................          TxD_Buff[16] = Alarm_Indicator9_16 ;   //14 
1F22:  MOVFF  45,7B
....................          TxD_Buff[17] = Alarm_Indicator17_24 ;  //15 
1F26:  MOVFF  46,7C
....................          
....................           TxD_Buff[18] = read_eeprom(0x10);//Red1_8;    //16 
1F2A:  MOVFF  FF2,1AB
1F2E:  BCF    FF2.7
1F30:  MOVLW  10
1F32:  MOVWF  FA9
1F34:  BCF    FA6.6
1F36:  BCF    FA6.7
1F38:  BSF    FA6.0
1F3A:  MOVF   FA8,W
1F3C:  MOVLB  1
1F3E:  BTFSC  xAB.7
1F40:  BSF    FF2.7
1F42:  MOVWF  7D
....................           TxD_Buff[19] = read_eeprom(0x11);//Red9_10;      //17 
1F44:  MOVFF  FF2,1AB
1F48:  BCF    FF2.7
1F4A:  MOVLW  11
1F4C:  MOVWF  FA9
1F4E:  BCF    FA6.6
1F50:  BCF    FA6.7
1F52:  BSF    FA6.0
1F54:  MOVF   FA8,W
1F56:  BTFSC  xAB.7
1F58:  BSF    FF2.7
1F5A:  MOVWF  7E
....................           TxD_Buff[20] = read_eeprom(0x12);//Red11_18;     //18 
1F5C:  MOVFF  FF2,1AB
1F60:  BCF    FF2.7
1F62:  MOVLW  12
1F64:  MOVWF  FA9
1F66:  BCF    FA6.6
1F68:  BCF    FA6.7
1F6A:  BSF    FA6.0
1F6C:  MOVF   FA8,W
1F6E:  BTFSC  xAB.7
1F70:  BSF    FF2.7
1F72:  MOVWF  7F
....................           TxD_Buff[21] = read_eeprom(0x13);//Red19_20;     //19 
1F74:  MOVFF  FF2,1AB
1F78:  BCF    FF2.7
1F7A:  MOVLW  13
1F7C:  MOVWF  FA9
1F7E:  BCF    FA6.6
1F80:  BCF    FA6.7
1F82:  BSF    FA6.0
1F84:  MOVF   FA8,W
1F86:  BTFSC  xAB.7
1F88:  BSF    FF2.7
1F8A:  MOVLB  0
1F8C:  MOVWF  x80
....................            
....................           TxD_Buff[22] = read_eeprom(0x14);//Green1_8;     //20 
1F8E:  MOVFF  FF2,1AB
1F92:  BCF    FF2.7
1F94:  MOVLW  14
1F96:  MOVWF  FA9
1F98:  BCF    FA6.6
1F9A:  BCF    FA6.7
1F9C:  BSF    FA6.0
1F9E:  MOVF   FA8,W
1FA0:  MOVLB  1
1FA2:  BTFSC  xAB.7
1FA4:  BSF    FF2.7
1FA6:  MOVLB  0
1FA8:  MOVWF  x81
....................           TxD_Buff[23] = read_eeprom(0x15);//Green9_10;    //21 
1FAA:  MOVFF  FF2,1AB
1FAE:  BCF    FF2.7
1FB0:  MOVLW  15
1FB2:  MOVWF  FA9
1FB4:  BCF    FA6.6
1FB6:  BCF    FA6.7
1FB8:  BSF    FA6.0
1FBA:  MOVF   FA8,W
1FBC:  MOVLB  1
1FBE:  BTFSC  xAB.7
1FC0:  BSF    FF2.7
1FC2:  MOVLB  0
1FC4:  MOVWF  x82
....................           TxD_Buff[24] = read_eeprom(0x16);//Green11_18;      //22 
1FC6:  MOVFF  FF2,1AB
1FCA:  BCF    FF2.7
1FCC:  MOVLW  16
1FCE:  MOVWF  FA9
1FD0:  BCF    FA6.6
1FD2:  BCF    FA6.7
1FD4:  BSF    FA6.0
1FD6:  MOVF   FA8,W
1FD8:  MOVLB  1
1FDA:  BTFSC  xAB.7
1FDC:  BSF    FF2.7
1FDE:  MOVLB  0
1FE0:  MOVWF  x83
....................           TxD_Buff[25] = read_eeprom(0x17);//Green19_20;      //23 
1FE2:  MOVFF  FF2,1AB
1FE6:  BCF    FF2.7
1FE8:  MOVLW  17
1FEA:  MOVWF  FA9
1FEC:  BCF    FA6.6
1FEE:  BCF    FA6.7
1FF0:  BSF    FA6.0
1FF2:  MOVF   FA8,W
1FF4:  MOVLB  1
1FF6:  BTFSC  xAB.7
1FF8:  BSF    FF2.7
1FFA:  MOVLB  0
1FFC:  MOVWF  x84
....................         
....................         
....................          TxD_Buff[26] = AutoAck ;            //24 
1FFE:  MOVFF  5B,85
....................          TxD_Buff[27] = AutoAckTime ;        //25 
2002:  MOVFF  5C,86
....................          TxD_Buff[28] = FlashingRate ;       //26 
2006:  MOVFF  5D,87
....................          TxD_Buff[29] = NoOfPoint ;          //27 
200A:  MOVFF  5E,88
....................          TxD_Buff[30] = FaultDelayTime ;    //28 
200E:  MOVLW  6A
2010:  MOVWF  x89
....................          TxD_Buff[31] = Address ;            //29 
2012:  MOVFF  69,8A
....................  
....................  
....................          TxD_Buff[32] = FaultDelayTime[1] ; 
2016:  MOVFF  16C,8B
....................          TxD_Buff[33] = FaultDelayTime[2] ; 
201A:  MOVFF  16E,8C
....................          TxD_Buff[34] = FaultDelayTime[3] ; 
201E:  MOVFF  170,8D
....................          TxD_Buff[35] = FaultDelayTime[4] ; 
2022:  MOVFF  172,8E
....................          TxD_Buff[36] = FaultDelayTime[5] ; 
2026:  MOVFF  174,8F
....................          TxD_Buff[37] = FaultDelayTime[6] ; 
202A:  MOVFF  176,90
....................          TxD_Buff[38] = FaultDelayTime[7] ; 
202E:  MOVFF  178,91
....................          TxD_Buff[39] = FaultDelayTime[8] ; 
2032:  MOVFF  17A,92
....................          TxD_Buff[40] = FaultDelayTime[9] ; 
2036:  MOVFF  17C,93
....................          TxD_Buff[41] = FaultDelayTime[10] ; 
203A:  MOVFF  17E,94
....................          TxD_Buff[42] = FaultDelayTime[11] ; 
203E:  MOVFF  180,95
....................          TxD_Buff[43] = FaultDelayTime[12] ; 
2042:  MOVFF  182,96
....................          TxD_Buff[44] = FaultDelayTime[13] ; 
2046:  MOVFF  184,97
....................          TxD_Buff[45] = FaultDelayTime[14] ; 
204A:  MOVFF  186,98
....................          TxD_Buff[46] = FaultDelayTime[15] ; 
204E:  MOVFF  188,99
....................          TxD_Buff[47] = FaultDelayTime[16] ; 
2052:  MOVFF  18A,9A
....................          TxD_Buff[48] = FaultDelayTime[17] ; 
2056:  MOVFF  18C,9B
....................          TxD_Buff[49] = FaultDelayTime[18] ; 
205A:  MOVFF  18E,9C
....................          TxD_Buff[50] = FaultDelayTime[19] ; 
205E:  MOVFF  190,9D
....................          TxD_Buff[51] = FaultDelayTime[20] ; 
2062:  MOVFF  192,9E
....................           
....................           
....................          CRC(TxD_Buff,52)   ; //Cal CRC 49 byte 
2066:  MOVLB  1
2068:  CLRF   xAD
206A:  MOVLW  6B
206C:  MOVWF  xAC
206E:  MOVLW  34
2070:  MOVWF  xAE
2072:  MOVLB  0
2074:  RCALL  1A46
....................  
....................          TxD_Buff[52] = CRC_Hi ; 
2076:  MOVFF  E4,9F
....................          TxD_Buff[53] = CRC_Lo ; 
207A:  MOVFF  E3,A0
....................  
....................          output_bit(P485ctrl,1); 
207E:  BSF    F8A.3
2080:  BCF    F93.3
....................          delay_ms(10); 
2082:  MOVLW  0A
2084:  MOVLB  1
2086:  MOVWF  xB3
2088:  MOVLB  0
208A:  CALL   05C4
....................  
....................          putc(Txd_Buff[0]); 
208E:  MOVF   6B,W
2090:  RCALL  1AB4
....................          putc(Txd_Buff[1]); 
2092:  MOVF   6C,W
2094:  RCALL  1AB4
....................          putc(Txd_Buff[2]); 
2096:  MOVF   6D,W
2098:  RCALL  1AB4
....................          putc(Txd_Buff[3]); 
209A:  MOVF   6E,W
209C:  RCALL  1AB4
....................          putc(Txd_Buff[4]); 
209E:  MOVF   6F,W
20A0:  RCALL  1AB4
....................          putc(Txd_Buff[5]); 
20A2:  MOVF   70,W
20A4:  RCALL  1AB4
....................          putc(Txd_Buff[6]); 
20A6:  MOVF   71,W
20A8:  RCALL  1AB4
....................          putc(Txd_Buff[7]); 
20AA:  MOVF   72,W
20AC:  RCALL  1AB4
....................          putc(Txd_Buff[8]); 
20AE:  MOVF   73,W
20B0:  RCALL  1AB4
....................          putc(Txd_Buff[9]); 
20B2:  MOVF   74,W
20B4:  RCALL  1AB4
....................          putc(Txd_Buff[10]); 
20B6:  MOVF   75,W
20B8:  RCALL  1AB4
....................          putc(Txd_Buff[11]); 
20BA:  MOVF   76,W
20BC:  RCALL  1AB4
....................          putc(Txd_Buff[12]); 
20BE:  MOVF   77,W
20C0:  RCALL  1AB4
....................          putc(Txd_Buff[13]); 
20C2:  MOVF   78,W
20C4:  RCALL  1AB4
....................          putc(Txd_Buff[14]); 
20C6:  MOVF   79,W
20C8:  RCALL  1AB4
....................          putc(Txd_Buff[15]); 
20CA:  MOVF   7A,W
20CC:  RCALL  1AB4
....................          putc(Txd_Buff[16]); 
20CE:  MOVF   7B,W
20D0:  RCALL  1AB4
....................          putc(Txd_Buff[17]); 
20D2:  MOVF   7C,W
20D4:  RCALL  1AB4
....................          putc(Txd_Buff[18]); 
20D6:  MOVF   7D,W
20D8:  RCALL  1AB4
....................          putc(Txd_Buff[19]); 
20DA:  MOVF   7E,W
20DC:  RCALL  1AB4
....................          putc(Txd_Buff[20]); 
20DE:  MOVF   7F,W
20E0:  RCALL  1AB4
....................          putc(Txd_Buff[21]); 
20E2:  MOVF   x80,W
20E4:  RCALL  1AB4
....................          putc(Txd_Buff[22]); 
20E6:  MOVF   x81,W
20E8:  RCALL  1AB4
....................          putc(Txd_Buff[23]); 
20EA:  MOVF   x82,W
20EC:  RCALL  1AB4
....................          putc(Txd_Buff[24]); 
20EE:  MOVF   x83,W
20F0:  RCALL  1AB4
....................          putc(Txd_Buff[25]); 
20F2:  MOVF   x84,W
20F4:  RCALL  1AB4
....................          putc(Txd_Buff[26]); 
20F6:  MOVF   x85,W
20F8:  RCALL  1AB4
....................          putc(Txd_Buff[27]); 
20FA:  MOVF   x86,W
20FC:  RCALL  1AB4
....................          putc(Txd_Buff[28]); 
20FE:  MOVF   x87,W
2100:  RCALL  1AB4
....................          putc(Txd_Buff[29]); 
2102:  MOVF   x88,W
2104:  RCALL  1AB4
....................          putc(Txd_Buff[30]); 
2106:  MOVF   x89,W
2108:  RCALL  1AB4
....................          putc(Txd_Buff[31]); 
210A:  MOVF   x8A,W
210C:  RCALL  1AB4
....................           
....................          putc(Txd_Buff[32]); 
210E:  MOVF   x8B,W
2110:  RCALL  1AB4
....................          putc(Txd_Buff[33]); 
2112:  MOVF   x8C,W
2114:  RCALL  1AB4
....................          putc(Txd_Buff[34]); 
2116:  MOVF   x8D,W
2118:  RCALL  1AB4
....................          putc(Txd_Buff[35]); 
211A:  MOVF   x8E,W
211C:  RCALL  1AB4
....................          putc(Txd_Buff[36]); 
211E:  MOVF   x8F,W
2120:  RCALL  1AB4
....................          putc(Txd_Buff[37]); 
2122:  MOVF   x90,W
2124:  RCALL  1AB4
....................          putc(Txd_Buff[38]); 
2126:  MOVF   x91,W
2128:  RCALL  1AB4
....................          putc(Txd_Buff[39]); 
212A:  MOVF   x92,W
212C:  RCALL  1AB4
....................          putc(Txd_Buff[40]); 
212E:  MOVF   x93,W
2130:  RCALL  1AB4
....................          putc(Txd_Buff[41]); 
2132:  MOVF   x94,W
2134:  RCALL  1AB4
....................           
....................          putc(Txd_Buff[42]); 
2136:  MOVF   x95,W
2138:  RCALL  1AB4
....................          putc(Txd_Buff[43]); 
213A:  MOVF   x96,W
213C:  RCALL  1AB4
....................          putc(Txd_Buff[44]); 
213E:  MOVF   x97,W
2140:  RCALL  1AB4
....................          putc(Txd_Buff[45]); 
2142:  MOVF   x98,W
2144:  RCALL  1AB4
....................          putc(Txd_Buff[46]); 
2146:  MOVF   x99,W
2148:  RCALL  1AB4
....................          putc(Txd_Buff[47]); 
214A:  MOVF   x9A,W
214C:  RCALL  1AB4
....................          putc(Txd_Buff[48]); 
214E:  MOVF   x9B,W
2150:  RCALL  1AB4
....................          putc(Txd_Buff[49]); 
2152:  MOVF   x9C,W
2154:  RCALL  1AB4
....................          putc(Txd_Buff[50]); 
2156:  MOVF   x9D,W
2158:  RCALL  1AB4
....................          putc(Txd_Buff[51]); 
215A:  MOVF   x9E,W
215C:  RCALL  1AB4
....................           
....................          putc(Txd_Buff[52]); 
215E:  MOVF   x9F,W
2160:  RCALL  1AB4
....................          putc(Txd_Buff[53]); 
2162:  MOVF   xA0,W
2164:  RCALL  1AB4
....................         
....................          delay_ms(3); 
2166:  MOVLW  03
2168:  MOVLB  1
216A:  MOVWF  xB3
216C:  MOVLB  0
216E:  CALL   05C4
....................          output_bit(P485ctrl,0); 
2172:  BCF    F8A.3
2174:  BCF    F93.3
....................           
....................       } 
....................     
....................     
....................    /////////////////////////////////////////////////////////////// 
....................       if(RxD_Buff[0] == Address) 
2176:  MOVF   69,W
2178:  SUBWF  xA7,W
217A:  BTFSS  FD8.2
217C:  GOTO   3498
....................       { 
....................        
....................       if(RxD_Buff[1] == 0x01)///////////// READ COIL ///////////////////// 
2180:  DECFSZ xA8,W
2182:  BRA    259A
....................       { 
....................             //Do Read Coil 
....................             Start_Address = RxD_Buff[2] ; 
2184:  CLRF   xE8
2186:  MOVFF  A9,E7
....................             Start_Address = (Start_Address << 8) | RxD_Buff[3] ;   //Start Address 16 bit 
218A:  MOVFF  E7,1AC
218E:  MOVLB  1
2190:  CLRF   xAB
2192:  MOVF   xAB,W
2194:  MOVLB  0
2196:  IORWF  xAA,W
2198:  MOVWF  xE7
219A:  MOVFF  1AC,E8
219E:  MOVLB  0
....................             No_PointCount = RxD_Buff[4] ; 
21A0:  CLRF   xEA
21A2:  MOVFF  AB,E9
....................             No_PointCount = (No_PointCount << 8) | RxD_Buff[5] ;      //No. of Point 16 bit 
21A6:  MOVFF  E9,1AC
21AA:  MOVLB  1
21AC:  CLRF   xAB
21AE:  MOVF   xAB,W
21B0:  MOVLB  0
21B2:  IORWF  xAC,W
21B4:  MOVWF  xE9
21B6:  MOVFF  1AC,EA
21BA:  MOVLB  0
....................  
....................             if(Start_Address < 0x10 && (Start_Address + No_PointCount) < 0x11)  //Valid point 0-15 
21BC:  MOVF   xE8,F
21BE:  BTFSS  FD8.2
21C0:  BRA    252E
21C2:  MOVF   xE7,W
21C4:  SUBLW  0F
21C6:  BTFSS  FD8.0
21C8:  BRA    252E
21CA:  MOVF   xE9,W
21CC:  ADDWF  xE7,W
21CE:  MOVLB  1
21D0:  MOVWF  xAB
21D2:  MOVLB  0
21D4:  MOVF   xEA,W
21D6:  ADDWFC xE8,W
21D8:  MOVLB  1
21DA:  MOVWF  xAC
21DC:  MOVF   xAC,F
21DE:  BTFSC  FD8.2
21E0:  BRA    21E6
21E2:  MOVLB  0
21E4:  BRA    252E
21E6:  MOVF   xAB,W
21E8:  SUBLW  10
21EA:  BTFSC  FD8.0
21EC:  BRA    21F2
21EE:  MOVLB  0
21F0:  BRA    252E
....................             { 
....................                if(No_PointCount < 9) Data_ByteCount = 0x01 ; 
21F2:  MOVLB  0
21F4:  MOVF   xEA,F
21F6:  BNZ   2204
21F8:  MOVF   xE9,W
21FA:  SUBLW  08
21FC:  BNC   2204
21FE:  MOVLW  01
2200:  MOVWF  xEB
....................                else if(No_PointCount < 17) Data_ByteCount = 0x02 ; 
2202:  BRA    2228
2204:  MOVF   xEA,F
2206:  BNZ   2214
2208:  MOVF   xE9,W
220A:  SUBLW  10
220C:  BNC   2214
220E:  MOVLW  02
2210:  MOVWF  xEB
....................                else if(No_PointCount < 25) Data_ByteCount = 0x03 ; 
2212:  BRA    2228
2214:  MOVF   xEA,F
2216:  BNZ   2224
2218:  MOVF   xE9,W
221A:  SUBLW  18
221C:  BNC   2224
221E:  MOVLW  03
2220:  MOVWF  xEB
....................                else   Data_ByteCount = 0x01 ; //----Jack 
2222:  BRA    2228
2224:  MOVLW  01
2226:  MOVWF  xEB
....................  
....................                if(Data_ByteCount == 0x01) 
2228:  DECFSZ xEB,W
222A:  BRA    236C
....................                { 
....................  
....................                   if(Start_Address < 0x09) 
222C:  MOVF   xE8,F
222E:  BNZ   224A
2230:  MOVF   xE7,W
2232:  SUBLW  08
2234:  BNC   224A
....................                   { 
....................                      //Data_Buff[0] = ~output[0] >> Start_Address ; 
....................                      //DataTemp = ~output[1] << (0x08 - Start_Address) ; 
....................                      //Data_Buff[0] = (~output[0] >> Start_Address) | DataTemp;   //Low Byte 
....................                       Data_Buff[0] = Input1_8 >> Start_Address ; 
2236:  MOVFF  47,EC
223A:  MOVF   xE7,W
223C:  MOVWF  01
223E:  BZ    2248
2240:  BCF    FD8.0
2242:  RRCF   xEC,F
2244:  DECFSZ 01,F
2246:  BRA    2240
....................                       //DataTemp = Input9_16 << (0x08 - Start_Address) ;//JJ 
....................                       //Data_Buff[0] = (Input1_8 >> Start_Address) | DataTemp;   //Low Byte//JJ 
....................                   } 
....................                   else if(Start_Address > 0x08 && Start_Address < 0x10) 
2248:  BRA    227E
224A:  MOVF   xE8,F
224C:  BNZ   2254
224E:  MOVF   xE7,W
2250:  SUBLW  08
2252:  BC    227E
2254:  MOVF   xE8,F
2256:  BNZ   227E
2258:  MOVF   xE7,W
225A:  SUBLW  0F
225C:  BNC   227E
....................                   { 
....................                      //Data_Buff[0] = ~output[1] >> (Start_Address - 0x08) ; 
....................                      Data_Buff[0] = Input9_16 >> (Start_Address - 0x08) ; 
225E:  MOVLW  08
2260:  SUBWF  xE7,W
2262:  MOVWF  00
2264:  MOVLW  00
2266:  SUBWFB xE8,W
2268:  MOVWF  03
226A:  MOVFF  00,01
226E:  MOVFF  2F,EC
2272:  MOVF   01,F
2274:  BZ    227E
2276:  BCF    FD8.0
2278:  RRCF   xEC,F
227A:  DECFSZ 01,F
227C:  BRA    2276
....................                   } 
....................  
....................  
....................                   if(No_PointCount == 0x08) 
227E:  MOVF   xE9,W
2280:  SUBLW  08
2282:  BNZ   228A
2284:  MOVF   xEA,F
2286:  BNZ   228A
....................                   { 
....................                      Data_Buff[0] = Data_Buff[0] & 0xFF ; //8 Point High Byte 
....................                   } 
....................                   else if(No_PointCount == 0x07) 
2288:  BRA    22F4
228A:  MOVF   xE9,W
228C:  SUBLW  07
228E:  BNZ   2298
2290:  MOVF   xEA,F
2292:  BNZ   2298
....................                   { 
....................                      Data_Buff[0] =    Data_Buff[0] & 0x7F ; //7 Point High Byte 
2294:  BCF    xEC.7
....................                   } 
....................                   else if(No_PointCount == 0x06) 
2296:  BRA    22F4
2298:  MOVF   xE9,W
229A:  SUBLW  06
229C:  BNZ   22A8
229E:  MOVF   xEA,F
22A0:  BNZ   22A8
....................                   { 
....................                      Data_Buff[0] =    Data_Buff[0] & 0x3F ; //6 Point High Byte 
22A2:  MOVLW  3F
22A4:  ANDWF  xEC,F
....................                   } 
....................                   else if(No_PointCount == 0x05) 
22A6:  BRA    22F4
22A8:  MOVF   xE9,W
22AA:  SUBLW  05
22AC:  BNZ   22B8
22AE:  MOVF   xEA,F
22B0:  BNZ   22B8
....................                   { 
....................                      Data_Buff[0] =    Data_Buff[0] & 0x1F ; //5 Point High Byte 
22B2:  MOVLW  1F
22B4:  ANDWF  xEC,F
....................                   } 
....................                   else if(No_PointCount == 0x04) 
22B6:  BRA    22F4
22B8:  MOVF   xE9,W
22BA:  SUBLW  04
22BC:  BNZ   22C8
22BE:  MOVF   xEA,F
22C0:  BNZ   22C8
....................                   { 
....................                      Data_Buff[0] =    Data_Buff[0] & 0x0F ; //4 Point High Byte 
22C2:  MOVLW  0F
22C4:  ANDWF  xEC,F
....................                   } 
....................                   else if(No_PointCount == 0x03) 
22C6:  BRA    22F4
22C8:  MOVF   xE9,W
22CA:  SUBLW  03
22CC:  BNZ   22D8
22CE:  MOVF   xEA,F
22D0:  BNZ   22D8
....................                   { 
....................                      Data_Buff[0] =    Data_Buff[0] & 0x07 ; //3 Point High Byte 
22D2:  MOVLW  07
22D4:  ANDWF  xEC,F
....................                   } 
....................                   else if(No_PointCount == 0x02) 
22D6:  BRA    22F4
22D8:  MOVF   xE9,W
22DA:  SUBLW  02
22DC:  BNZ   22E8
22DE:  MOVF   xEA,F
22E0:  BNZ   22E8
....................                   { 
....................                      Data_Buff[0] =    Data_Buff[0] & 0x03 ; //2 Point High Byte 
22E2:  MOVLW  03
22E4:  ANDWF  xEC,F
....................                   } 
....................                   else if(No_PointCount == 0x01) 
22E6:  BRA    22F4
22E8:  DECFSZ xE9,W
22EA:  BRA    22F4
22EC:  MOVF   xEA,F
22EE:  BNZ   22F4
....................                   { 
....................                      Data_Buff[0] =    Data_Buff[0] & 0x01 ; //1 Point High Byte 
22F0:  MOVLW  01
22F2:  ANDWF  xEC,F
....................                   } 
....................  
....................                   TxD_Buff[0] = Address ;         //Address 
22F4:  MOVFF  69,6B
....................                   TxD_Buff[1] = 0x01 ;         //Function Code 
22F8:  MOVLW  01
22FA:  MOVWF  6C
....................                   TxD_Buff[2] = Data_ByteCount ;   //Byte Count 
22FC:  MOVFF  EB,6D
....................                   TxD_Buff[3] = Data_Buff[0] ;   //Data 
2300:  MOVFF  EC,6E
....................  
....................                   CRC(TxD_Buff,4)   ;            //Cal CRC 5 Byte 
2304:  MOVLB  1
2306:  CLRF   xAD
2308:  MOVLW  6B
230A:  MOVWF  xAC
230C:  MOVLW  04
230E:  MOVWF  xAE
2310:  MOVLB  0
2312:  CALL   1A46
....................  
....................                   TxD_Buff[4] = CRC_Hi ; 
2316:  MOVFF  E4,6F
....................                   TxD_Buff[5] = CRC_Lo ; 
231A:  MOVFF  E3,70
....................  
....................                   //TxD_DataLen = 0x06 ; 
....................                   //rs485_ctrl = 1; 
....................                   //dmsec(4); 
....................                   //send = 1; 
....................                   //TI=1; 
....................                   output_bit(P485ctrl,1); 
231E:  BSF    F8A.3
2320:  BCF    F93.3
....................                   restart_wdt(); 
2322:  CLRWDT
....................                   delay_ms(4); 
2324:  MOVLW  04
2326:  MOVLB  1
2328:  MOVWF  xB3
232A:  MOVLB  0
232C:  CALL   05C4
....................                   restart_wdt(); 
2330:  CLRWDT
....................  
....................                   putc(TxD_Buff[0]) ;               //Address 
2332:  MOVF   6B,W
2334:  CALL   1AB4
....................                   putc(TxD_Buff[1]) ;               //Function Code 
2338:  MOVF   6C,W
233A:  CALL   1AB4
....................                   putc(TxD_Buff[2]) ;               //Byte Count 
233E:  MOVF   6D,W
2340:  CALL   1AB4
....................                   putc(TxD_Buff[3]) ; 
2344:  MOVF   6E,W
2346:  CALL   1AB4
....................                   putc(TxD_Buff[4]) ; 
234A:  MOVF   6F,W
234C:  CALL   1AB4
....................                   putc(TxD_Buff[5]) ; 
2350:  MOVF   70,W
2352:  CALL   1AB4
....................                   //putc(TxD_Buff[6]) ; 
....................                   //putc(TxD_Buff[7]) ; 
....................                   //putc(TxD_Buff[8]) ; 
....................                   //putc(TxD_Buff[9]) ; 
....................                 
....................                   restart_wdt(); 
2356:  CLRWDT
....................                   delay_ms(3); 
2358:  MOVLW  03
235A:  MOVLB  1
235C:  MOVWF  xB3
235E:  MOVLB  0
2360:  CALL   05C4
....................                   restart_wdt(); 
2364:  CLRWDT
....................                   output_bit(P485ctrl,0); 
2366:  BCF    F8A.3
2368:  BCF    F93.3
....................                
....................                } 
....................                else if(Data_ByteCount == 0x02) 
236A:  BRA    252C
236C:  MOVF   xEB,W
236E:  SUBLW  02
2370:  BTFSS  FD8.2
2372:  BRA    252C
....................                { 
....................                   //Data_Buff[1] = ~output[1] >> Start_Address ; 
....................                   //DataTemp = ~output[1] << (0x08 - Start_Address) ; 
....................                   //Data_Buff[0] = (~output[0] >> Start_Address) | DataTemp;   //Low Byte 
....................                    
....................                   //Data_Buff[1] = Output9_16 >> Start_Address ;//jj 
....................                   //DataTemp = Output9_16 << (0x08 - Start_Address) ;//jj 
....................                   //Data_Buff[0] = (Output1_8 >> Start_Address) | DataTemp;   //Low Byte//jj 
....................                   Data_Buff[0] = Input1_8 >> Start_Address ; 
2374:  MOVFF  47,EC
2378:  MOVF   xE7,W
237A:  MOVWF  01
237C:  BZ    2386
237E:  BCF    FD8.0
2380:  RRCF   xEC,F
2382:  DECFSZ 01,F
2384:  BRA    237E
....................                   Data_Buff[1] = Input9_10 ;// >> Start_Address ; 
2386:  MOVFF  48,ED
....................  
....................  
....................                   if((No_PointCount - 0x07) == 0x08) 
238A:  MOVLW  07
238C:  SUBWF  xE9,W
238E:  MOVLB  1
2390:  MOVWF  xAB
2392:  MOVLW  00
2394:  MOVLB  0
2396:  SUBWFB xEA,W
2398:  MOVLB  1
239A:  MOVWF  xAC
239C:  MOVF   xAB,W
239E:  SUBLW  08
23A0:  BNZ   23A8
23A2:  MOVF   xAC,F
23A4:  BNZ   23A8
....................                   { 
....................                      Data_Buff[1] = Data_Buff[1] & 0xFF ; //16 Point High Byte 
....................                   } 
....................                   else if((No_PointCount - 0x07) == 0x07) 
23A6:  BRA    24AE
23A8:  MOVLW  07
23AA:  MOVLB  0
23AC:  SUBWF  xE9,W
23AE:  MOVLB  1
23B0:  MOVWF  xAB
23B2:  MOVLW  00
23B4:  MOVLB  0
23B6:  SUBWFB xEA,W
23B8:  MOVLB  1
23BA:  MOVWF  xAC
23BC:  MOVF   xAB,W
23BE:  SUBLW  07
23C0:  BNZ   23CC
23C2:  MOVF   xAC,F
23C4:  BNZ   23CC
....................                   { 
....................                      Data_Buff[1] =    Data_Buff[1] & 0x7F ; //15 Point High Byte 
23C6:  MOVLB  0
23C8:  BCF    xED.7
....................                   } 
....................                   else if((No_PointCount - 0x07) == 0x06) 
23CA:  BRA    24AC
23CC:  MOVLW  07
23CE:  MOVLB  0
23D0:  SUBWF  xE9,W
23D2:  MOVLB  1
23D4:  MOVWF  xAB
23D6:  MOVLW  00
23D8:  MOVLB  0
23DA:  SUBWFB xEA,W
23DC:  MOVLB  1
23DE:  MOVWF  xAC
23E0:  MOVF   xAB,W
23E2:  SUBLW  06
23E4:  BNZ   23F2
23E6:  MOVF   xAC,F
23E8:  BNZ   23F2
....................                   { 
....................                      Data_Buff[1] =    Data_Buff[1] & 0x3F ; //14 Point High Byte 
23EA:  MOVLW  3F
23EC:  MOVLB  0
23EE:  ANDWF  xED,F
....................                   } 
....................                   else if((No_PointCount - 0x07) == 0x05) 
23F0:  BRA    24AC
23F2:  MOVLW  07
23F4:  MOVLB  0
23F6:  SUBWF  xE9,W
23F8:  MOVLB  1
23FA:  MOVWF  xAB
23FC:  MOVLW  00
23FE:  MOVLB  0
2400:  SUBWFB xEA,W
2402:  MOVLB  1
2404:  MOVWF  xAC
2406:  MOVF   xAB,W
2408:  SUBLW  05
240A:  BNZ   2418
240C:  MOVF   xAC,F
240E:  BNZ   2418
....................                   { 
....................                      Data_Buff[1] =    Data_Buff[1] & 0x1F ; //13 Point High Byte 
2410:  MOVLW  1F
2412:  MOVLB  0
2414:  ANDWF  xED,F
....................                   } 
....................                   else if((No_PointCount - 0x07) == 0x04) 
2416:  BRA    24AC
2418:  MOVLW  07
241A:  MOVLB  0
241C:  SUBWF  xE9,W
241E:  MOVLB  1
2420:  MOVWF  xAB
2422:  MOVLW  00
2424:  MOVLB  0
2426:  SUBWFB xEA,W
2428:  MOVLB  1
242A:  MOVWF  xAC
242C:  MOVF   xAB,W
242E:  SUBLW  04
2430:  BNZ   243E
2432:  MOVF   xAC,F
2434:  BNZ   243E
....................                   { 
....................                      Data_Buff[1] =    Data_Buff[1] & 0x0F ; //12 Point High Byte 
2436:  MOVLW  0F
2438:  MOVLB  0
243A:  ANDWF  xED,F
....................                   } 
....................                   else if((No_PointCount - 0x07) == 0x03) 
243C:  BRA    24AC
243E:  MOVLW  07
2440:  MOVLB  0
2442:  SUBWF  xE9,W
2444:  MOVLB  1
2446:  MOVWF  xAB
2448:  MOVLW  00
244A:  MOVLB  0
244C:  SUBWFB xEA,W
244E:  MOVLB  1
2450:  MOVWF  xAC
2452:  MOVF   xAB,W
2454:  SUBLW  03
2456:  BNZ   2464
2458:  MOVF   xAC,F
245A:  BNZ   2464
....................                   { 
....................                      Data_Buff[1] =    Data_Buff[1] & 0x07 ; //11 Point High Byte 
245C:  MOVLW  07
245E:  MOVLB  0
2460:  ANDWF  xED,F
....................                   } 
....................                   else if((No_PointCount - 0x07) == 0x02) 
2462:  BRA    24AC
2464:  MOVLW  07
2466:  MOVLB  0
2468:  SUBWF  xE9,W
246A:  MOVLB  1
246C:  MOVWF  xAB
246E:  MOVLW  00
2470:  MOVLB  0
2472:  SUBWFB xEA,W
2474:  MOVLB  1
2476:  MOVWF  xAC
2478:  MOVF   xAB,W
247A:  SUBLW  02
247C:  BNZ   248A
247E:  MOVF   xAC,F
2480:  BNZ   248A
....................                   { 
....................                      Data_Buff[1] =    Data_Buff[1] & 0x03 ; //10 Point High Byte 
2482:  MOVLW  03
2484:  MOVLB  0
2486:  ANDWF  xED,F
....................                   } 
....................                   else if((No_PointCount - 0x07) == 0x01) 
2488:  BRA    24AC
248A:  MOVLW  07
248C:  MOVLB  0
248E:  SUBWF  xE9,W
2490:  MOVLB  1
2492:  MOVWF  xAB
2494:  MOVLW  00
2496:  MOVLB  0
2498:  SUBWFB xEA,W
249A:  MOVLB  1
249C:  MOVWF  xAC
249E:  DECFSZ xAB,W
24A0:  BRA    24AE
24A2:  MOVF   xAC,F
24A4:  BNZ   24AE
....................                   { 
....................                      Data_Buff[1] =    Data_Buff[1] & 0x01 ; //9 Point High Byte 
24A6:  MOVLW  01
24A8:  MOVLB  0
24AA:  ANDWF  xED,F
24AC:  MOVLB  1
....................                   } 
....................  
....................                   TxD_Buff[0] = Address ;         //Address 
24AE:  MOVFF  69,6B
....................                   TxD_Buff[1] = 0x01 ;         //Function Code 
24B2:  MOVLW  01
24B4:  MOVWF  6C
....................                   TxD_Buff[2] = Data_ByteCount ;   //Byte Count 
24B6:  MOVFF  EB,6D
....................                   TxD_Buff[3] = Data_Buff[0] ;      //first byte Data 
24BA:  MOVFF  EC,6E
....................                   TxD_Buff[4] = Data_Buff[1] ;      //second byte Data 
24BE:  MOVFF  ED,6F
....................  
....................                   CRC(TxD_Buff,5)   ;            //Cal CRC 5 Byte 
24C2:  CLRF   xAD
24C4:  MOVLW  6B
24C6:  MOVWF  xAC
24C8:  MOVLW  05
24CA:  MOVWF  xAE
24CC:  MOVLB  0
24CE:  CALL   1A46
....................  
....................                   TxD_Buff[5] = CRC_Hi ; 
24D2:  MOVFF  E4,70
....................                   TxD_Buff[6] = CRC_Lo ; 
24D6:  MOVFF  E3,71
....................  
....................                   //TxD_DataLen = 0x07 ; 
....................                   //rs485_ctrl = 1; 
....................                   //dmsec(4); 
....................                   //send = 1; 
....................                   //TI=1; 
....................                   output_bit(P485ctrl,1); 
24DA:  BSF    F8A.3
24DC:  BCF    F93.3
....................                   restart_wdt(); 
24DE:  CLRWDT
....................                   delay_ms(4); 
24E0:  MOVLW  04
24E2:  MOVLB  1
24E4:  MOVWF  xB3
24E6:  MOVLB  0
24E8:  CALL   05C4
....................                   restart_wdt(); 
24EC:  CLRWDT
....................  
....................                   putc(TxD_Buff[0]) ;               //Address 
24EE:  MOVF   6B,W
24F0:  CALL   1AB4
....................                   putc(TxD_Buff[1]) ;               //Function Code 
24F4:  MOVF   6C,W
24F6:  CALL   1AB4
....................                   putc(TxD_Buff[2]) ;               //Byte Count 
24FA:  MOVF   6D,W
24FC:  CALL   1AB4
....................                   putc(TxD_Buff[3]) ; 
2500:  MOVF   6E,W
2502:  CALL   1AB4
....................                   putc(TxD_Buff[4]) ; 
2506:  MOVF   6F,W
2508:  CALL   1AB4
....................                   putc(TxD_Buff[5]) ; 
250C:  MOVF   70,W
250E:  CALL   1AB4
....................                   putc(TxD_Buff[6]) ; 
2512:  MOVF   71,W
2514:  CALL   1AB4
....................                   //putc(TxD_Buff[7]) ; 
....................                   //putc(TxD_Buff[8]) ; 
....................                   //putc(TxD_Buff[9]) ; 
....................  
....................                   restart_wdt(); 
2518:  CLRWDT
....................                   delay_ms(3); 
251A:  MOVLW  03
251C:  MOVLB  1
251E:  MOVWF  xB3
2520:  MOVLB  0
2522:  CALL   05C4
....................                   restart_wdt(); 
2526:  CLRWDT
....................                   output_bit(P485ctrl,0); 
2528:  BCF    F8A.3
252A:  BCF    F93.3
....................                
....................                } 
....................             } 
....................             else 
252C:  BRA    259A
....................             { 
....................                //invalid parameter 
....................                TxD_Buff[0] = Address ;         //Address 
252E:  MOVFF  69,6B
....................                TxD_Buff[1] = 0x81 ;         //Function Code 
2532:  MOVLW  81
2534:  MOVWF  6C
....................                TxD_Buff[2] = 0x02 ;         //illegal data address 
2536:  MOVLW  02
2538:  MOVWF  6D
....................  
....................                CRC(TxD_Buff,3)   ;            //Cal CRC 3 Byte 
253A:  MOVLB  1
253C:  CLRF   xAD
253E:  MOVLW  6B
2540:  MOVWF  xAC
2542:  MOVLW  03
2544:  MOVWF  xAE
2546:  MOVLB  0
2548:  CALL   1A46
....................  
....................                TxD_Buff[3] = CRC_Hi ; 
254C:  MOVFF  E4,6E
....................                TxD_Buff[4] = CRC_Lo ; 
2550:  MOVFF  E3,6F
....................  
....................                //TxD_DataLen = 0x05 ; 
....................                //rs485_ctrl = 1; 
....................                //restart_wdt(); 
....................                //dmsec(4); 
....................                //restart_wdt(); 
....................                //send = 1; 
....................                //TI=1; 
....................                output_bit(P485ctrl,1); 
2554:  BSF    F8A.3
2556:  BCF    F93.3
....................                restart_wdt(); 
2558:  CLRWDT
....................                delay_ms(4); 
255A:  MOVLW  04
255C:  MOVLB  1
255E:  MOVWF  xB3
2560:  MOVLB  0
2562:  CALL   05C4
....................                restart_wdt(); 
2566:  CLRWDT
....................  
....................                putc(TxD_Buff[0]) ;               //Address 
2568:  MOVF   6B,W
256A:  CALL   1AB4
....................                putc(TxD_Buff[1]) ;               //Function Code 
256E:  MOVF   6C,W
2570:  CALL   1AB4
....................                putc(TxD_Buff[2]) ;               //Byte Count 
2574:  MOVF   6D,W
2576:  CALL   1AB4
....................                putc(TxD_Buff[3]) ; 
257A:  MOVF   6E,W
257C:  CALL   1AB4
....................                putc(TxD_Buff[4]) ; 
2580:  MOVF   6F,W
2582:  CALL   1AB4
....................               //putc(TxD_Buff[5]) ; 
....................                //putc(TxD_Buff[6]) ; 
....................                //putc(TxD_Buff[7]) ; 
....................                //putc(TxD_Buff[8]) ; 
....................                //putc(TxD_Buff[9]) ; 
....................  
....................                restart_wdt(); 
2586:  CLRWDT
....................                delay_ms(3); 
2588:  MOVLW  03
258A:  MOVLB  1
258C:  MOVWF  xB3
258E:  MOVLB  0
2590:  CALL   05C4
....................                restart_wdt(); 
2594:  CLRWDT
....................                output_bit(P485ctrl,0); 
2596:  BCF    F8A.3
2598:  BCF    F93.3
....................                 
....................             } 
....................          } 
.................... ////\*/ 
....................  
....................  
....................               /*-------------jack----*/ 
....................   
....................       if(RxD_Buff[1] == 0x07)///////////// READ COIL (esp code)//////////// 
259A:  MOVF   xA8,W
259C:  SUBLW  07
259E:  BTFSS  FD8.2
25A0:  BRA    26FE
....................       { 
....................          alarmtosend(); 
25A2:  GOTO   1ABE
....................           
....................          disable_interrupts(INT_TIMER2); 
25A6:  BCF    F9D.1
....................          //----------------------------------jj----------------------------// 
....................           
....................             Data_Buff[0] = Input1_8_Send ; //>> Start_Address ; 
25A8:  MOVFF  1B,EC
....................             Data_Buff[1] = Input9_16_Send ;// >> Start_Address ; 
25AC:  MOVFF  1C,ED
....................             Data_Buff[2] = Input17_24_Send ;// >> Start_Address ; 
25B0:  MOVFF  1D,EE
....................             Data_Buff[3] = Input25_32_Send ; 
25B4:  MOVFF  1E,EF
....................             Data_Buff[4] = Input33_40_Send ; 
25B8:  MOVFF  1F,F0
....................             Data_Buff[5] = Input41_48_Send ; 
25BC:  MOVFF  20,F1
....................             Data_Buff[6] = Input49_56_Send ; 
25C0:  MOVFF  21,F2
....................             Data_Buff[7] = Input57_64_Send ; 
25C4:  MOVFF  22,F3
....................             
....................             Data_Buff[8] = Ack1_8_Send ; 
25C8:  MOVFF  23,F4
....................             Data_Buff[9] = Ack9_16_Send ; 
25CC:  MOVFF  24,F5
....................             Data_Buff[10] = Ack17_24_Send ; 
25D0:  MOVFF  25,F6
....................             Data_Buff[11] = Ack25_32_Send ; 
25D4:  MOVFF  26,F7
....................             Data_Buff[12] = Ack33_40_Send ; 
25D8:  MOVFF  27,F8
....................             Data_Buff[13] = Ack41_48_Send ; 
25DC:  MOVFF  28,F9
....................             Data_Buff[14] = Ack49_56_Send ; 
25E0:  MOVFF  29,FA
....................             Data_Buff[15] = Ack57_64_Send ; 
25E4:  MOVFF  2A,FB
....................     
....................              
....................              
....................             TxD_Buff[0] = Address ;         //Address 
25E8:  MOVFF  69,6B
....................             TxD_Buff[1] = 0x07 ;         //Function Code 
25EC:  MOVLW  07
25EE:  MOVWF  6C
....................             TxD_Buff[2] = Data_ByteCount=0x10;   //Byte Count 
25F0:  MOVLW  10
25F2:  MOVWF  xEB
25F4:  MOVFF  EB,6D
....................             TxD_Buff[3] = Data_Buff[0] ;      //first byte Data 
25F8:  MOVFF  EC,6E
....................             TxD_Buff[4] = Data_Buff[1] ;      //second byte Data 
25FC:  MOVFF  ED,6F
....................             TxD_Buff[5] = Data_Buff[2] ;   
2600:  MOVFF  EE,70
....................             TxD_Buff[6] = Data_Buff[3] ; 
2604:  MOVFF  EF,71
....................             TxD_Buff[7] = Data_Buff[4] ; 
2608:  MOVFF  F0,72
....................             TxD_Buff[8] = Data_Buff[5] ; 
260C:  MOVFF  F1,73
....................             TxD_Buff[9] = Data_Buff[6] ; 
2610:  MOVFF  F2,74
....................             TxD_Buff[10] = Data_Buff[7] ; 
2614:  MOVFF  F3,75
....................                
....................            TxD_Buff[11] = Data_Buff[8] ; //Ack1-8 
2618:  MOVFF  F4,76
....................            TxD_Buff[12] = Data_Buff[9] ; 
261C:  MOVFF  F5,77
....................            TxD_Buff[13] = Data_Buff[10] ; 
2620:  MOVFF  F6,78
....................            TxD_Buff[14] = Data_Buff[11] ; 
2624:  MOVFF  F7,79
....................            TxD_Buff[15] = Data_Buff[12] ; 
2628:  MOVFF  F8,7A
....................            TxD_Buff[16] = Data_Buff[13] ; 
262C:  MOVFF  F9,7B
....................            TxD_Buff[17] = Data_Buff[14] ; 
2630:  MOVFF  FA,7C
....................            TxD_Buff[18] = Data_Buff[15] ; //Ack57-64 
2634:  MOVFF  FB,7D
....................  
....................            CRC(TxD_Buff,19);            //Cal CRC 5 Byte 
2638:  MOVLB  1
263A:  CLRF   xAD
263C:  MOVLW  6B
263E:  MOVWF  xAC
2640:  MOVLW  13
2642:  MOVWF  xAE
2644:  MOVLB  0
2646:  CALL   1A46
....................  
....................           TxD_Buff[19] = CRC_Hi ; 
264A:  MOVFF  E4,7E
....................           TxD_Buff[20] = CRC_Lo ; 
264E:  MOVFF  E3,7F
....................  
....................          
....................          output_bit(P485ctrl,1); 
2652:  BSF    F8A.3
2654:  BCF    F93.3
....................          restart_wdt(); 
2656:  CLRWDT
....................          delay_ms(4); 
2658:  MOVLW  04
265A:  MOVLB  1
265C:  MOVWF  xB3
265E:  MOVLB  0
2660:  CALL   05C4
....................          restart_wdt(); 
2664:  CLRWDT
....................           
....................           
....................           
....................          putc(TxD_Buff[0]) ;               //Address 
2666:  MOVF   6B,W
2668:  CALL   1AB4
....................          putc(TxD_Buff[1]) ;               //Function Code 
266C:  MOVF   6C,W
266E:  CALL   1AB4
....................          putc(TxD_Buff[2]) ;               //Byte Count 
2672:  MOVF   6D,W
2674:  CALL   1AB4
....................          putc(TxD_Buff[3]) ; 
2678:  MOVF   6E,W
267A:  CALL   1AB4
....................          putc(TxD_Buff[4]) ; 
267E:  MOVF   6F,W
2680:  CALL   1AB4
....................          putc(TxD_Buff[5]) ; 
2684:  MOVF   70,W
2686:  CALL   1AB4
....................          putc(TxD_Buff[6]) ; 
268A:  MOVF   71,W
268C:  CALL   1AB4
....................          putc(TxD_Buff[7]) ; 
2690:  MOVF   72,W
2692:  CALL   1AB4
....................          putc(TxD_Buff[8]) ; 
2696:  MOVF   73,W
2698:  CALL   1AB4
....................          putc(TxD_Buff[9]) ; 
269C:  MOVF   74,W
269E:  CALL   1AB4
....................          putc(TxD_Buff[10]) ; 
26A2:  MOVF   75,W
26A4:  CALL   1AB4
....................          putc(TxD_Buff[11]) ; 
26A8:  MOVF   76,W
26AA:  CALL   1AB4
....................          putc(TxD_Buff[12]) ; 
26AE:  MOVF   77,W
26B0:  CALL   1AB4
....................          putc(TxD_Buff[13]) ; 
26B4:  MOVF   78,W
26B6:  CALL   1AB4
....................          putc(TxD_Buff[14]) ; 
26BA:  MOVF   79,W
26BC:  CALL   1AB4
....................          putc(TxD_Buff[15]) ; 
26C0:  MOVF   7A,W
26C2:  CALL   1AB4
....................          putc(TxD_Buff[16]) ; 
26C6:  MOVF   7B,W
26C8:  CALL   1AB4
....................          putc(TxD_Buff[17]) ; 
26CC:  MOVF   7C,W
26CE:  CALL   1AB4
....................          putc(TxD_Buff[18]) ; 
26D2:  MOVF   7D,W
26D4:  CALL   1AB4
....................          putc(TxD_Buff[19]) ; 
26D8:  MOVF   7E,W
26DA:  CALL   1AB4
....................          putc(TxD_Buff[20]) ; 
26DE:  MOVF   7F,W
26E0:  CALL   1AB4
....................  
....................          restart_wdt(); 
26E4:  CLRWDT
....................          delay_ms(3); 
26E6:  MOVLW  03
26E8:  MOVLB  1
26EA:  MOVWF  xB3
26EC:  MOVLB  0
26EE:  CALL   05C4
....................          restart_wdt(); 
26F2:  CLRWDT
....................          output_bit(P485ctrl,0); 
26F4:  BCF    F8A.3
26F6:  BCF    F93.3
....................             
....................          
....................          ///////////////////////////////////////// 
....................           
....................         enable_interrupts(INT_TIMER2);  
26F8:  BSF    F9D.1
....................       
....................        } 
....................       ///////////////////////////////////////////////////////////////// 
....................          /*-------------jack---- 
....................          //else if(RxD_Buff[1] == 0x02)/////////// READ INPUT ///////////////////// 
....................          if(RxD_Buff[1] == 0x02)///////////// READ INPUT ///////////////////// 
....................          { 
....................             //Do Read Input 
....................             Start_Address = RxD_Buff[2] ; 
....................             Start_Address = (Start_Address << 8) | RxD_Buff[3] ;   //Start Address 16 bit 
....................             No_PointCount = RxD_Buff[4] ; 
....................             No_PointCount = (No_PointCount << 8) | RxD_Buff[5] ;      //No. of Point 16 bit 
....................  
....................             //if(Start_Address < 0x10 && (Start_Address + No_PointCount) < 0x11)  //Valid point 0-15 
....................             if(Start_Address == 0x00 && No_PointCount == 0x28)  //Valid point 0-40 
....................             { 
....................              
....................                //\* //----JACK Comment --------// 
....................                if(No_PointCount < 9) Data_ByteCount = 0x01 ; 
....................                else if(No_PointCount < 17) Data_ByteCount = 0x02 ; 
....................                else if(No_PointCount < 25) Data_ByteCount = 0x03 ; 
....................  
....................                if(Data_ByteCount == 0x01) 
....................                { 
....................                   if(Start_Address < 0x09) 
....................                   { 
....................                      Data_Buff[0] = Input1_8 >> Start_Address ; 
....................                      DataTemp = Input9_16 << (0x08 - Start_Address) ; 
....................                      Data_Buff[0] = (Input1_8 >> Start_Address) | DataTemp;   //Low Byte 
....................                   } 
....................                   else if(Start_Address > 0x08 && Start_Address < 0x10) 
....................                   { 
....................                      Data_Buff[0] = Input9_16 >> (Start_Address - 0x08) ; 
....................                   } 
....................  
....................  
....................                   if(No_PointCount == 0x08) 
....................                   { 
....................                      Data_Buff[0] = Data_Buff[0] & 0xFF ; //8 Point High Byte 
....................                   } 
....................                   else if(No_PointCount == 0x07) 
....................                   { 
....................                      Data_Buff[0] =    Data_Buff[0] & 0x7F ; //7 Point High Byte 
....................                   } 
....................                   else if(No_PointCount == 0x06) 
....................                   { 
....................                      Data_Buff[0] =    Data_Buff[0] & 0x3F ; //6 Point High Byte 
....................                   } 
....................                   else if(No_PointCount == 0x05) 
....................                   { 
....................                      Data_Buff[0] =    Data_Buff[0] & 0x1F ; //5 Point High Byte 
....................                   } 
....................                   else if(No_PointCount == 0x04) 
....................                   { 
....................                      Data_Buff[0] =    Data_Buff[0] & 0x0F ; //4 Point High Byte 
....................                   } 
....................                   else if(No_PointCount == 0x03) 
....................                   { 
....................                      Data_Buff[0] =    Data_Buff[0] & 0x07 ; //3 Point High Byte 
....................                   } 
....................                   else if(No_PointCount == 0x02) 
....................                   { 
....................                      Data_Buff[0] =    Data_Buff[0] & 0x03 ; //2 Point High Byte 
....................                   } 
....................                   else if(No_PointCount == 0x01) 
....................                   { 
....................                      Data_Buff[0] =    Data_Buff[0] & 0x01 ; //1 Point High Byte 
....................                   } 
....................  
....................                   TxD_Buff[0] = Address ;         //Address 
....................                   TxD_Buff[1] = 0x02 ;         //Function Code 
....................                   TxD_Buff[2] = Data_ByteCount ;   //Byte Count 
....................                   TxD_Buff[3] = Data_Buff[0] ;   //Data 
....................  
....................                   CRC(TxD_Buff,4)   ;            //Cal CRC 4 Byte 
....................  
....................                   TxD_Buff[4] = CRC_Hi ; 
....................                   TxD_Buff[5] = CRC_Lo ; 
....................  
....................                   TxD_DataLen = 0x06 ; 
....................                   //rs485_ctrl = 1; 
....................                   //dmsec(4); 
....................                   //send = 1; 
....................                   //TI=1; 
....................         //*\///----JACK Comment --------// 
....................  
....................                   TxD_Buff[0] = Address ;         //Address 
....................                   TxD_Buff[1] = 0x02 ;         //Function Code 
....................                   TxD_Buff[2] = 0x05 ;   //Byte Count 
....................                   TxD_Buff[3] = Input1_8 ;   //Data 
....................                   TxD_Buff[4] = Input9_16 ;   //Data 
....................                   TxD_Buff[5] = Input17_24 ;   //Data 
....................                   TxD_Buff[6] = Input25_32 ;   //Data 
....................                   TxD_Buff[7] = Input33_40 ;   //Data 
....................  
....................                   CRC(TxD_Buff,8);            //Cal CRC 4 Byte 
....................  
....................                   TxD_Buff[8] = CRC_Hi ; 
....................                   TxD_Buff[9] = CRC_Lo ; 
....................  
....................                   output_bit(P485ctrl,1); 
....................                   restart_wdt(); 
....................                   delay_ms(4); 
....................                   restart_wdt(); 
....................  
....................                   putc(TxD_Buff[0]) ;               //Address 
....................                   putc(TxD_Buff[1]) ;               //Function Code 
....................                   putc(TxD_Buff[2]) ;               //Byte Count 
....................                   putc(TxD_Buff[3]) ; 
....................                   putc(TxD_Buff[4]) ; 
....................                   putc(TxD_Buff[5]) ; 
....................                   putc(TxD_Buff[6]) ; 
....................                   putc(TxD_Buff[7]) ; 
....................                   putc(TxD_Buff[8]) ; 
....................                   putc(TxD_Buff[9]) ; 
....................  
....................                   delay_ms(3); 
....................                   output_bit(P485ctrl,0); 
....................  
....................                /*} 
....................                else if(Data_ByteCount == 0x02) 
....................                { 
....................                   Data_Buff[1] = ~input[1] >> Start_Address ; 
....................                   DataTemp = ~input[1] << (0x08 - Start_Address) ; 
....................                   Data_Buff[0] = (~input[0] >> Start_Address) | DataTemp;   //Low Byte 
....................  
....................                   if((No_PointCount - 0x08) == 0x08) 
....................                   { 
....................                      Data_Buff[1] = Data_Buff[1] & 0xFF ; //16 Point High Byte 
....................                   } 
....................                   else if((No_PointCount - 0x08) == 0x07) 
....................                   { 
....................                      Data_Buff[1] =    Data_Buff[1] & 0x7F ; //15 Point High Byte 
....................                   } 
....................                   else if((No_PointCount - 0x08) == 0x06) 
....................                   { 
....................                      Data_Buff[1] =    Data_Buff[1] & 0x3F ; //14 Point High Byte 
....................                   } 
....................                   else if((No_PointCount - 0x08) == 0x05) 
....................                   { 
....................                      Data_Buff[1] =    Data_Buff[1] & 0x1F ; //13 Point High Byte 
....................                   } 
....................                   else if((No_PointCount - 0x08) == 0x04) 
....................                   { 
....................                      Data_Buff[1] =    Data_Buff[1] & 0x0F ; //12 Point High Byte 
....................                   } 
....................                   else if((No_PointCount - 0x08) == 0x03) 
....................                   { 
....................                      Data_Buff[1] =    Data_Buff[1] & 0x07 ; //11 Point High Byte 
....................                   } 
....................                   else if((No_PointCount - 0x08) == 0x02) 
....................                   { 
....................                      Data_Buff[1] =    Data_Buff[1] & 0x03 ; //10 Point High Byte 
....................                   } 
....................                   else if((No_PointCount - 0x08) == 0x01) 
....................                   { 
....................                      Data_Buff[1] =    Data_Buff[1] & 0x01 ; //9 Point High Byte 
....................                   } 
....................  
....................                   TxD_Buff[0] = Address ;         //Address 
....................                   TxD_Buff[1] = 0x02 ;         //Function Code 
....................                   TxD_Buff[2] = Data_ByteCount ;   //Byte Count 
....................                   TxD_Buff[3] = Data_Buff[0] ;      //first byte Data 
....................                   TxD_Buff[4] = Data_Buff[1] ;      //second byte Data 
....................  
....................                   CRC(TxD_Buff,5)   ;            //Cal CRC 5 Byte 
....................  
....................                   TxD_Buff[5] = CRC_Hi ; 
....................                   TxD_Buff[6] = CRC_Lo ; 
....................  
....................                   TxD_DataLen = 0x07 ; 
....................                   rs485_ctrl = 1; 
....................                   dmsec(4); 
....................                   send = 1; 
....................                   TI=1; 
....................                }// 
....................             } 
....................             else 
....................             { 
....................                //Invalid function 
....................                TxD_Buff[0] = Address ;         //Address 
....................                TxD_Buff[1] = 0x81 ;         //Function Code 
....................                TxD_Buff[2] = 0x01 ;         //illegal function 
....................  
....................                CRC(TxD_Buff,3)   ;            //Cal CRC 3 Byte 
....................  
....................                TxD_Buff[3] = CRC_Hi ; 
....................                TxD_Buff[4] = CRC_Lo ; 
....................  
....................                output_bit(P485ctrl,1); 
....................                delay_ms(10); 
....................  
....................                putc(Txd_Buff[0]); 
....................                putc(Txd_Buff[1]); 
....................                putc(Txd_Buff[2]); 
....................                putc(Txd_Buff[3]); 
....................                putc(Txd_Buff[4]); 
....................  
....................                delay_ms(3); 
....................                output_bit(P485ctrl,0); 
....................             } 
....................  
....................          } 
....................       } 
....................        
....................       */ 
....................        else if(RxD_Buff[1] == 0x05)///////////// FORCE COIL ///////////////////// 
26FA:  GOTO   340A
26FE:  MOVF   xA8,W
2700:  SUBLW  05
2702:  BTFSS  FD8.2
2704:  BRA    2BD4
....................          { 
....................             //Do Force Coil 
....................             Start_Address = RxD_Buff[2] ; 
2706:  CLRF   xE8
2708:  MOVFF  A9,E7
....................             Start_Address = (Start_Address << 8) | RxD_Buff[3] ;   //Coil Address 16 bit 
270C:  MOVFF  E7,1AC
2710:  MOVLB  1
2712:  CLRF   xAB
2714:  MOVF   xAB,W
2716:  MOVLB  0
2718:  IORWF  xAA,W
271A:  MOVWF  xE7
271C:  MOVFF  1AC,E8
2720:  MOVLB  0
....................             No_PointCount = RxD_Buff[4] ; 
2722:  CLRF   xEA
2724:  MOVFF  AB,E9
....................             No_PointCount = (No_PointCount << 8) | RxD_Buff[5] ;   //Force Data 16 bit FF00 = ON, 00FF = OFF 
2728:  MOVFF  E9,1AC
272C:  MOVLB  1
272E:  CLRF   xAB
2730:  MOVF   xAB,W
2732:  MOVLB  0
2734:  IORWF  xAC,W
2736:  MOVWF  xE9
2738:  MOVFF  1AC,EA
273C:  MOVLB  0
....................  
....................             if(Start_Address == 0x00)   ////// Acknowlegde ////// 
273E:  MOVF   xE7,F
2740:  BNZ   27DC
2742:  MOVF   xE8,F
2744:  BNZ   27DC
....................             { 
....................                if(No_PointCount == 0xFF00)   //ON 
2746:  MOVF   xE9,F
2748:  BNZ   27DA
274A:  INCFSZ xEA,W
274C:  BRA    27DA
....................                { 
....................                   //Modbus_ACK = 1 ; 
....................                   AutoAckFlag = 1; 
274E:  BSF    17.2
....................  
....................                   TxD_Buff[0] = Address ;         //Address 
2750:  MOVFF  69,6B
....................                   TxD_Buff[1] = 0x05 ;         //Function Code 
2754:  MOVLW  05
2756:  MOVWF  6C
....................                   TxD_Buff[2] = RxD_Buff[2] ;      //Coil Address Hi 
2758:  MOVFF  A9,6D
....................                   TxD_Buff[3] = RxD_Buff[3] ;      //Coil Address Lo 
275C:  MOVFF  AA,6E
....................                   TxD_Buff[4] = RxD_Buff[4] ;      //Force Data Hi 
2760:  MOVFF  AB,6F
....................                   TxD_Buff[5] = RxD_Buff[5] ;      //Force Data Lo 
2764:  MOVFF  AC,70
....................  
....................                   CRC(TxD_Buff,6)   ;            //Cal CRC 6 Byte 
2768:  MOVLB  1
276A:  CLRF   xAD
276C:  MOVLW  6B
276E:  MOVWF  xAC
2770:  MOVLW  06
2772:  MOVWF  xAE
2774:  MOVLB  0
2776:  CALL   1A46
....................  
....................                   TxD_Buff[6] = CRC_Hi ; 
277A:  MOVFF  E4,71
....................                   TxD_Buff[7] = CRC_Lo ; 
277E:  MOVFF  E3,72
....................  
....................                   //TxD_DataLen = 0x08 ; 
....................                   //rs485_ctrl = 1; 
....................                   //dmsec(4); 
....................                   //send = 1; 
....................                   //TI=1; 
....................               output_bit(P485ctrl,1); 
2782:  BSF    F8A.3
2784:  BCF    F93.3
....................                   restart_wdt(); 
2786:  CLRWDT
....................                   delay_ms(4); 
2788:  MOVLW  04
278A:  MOVLB  1
278C:  MOVWF  xB3
278E:  MOVLB  0
2790:  CALL   05C4
....................                   restart_wdt(); 
2794:  CLRWDT
....................  
....................                   putc(TxD_Buff[0]) ;               //Address 
2796:  MOVF   6B,W
2798:  CALL   1AB4
....................                   putc(TxD_Buff[1]) ;               //Function Code 
279C:  MOVF   6C,W
279E:  CALL   1AB4
....................                   putc(TxD_Buff[2]) ;               //Byte Count 
27A2:  MOVF   6D,W
27A4:  CALL   1AB4
....................                   putc(TxD_Buff[3]) ; 
27A8:  MOVF   6E,W
27AA:  CALL   1AB4
....................                   putc(TxD_Buff[4]) ; 
27AE:  MOVF   6F,W
27B0:  CALL   1AB4
....................                   putc(TxD_Buff[5]) ; 
27B4:  MOVF   70,W
27B6:  CALL   1AB4
....................                   putc(TxD_Buff[6]) ; 
27BA:  MOVF   71,W
27BC:  CALL   1AB4
....................                   putc(TxD_Buff[7]) ; 
27C0:  MOVF   72,W
27C2:  CALL   1AB4
....................                   //putc(TxD_Buff[8]) ; 
....................                   //putc(TxD_Buff[9]) ; 
....................  
....................                   restart_wdt(); 
27C6:  CLRWDT
....................                   delay_ms(3); 
27C8:  MOVLW  03
27CA:  MOVLB  1
27CC:  MOVWF  xB3
27CE:  MOVLB  0
27D0:  CALL   05C4
....................                   restart_wdt(); 
27D4:  CLRWDT
....................                   output_bit(P485ctrl,0); 
27D6:  BCF    F8A.3
27D8:  BCF    F93.3
....................                
....................                } 
....................             } 
....................             else if(Start_Address == 0x01)   ///// Reset ////// 
27DA:  BRA    2BD0
27DC:  DECFSZ xE7,W
27DE:  BRA    287A
27E0:  MOVF   xE8,F
27E2:  BNZ   287A
....................             { 
....................                if(No_PointCount == 0xFF00)   //ON 
27E4:  MOVF   xE9,F
27E6:  BNZ   2878
27E8:  INCFSZ xEA,W
27EA:  BRA    2878
....................                { 
....................                   //Modbus_RET = 1 ; 
....................                   AutoResetFlag = 1; 
27EC:  BSF    17.3
....................                    
....................                   TxD_Buff[0] = Address ;         //Address 
27EE:  MOVFF  69,6B
....................                   TxD_Buff[1] = 0x05 ;         //Function Code 
27F2:  MOVLW  05
27F4:  MOVWF  6C
....................                   TxD_Buff[2] = RxD_Buff[2] ;      //Coil Address Hi 
27F6:  MOVFF  A9,6D
....................                   TxD_Buff[3] = RxD_Buff[3] ;      //Coil Address Lo 
27FA:  MOVFF  AA,6E
....................                   TxD_Buff[4] = RxD_Buff[4] ;      //Force Data Hi 
27FE:  MOVFF  AB,6F
....................                   TxD_Buff[5] = RxD_Buff[5] ;      //Force Data Lo 
2802:  MOVFF  AC,70
....................  
....................                   CRC(TxD_Buff,6)   ;            //Cal CRC 6 Byte 
2806:  MOVLB  1
2808:  CLRF   xAD
280A:  MOVLW  6B
280C:  MOVWF  xAC
280E:  MOVLW  06
2810:  MOVWF  xAE
2812:  MOVLB  0
2814:  CALL   1A46
....................  
....................                   TxD_Buff[6] = CRC_Hi ; 
2818:  MOVFF  E4,71
....................                   TxD_Buff[7] = CRC_Lo ; 
281C:  MOVFF  E3,72
....................  
....................                   //TxD_DataLen = 0x08 ; 
....................                   //rs485_ctrl = 1; 
....................                  //dmsec(4); 
....................                   //send = 1; 
....................                   //TI=1; 
....................               output_bit(P485ctrl,1); 
2820:  BSF    F8A.3
2822:  BCF    F93.3
....................                   restart_wdt(); 
2824:  CLRWDT
....................                   delay_ms(4); 
2826:  MOVLW  04
2828:  MOVLB  1
282A:  MOVWF  xB3
282C:  MOVLB  0
282E:  CALL   05C4
....................                   restart_wdt(); 
2832:  CLRWDT
....................  
....................                   putc(TxD_Buff[0]) ;               //Address 
2834:  MOVF   6B,W
2836:  CALL   1AB4
....................                   putc(TxD_Buff[1]) ;               //Function Code 
283A:  MOVF   6C,W
283C:  CALL   1AB4
....................                   putc(TxD_Buff[2]) ;               //Byte Count 
2840:  MOVF   6D,W
2842:  CALL   1AB4
....................                   putc(TxD_Buff[3]) ; 
2846:  MOVF   6E,W
2848:  CALL   1AB4
....................                   putc(TxD_Buff[4]) ; 
284C:  MOVF   6F,W
284E:  CALL   1AB4
....................                   putc(TxD_Buff[5]) ; 
2852:  MOVF   70,W
2854:  CALL   1AB4
....................                   putc(TxD_Buff[6]) ; 
2858:  MOVF   71,W
285A:  CALL   1AB4
....................                   putc(TxD_Buff[7]) ; 
285E:  MOVF   72,W
2860:  CALL   1AB4
....................                   //putc(TxD_Buff[8]) ; 
....................                   //putc(TxD_Buff[9]) ; 
....................  
....................                   restart_wdt(); 
2864:  CLRWDT
....................                   delay_ms(3); 
2866:  MOVLW  03
2868:  MOVLB  1
286A:  MOVWF  xB3
286C:  MOVLB  0
286E:  CALL   05C4
....................                   restart_wdt(); 
2872:  CLRWDT
....................                   output_bit(P485ctrl,0); 
2874:  BCF    F8A.3
2876:  BCF    F93.3
....................                
....................                } 
....................             } 
....................             else if(Start_Address == 0x02)   ///// Test ////// 
2878:  BRA    2BD0
287A:  MOVF   xE7,W
287C:  SUBLW  02
287E:  BTFSS  FD8.2
2880:  BRA    29C4
2882:  MOVF   xE8,F
2884:  BTFSS  FD8.2
2886:  BRA    29C4
....................             { 
....................                if(No_PointCount == 0xFF00)   //ON 
2888:  MOVF   xE9,F
288A:  BNZ   291E
288C:  INCFSZ xEA,W
288E:  BRA    291E
....................                { 
....................                   //Modbus_Lamp_Test = 1 ; 
....................                   AutoTestFlag = 1; 
2890:  BSF    17.4
....................  
....................                   TxD_Buff[0] = Address ;         //Address 
2892:  MOVFF  69,6B
....................                   TxD_Buff[1] = 0x05 ;         //Function Code 
2896:  MOVLW  05
2898:  MOVWF  6C
....................                   TxD_Buff[2] = RxD_Buff[2] ;      //Coil Address Hi 
289A:  MOVFF  A9,6D
....................                   TxD_Buff[3] = RxD_Buff[3] ;      //Coil Address Lo 
289E:  MOVFF  AA,6E
....................                   TxD_Buff[4] = RxD_Buff[4] ;      //Force Data Hi 
28A2:  MOVFF  AB,6F
....................                   TxD_Buff[5] = RxD_Buff[5] ;      //Force Data Lo 
28A6:  MOVFF  AC,70
....................  
....................                   CRC(TxD_Buff,6)   ;            //Cal CRC 6 Byte 
28AA:  MOVLB  1
28AC:  CLRF   xAD
28AE:  MOVLW  6B
28B0:  MOVWF  xAC
28B2:  MOVLW  06
28B4:  MOVWF  xAE
28B6:  MOVLB  0
28B8:  CALL   1A46
....................  
....................                   TxD_Buff[6] = CRC_Hi ; 
28BC:  MOVFF  E4,71
....................                   TxD_Buff[7] = CRC_Lo ; 
28C0:  MOVFF  E3,72
....................  
....................                  //TxD_DataLen = 0x08 ; 
....................                  //rs485_ctrl = 1; 
....................                  //dmsec(4); 
....................                  //send = 1; 
....................                  //TI=1; 
....................                   output_bit(P485ctrl,1); 
28C4:  BSF    F8A.3
28C6:  BCF    F93.3
....................                   restart_wdt(); 
28C8:  CLRWDT
....................                   delay_ms(4); 
28CA:  MOVLW  04
28CC:  MOVLB  1
28CE:  MOVWF  xB3
28D0:  MOVLB  0
28D2:  CALL   05C4
....................                   restart_wdt(); 
28D6:  CLRWDT
....................  
....................                   putc(TxD_Buff[0]) ;               //Address 
28D8:  MOVF   6B,W
28DA:  CALL   1AB4
....................                   putc(TxD_Buff[1]) ;               //Function Code 
28DE:  MOVF   6C,W
28E0:  CALL   1AB4
....................                   putc(TxD_Buff[2]) ;               //Byte Count 
28E4:  MOVF   6D,W
28E6:  CALL   1AB4
....................                   putc(TxD_Buff[3]) ; 
28EA:  MOVF   6E,W
28EC:  CALL   1AB4
....................                   putc(TxD_Buff[4]) ; 
28F0:  MOVF   6F,W
28F2:  CALL   1AB4
....................                   putc(TxD_Buff[5]) ; 
28F6:  MOVF   70,W
28F8:  CALL   1AB4
....................                   putc(TxD_Buff[6]) ; 
28FC:  MOVF   71,W
28FE:  CALL   1AB4
....................                   putc(TxD_Buff[7]) ; 
2902:  MOVF   72,W
2904:  CALL   1AB4
....................                   //putc(TxD_Buff[8]) ; 
....................                   //putc(TxD_Buff[9]) ; 
....................  
....................                   restart_wdt(); 
2908:  CLRWDT
....................                   delay_ms(3); 
290A:  MOVLW  03
290C:  MOVLB  1
290E:  MOVWF  xB3
2910:  MOVLB  0
2912:  CALL   05C4
....................                   restart_wdt(); 
2916:  CLRWDT
....................                   output_bit(P485ctrl,0); 
2918:  BCF    F8A.3
291A:  BCF    F93.3
....................               
....................                } 
....................                else if(No_PointCount == 0x00)   //OFF 
291C:  BRA    29C2
291E:  MOVF   xE9,F
2920:  BNZ   29C2
2922:  MOVF   xEA,F
2924:  BNZ   29C2
....................                { 
....................                   //Modbus_Lamp_Test = 0 ; 
....................                   AutoTestFlag = 0; 
2926:  BCF    17.4
....................                   Read_input(); 
2928:  CALL   0FF2
....................                   AutoAckFlag = 1; 
292C:  BSF    17.2
....................                   check_ack(); 
292E:  CALL   1C7A
....................                   AutoResetFlag = 1; 
2932:  BSF    17.3
....................                   check_reset(); 
2934:  CALL   1D68
....................  
....................                   TxD_Buff[0] = Address ;         //Address 
2938:  MOVFF  69,6B
....................                   TxD_Buff[1] = 0x05 ;         //Function Code 
293C:  MOVLW  05
293E:  MOVWF  6C
....................                   TxD_Buff[2] = RxD_Buff[2] ;      //Coil Address Hi 
2940:  MOVFF  A9,6D
....................                   TxD_Buff[3] = RxD_Buff[3] ;      //Coil Address Lo 
2944:  MOVFF  AA,6E
....................                   TxD_Buff[4] = RxD_Buff[4] ;      //Force Data Hi 
2948:  MOVFF  AB,6F
....................                   TxD_Buff[5] = RxD_Buff[5] ;      //Force Data Lo 
294C:  MOVFF  AC,70
....................  
....................                   CRC(TxD_Buff,6)   ;            //Cal CRC 6 Byte 
2950:  MOVLB  1
2952:  CLRF   xAD
2954:  MOVLW  6B
2956:  MOVWF  xAC
2958:  MOVLW  06
295A:  MOVWF  xAE
295C:  MOVLB  0
295E:  CALL   1A46
....................  
....................                   TxD_Buff[6] = CRC_Hi ; 
2962:  MOVFF  E4,71
....................                   TxD_Buff[7] = CRC_Lo ; 
2966:  MOVFF  E3,72
....................  
....................                   //TxD_DataLen = 0x08 ; 
....................                   //rs485_ctrl = 1; 
....................                   //dmsec(4); 
....................                   //send = 1; 
....................                   //TI=1; 
....................                   output_bit(P485ctrl,1); 
296A:  BSF    F8A.3
296C:  BCF    F93.3
....................                   restart_wdt(); 
296E:  CLRWDT
....................                   delay_ms(4); 
2970:  MOVLW  04
2972:  MOVLB  1
2974:  MOVWF  xB3
2976:  MOVLB  0
2978:  CALL   05C4
....................                   restart_wdt(); 
297C:  CLRWDT
....................  
....................                   putc(TxD_Buff[0]) ;               //Address 
297E:  MOVF   6B,W
2980:  CALL   1AB4
....................                   putc(TxD_Buff[1]) ;               //Function Code 
2984:  MOVF   6C,W
2986:  CALL   1AB4
....................                   putc(TxD_Buff[2]) ;               //Byte Count 
298A:  MOVF   6D,W
298C:  CALL   1AB4
....................                   putc(TxD_Buff[3]) ; 
2990:  MOVF   6E,W
2992:  CALL   1AB4
....................                   putc(TxD_Buff[4]) ; 
2996:  MOVF   6F,W
2998:  CALL   1AB4
....................                   putc(TxD_Buff[5]) ; 
299C:  MOVF   70,W
299E:  CALL   1AB4
....................                   putc(TxD_Buff[6]) ; 
29A2:  MOVF   71,W
29A4:  CALL   1AB4
....................                   putc(TxD_Buff[7]) ; 
29A8:  MOVF   72,W
29AA:  CALL   1AB4
....................                   //putc(TxD_Buff[8]) ; 
....................                   //putc(TxD_Buff[9]) ; 
....................  
....................                   restart_wdt(); 
29AE:  CLRWDT
....................                   delay_ms(3); 
29B0:  MOVLW  03
29B2:  MOVLB  1
29B4:  MOVWF  xB3
29B6:  MOVLB  0
29B8:  CALL   05C4
....................                   restart_wdt(); 
29BC:  CLRWDT
....................                   output_bit(P485ctrl,0); 
29BE:  BCF    F8A.3
29C0:  BCF    F93.3
....................                    
....................                } 
....................             } 
....................             else if(Start_Address == 0x03)   ///// Function Test ////// 
29C2:  BRA    2BD0
29C4:  MOVF   xE7,W
29C6:  SUBLW  03
29C8:  BTFSS  FD8.2
29CA:  BRA    2B0E
29CC:  MOVF   xE8,F
29CE:  BTFSS  FD8.2
29D0:  BRA    2B0E
....................             { 
....................                if(No_PointCount == 0xFF00)   //ON 
29D2:  MOVF   xE9,F
29D4:  BNZ   2A68
29D6:  INCFSZ xEA,W
29D8:  BRA    2A68
....................                { 
....................                   //Modbus_Lamp_Test = 1 ; 
....................                   test_fault = 1 ; 
29DA:  BSF    17.5
....................  
....................                   TxD_Buff[0] = Address ;         //Address 
29DC:  MOVFF  69,6B
....................                   TxD_Buff[1] = 0x05 ;         //Function Code 
29E0:  MOVLW  05
29E2:  MOVWF  6C
....................                   TxD_Buff[2] = RxD_Buff[2] ;      //Coil Address Hi 
29E4:  MOVFF  A9,6D
....................                   TxD_Buff[3] = RxD_Buff[3] ;      //Coil Address Lo 
29E8:  MOVFF  AA,6E
....................                   TxD_Buff[4] = RxD_Buff[4] ;      //Force Data Hi 
29EC:  MOVFF  AB,6F
....................                   TxD_Buff[5] = RxD_Buff[5] ;      //Force Data Lo 
29F0:  MOVFF  AC,70
....................  
....................                   CRC(TxD_Buff,6)   ;            //Cal CRC 6 Byte 
29F4:  MOVLB  1
29F6:  CLRF   xAD
29F8:  MOVLW  6B
29FA:  MOVWF  xAC
29FC:  MOVLW  06
29FE:  MOVWF  xAE
2A00:  MOVLB  0
2A02:  CALL   1A46
....................  
....................                   TxD_Buff[6] = CRC_Hi ; 
2A06:  MOVFF  E4,71
....................                   TxD_Buff[7] = CRC_Lo ; 
2A0A:  MOVFF  E3,72
....................  
....................                   output_bit(P485ctrl,1); 
2A0E:  BSF    F8A.3
2A10:  BCF    F93.3
....................                   restart_wdt(); 
2A12:  CLRWDT
....................                   delay_ms(4); 
2A14:  MOVLW  04
2A16:  MOVLB  1
2A18:  MOVWF  xB3
2A1A:  MOVLB  0
2A1C:  CALL   05C4
....................                   restart_wdt(); 
2A20:  CLRWDT
....................  
....................                   putc(TxD_Buff[0]) ;               //Address 
2A22:  MOVF   6B,W
2A24:  CALL   1AB4
....................                   putc(TxD_Buff[1]) ;               //Function Code 
2A28:  MOVF   6C,W
2A2A:  CALL   1AB4
....................                   putc(TxD_Buff[2]) ;               //Byte Count 
2A2E:  MOVF   6D,W
2A30:  CALL   1AB4
....................                   putc(TxD_Buff[3]) ; 
2A34:  MOVF   6E,W
2A36:  CALL   1AB4
....................                   putc(TxD_Buff[4]) ; 
2A3A:  MOVF   6F,W
2A3C:  CALL   1AB4
....................                   putc(TxD_Buff[5]) ; 
2A40:  MOVF   70,W
2A42:  CALL   1AB4
....................                   putc(TxD_Buff[6]) ; 
2A46:  MOVF   71,W
2A48:  CALL   1AB4
....................                   putc(TxD_Buff[7]) ; 
2A4C:  MOVF   72,W
2A4E:  CALL   1AB4
....................                   //putc(TxD_Buff[8]) ; 
....................                   //putc(TxD_Buff[9]) ; 
....................  
....................                   restart_wdt(); 
2A52:  CLRWDT
....................                   delay_ms(10); 
2A54:  MOVLW  0A
2A56:  MOVLB  1
2A58:  MOVWF  xB3
2A5A:  MOVLB  0
2A5C:  CALL   05C4
....................                   restart_wdt(); 
2A60:  CLRWDT
....................                   output_bit(P485ctrl,0); 
2A62:  BCF    F8A.3
2A64:  BCF    F93.3
....................                } 
....................                else if(No_PointCount == 0x00)   //OFF 
2A66:  BRA    2B0C
2A68:  MOVF   xE9,F
2A6A:  BNZ   2B0C
2A6C:  MOVF   xEA,F
2A6E:  BNZ   2B0C
....................                { 
....................                   //Modbus_Lamp_Test = 0 ; 
....................                   test_fault = 0; 
2A70:  BCF    17.5
....................                   Read_input(); 
2A72:  CALL   0FF2
....................                   AutoAckFlag = 1; 
2A76:  BSF    17.2
....................                   check_ack(); 
2A78:  CALL   1C7A
....................                   AutoResetFlag = 1; 
2A7C:  BSF    17.3
....................                   check_reset(); 
2A7E:  CALL   1D68
....................  
....................                   TxD_Buff[0] = Address ;         //Address 
2A82:  MOVFF  69,6B
....................                   TxD_Buff[1] = 0x05 ;         //Function Code 
2A86:  MOVLW  05
2A88:  MOVWF  6C
....................                   TxD_Buff[2] = RxD_Buff[2] ;      //Coil Address Hi 
2A8A:  MOVFF  A9,6D
....................                   TxD_Buff[3] = RxD_Buff[3] ;      //Coil Address Lo 
2A8E:  MOVFF  AA,6E
....................                   TxD_Buff[4] = RxD_Buff[4] ;      //Force Data Hi 
2A92:  MOVFF  AB,6F
....................                   TxD_Buff[5] = RxD_Buff[5] ;      //Force Data Lo 
2A96:  MOVFF  AC,70
....................  
....................                   CRC(TxD_Buff,6)   ;            //Cal CRC 6 Byte 
2A9A:  MOVLB  1
2A9C:  CLRF   xAD
2A9E:  MOVLW  6B
2AA0:  MOVWF  xAC
2AA2:  MOVLW  06
2AA4:  MOVWF  xAE
2AA6:  MOVLB  0
2AA8:  CALL   1A46
....................  
....................                   TxD_Buff[6] = CRC_Hi ; 
2AAC:  MOVFF  E4,71
....................                   TxD_Buff[7] = CRC_Lo ; 
2AB0:  MOVFF  E3,72
....................  
....................                   //TxD_DataLen = 0x08 ; 
....................                   //rs485_ctrl = 1; 
....................                   //dmsec(4); 
....................                   //send = 1; 
....................                   //TI=1; 
....................                   output_bit(P485ctrl,1); 
2AB4:  BSF    F8A.3
2AB6:  BCF    F93.3
....................                   restart_wdt(); 
2AB8:  CLRWDT
....................                   delay_ms(4); 
2ABA:  MOVLW  04
2ABC:  MOVLB  1
2ABE:  MOVWF  xB3
2AC0:  MOVLB  0
2AC2:  CALL   05C4
....................                   restart_wdt(); 
2AC6:  CLRWDT
....................  
....................                   putc(TxD_Buff[0]) ;               //Address 
2AC8:  MOVF   6B,W
2ACA:  CALL   1AB4
....................                   putc(TxD_Buff[1]) ;               //Function Code 
2ACE:  MOVF   6C,W
2AD0:  CALL   1AB4
....................                   putc(TxD_Buff[2]) ;               //Byte Count 
2AD4:  MOVF   6D,W
2AD6:  CALL   1AB4
....................                   putc(TxD_Buff[3]) ; 
2ADA:  MOVF   6E,W
2ADC:  CALL   1AB4
....................                   putc(TxD_Buff[4]) ; 
2AE0:  MOVF   6F,W
2AE2:  CALL   1AB4
....................                   putc(TxD_Buff[5]) ; 
2AE6:  MOVF   70,W
2AE8:  CALL   1AB4
....................                   putc(TxD_Buff[6]) ; 
2AEC:  MOVF   71,W
2AEE:  CALL   1AB4
....................                   putc(TxD_Buff[7]) ; 
2AF2:  MOVF   72,W
2AF4:  CALL   1AB4
....................                   //putc(TxD_Buff[8]) ; 
....................                   //putc(TxD_Buff[9]) ; 
....................  
....................                   restart_wdt(); 
2AF8:  CLRWDT
....................                   delay_ms(3); 
2AFA:  MOVLW  03
2AFC:  MOVLB  1
2AFE:  MOVWF  xB3
2B00:  MOVLB  0
2B02:  CALL   05C4
....................                   restart_wdt(); 
2B06:  CLRWDT
....................                   output_bit(P485ctrl,0); 
2B08:  BCF    F8A.3
2B0A:  BCF    F93.3
....................                    
....................                } 
....................             } 
....................             else if(Start_Address == 0x64)   ///// Change Modbus Addr ////// 
2B0C:  BRA    2BD0
2B0E:  MOVF   xE7,W
2B10:  SUBLW  64
2B12:  BNZ   2BD0
2B14:  MOVF   xE8,F
2B16:  BNZ   2BD0
....................             { 
....................                Address = No_PointCount; 
2B18:  MOVFF  E9,69
....................                write_eeprom(0x1D,Address);   //Communication Address 
2B1C:  MOVLW  1D
2B1E:  MOVWF  FA9
2B20:  MOVFF  69,FA8
2B24:  BCF    FA6.6
2B26:  BCF    FA6.7
2B28:  BSF    FA6.2
2B2A:  MOVF   FF2,W
2B2C:  MOVWF  00
2B2E:  BCF    FF2.7
2B30:  MOVLB  F
2B32:  MOVLW  55
2B34:  MOVWF  FA7
2B36:  MOVLW  AA
2B38:  MOVWF  FA7
2B3A:  BSF    FA6.1
2B3C:  BTFSC  FA6.1
2B3E:  BRA    2B3C
2B40:  BCF    FA6.2
2B42:  MOVF   00,W
2B44:  IORWF  FF2,F
....................                 
....................                TxD_Buff[0] = Address ;         //Address 
2B46:  MOVFF  69,6B
....................                TxD_Buff[1] = 0x05 ;         //Function Code 
2B4A:  MOVLW  05
2B4C:  MOVWF  6C
....................                TxD_Buff[2] = RxD_Buff[2] ;      //Coil Address Hi 
2B4E:  MOVFF  A9,6D
....................                TxD_Buff[3] = RxD_Buff[3] ;      //Coil Address Lo 
2B52:  MOVFF  AA,6E
....................                TxD_Buff[4] = RxD_Buff[4] ;      //Force Data Hi 
2B56:  MOVFF  AB,6F
....................                TxD_Buff[5] = RxD_Buff[5] ;      //Force Data Lo 
2B5A:  MOVFF  AC,70
....................  
....................                CRC(TxD_Buff,6)   ;            //Cal CRC 6 Byte 
2B5E:  MOVLB  1
2B60:  CLRF   xAD
2B62:  MOVLW  6B
2B64:  MOVWF  xAC
2B66:  MOVLW  06
2B68:  MOVWF  xAE
2B6A:  MOVLB  0
2B6C:  CALL   1A46
....................  
....................                TxD_Buff[6] = CRC_Hi ; 
2B70:  MOVFF  E4,71
....................                TxD_Buff[7] = CRC_Lo ; 
2B74:  MOVFF  E3,72
....................  
....................                //TxD_DataLen = 0x08 ; 
....................                //rs485_ctrl = 1; 
....................                //dmsec(4); 
....................                //send = 1; 
....................                //TI=1; 
....................                output_bit(P485ctrl,1); 
2B78:  BSF    F8A.3
2B7A:  BCF    F93.3
....................                restart_wdt(); 
2B7C:  CLRWDT
....................                delay_ms(4); 
2B7E:  MOVLW  04
2B80:  MOVLB  1
2B82:  MOVWF  xB3
2B84:  MOVLB  0
2B86:  CALL   05C4
....................                restart_wdt(); 
2B8A:  CLRWDT
....................  
....................                putc(TxD_Buff[0]) ;               //Address 
2B8C:  MOVF   6B,W
2B8E:  CALL   1AB4
....................                putc(TxD_Buff[1]) ;               //Function Code 
2B92:  MOVF   6C,W
2B94:  CALL   1AB4
....................                putc(TxD_Buff[2]) ;               //Byte Count 
2B98:  MOVF   6D,W
2B9A:  CALL   1AB4
....................                putc(TxD_Buff[3]) ; 
2B9E:  MOVF   6E,W
2BA0:  CALL   1AB4
....................                putc(TxD_Buff[4]) ; 
2BA4:  MOVF   6F,W
2BA6:  CALL   1AB4
....................                putc(TxD_Buff[5]) ; 
2BAA:  MOVF   70,W
2BAC:  CALL   1AB4
....................                putc(TxD_Buff[6]) ; 
2BB0:  MOVF   71,W
2BB2:  CALL   1AB4
....................                putc(TxD_Buff[7]) ; 
2BB6:  MOVF   72,W
2BB8:  CALL   1AB4
....................                //putc(TxD_Buff[8]) ; 
....................                //putc(TxD_Buff[9]) ; 
....................  
....................                restart_wdt(); 
2BBC:  CLRWDT
....................                delay_ms(3); 
2BBE:  MOVLW  03
2BC0:  MOVLB  1
2BC2:  MOVWF  xB3
2BC4:  MOVLB  0
2BC6:  CALL   05C4
....................                restart_wdt(); 
2BCA:  CLRWDT
....................                output_bit(P485ctrl,0); 
2BCC:  BCF    F8A.3
2BCE:  BCF    F93.3
....................  
....................  
....................                //save_addr(); 
....................             } 
....................          } 
....................          //--------------------------------------------------// 
....................          /* 
....................          else if(RxD_Buff[1] == 0x20)///////////// READ SETTING ///////////////////// 
....................          { 
....................             TxD_Buff[0] = Address ;         //Address 
....................             TxD_Buff[1] = 0x20 ;            //function code 
....................             TxD_Buff[2] = 0x1C ;            //16 Byte//Data Byte count 
....................             TxD_Buff[3] = InputType1_8 ; 
....................             TxD_Buff[4] = InputType9_16 ; 
....................             TxD_Buff[5] = InputType17_24 ; 
....................              
....................             TxD_Buff[6] = FaultType1_8 ; 
....................             TxD_Buff[7] = FaultType9_16 ; 
....................             TxD_Buff[8] = FaultType17_24 ; 
....................              
....................             TxD_Buff[9] = OutputType1_8 ; 
....................             TxD_Buff[10] = OutputType9_16 ; 
....................             TxD_Buff[11] = OutputType17_24 ; 
....................              
....................             TxD_Buff[12] = OutputBoth1_8 ; 
....................             TxD_Buff[13] = OutputBoth9_16 ; 
....................             TxD_Buff[14] = OutputBoth17_24 ; 
....................             
....................             TxD_Buff[15] = Alarm_Indicator1_8 ; 
....................             TxD_Buff[16] = Alarm_Indicator9_16 ; 
....................             TxD_Buff[17] = Alarm_Indicator17_24 ; 
....................             
....................             TxD_Buff[18] = Red1_8; 
....................             TxD_Buff[19] = Red9_10; 
....................             TxD_Buff[20] = Red11_18; 
....................             TxD_Buff[21] = Red19_20; 
....................             TxD_Buff[22] = Green1_8; 
....................             TxD_Buff[23] = Green9_10; 
....................             TxD_Buff[24] = Green11_18; 
....................             TxD_Buff[25] = Green19_20; 
....................           
....................           
....................             TxD_Buff[26] = AutoAck ; 
....................             TxD_Buff[27] = AutoAckTime ; 
....................             TxD_Buff[28] = FlashingRate ; 
....................             TxD_Buff[29] = NoOfPoint ; 
....................             TxD_Buff[30] = FaultDelayTime ; 
....................             TxD_Buff[31] = Address ; 
....................  
....................  
....................             CRC(TxD_Buff,32)   ; //Cal CRC 49 byte 
....................  
....................             TxD_Buff[32] = CRC_Hi ; 
....................             TxD_Buff[33] = CRC_Lo ; 
....................  
....................             output_bit(P485ctrl,1); 
....................             delay_ms(10); 
....................  
....................             putc(Txd_Buff[0]); 
....................             putc(Txd_Buff[1]); 
....................             putc(Txd_Buff[2]); 
....................             putc(Txd_Buff[3]); 
....................             putc(Txd_Buff[4]); 
....................             putc(Txd_Buff[5]); 
....................             putc(Txd_Buff[6]); 
....................             putc(Txd_Buff[7]); 
....................             putc(Txd_Buff[8]); 
....................             putc(Txd_Buff[9]); 
....................             putc(Txd_Buff[10]); 
....................             putc(Txd_Buff[11]); 
....................             putc(Txd_Buff[12]); 
....................             putc(Txd_Buff[13]); 
....................             putc(Txd_Buff[14]); 
....................             putc(Txd_Buff[15]); 
....................             putc(Txd_Buff[16]); 
....................             putc(Txd_Buff[17]); 
....................             putc(Txd_Buff[18]); 
....................             putc(Txd_Buff[19]); 
....................             putc(Txd_Buff[20]); 
....................             putc(Txd_Buff[21]); 
....................             putc(Txd_Buff[22]); 
....................             putc(Txd_Buff[23]); 
....................             putc(Txd_Buff[24]); 
....................             putc(Txd_Buff[25]); 
....................             putc(Txd_Buff[26]); 
....................             putc(Txd_Buff[27]); 
....................             putc(Txd_Buff[28]); 
....................             putc(Txd_Buff[29]); 
....................             putc(Txd_Buff[30]); 
....................             putc(Txd_Buff[31]); 
....................             putc(Txd_Buff[32]); 
....................             putc(Txd_Buff[33]); 
....................            
....................  
....................  
....................             delay_ms(3); 
....................             output_bit(P485ctrl,0); 
....................          } 
....................          */ 
....................          else if(RxD_Buff[1] == 0x21)///////////// WRITE SETTING ///////////////////// 
2BD0:  GOTO   340A
2BD4:  MOVF   xA8,W
2BD6:  SUBLW  21
2BD8:  BTFSS  FD8.2
2BDA:  GOTO   340A
....................          { 
....................  
....................             write_eeprom(0x00,0x0F); 
2BDE:  CLRF   FA9
2BE0:  MOVLW  0F
2BE2:  MOVWF  FA8
2BE4:  BCF    FA6.6
2BE6:  BCF    FA6.7
2BE8:  BSF    FA6.2
2BEA:  MOVF   FF2,W
2BEC:  MOVWF  00
2BEE:  BCF    FF2.7
2BF0:  MOVLB  F
2BF2:  MOVLW  55
2BF4:  MOVWF  FA7
2BF6:  MOVLW  AA
2BF8:  MOVWF  FA7
2BFA:  BSF    FA6.1
2BFC:  BTFSC  FA6.1
2BFE:  BRA    2BFC
2C00:  BCF    FA6.2
2C02:  MOVF   00,W
2C04:  IORWF  FF2,F
....................  
....................             write_eeprom(0x01,RxD_Buff[3]);   //Input Type 
2C06:  MOVLW  01
2C08:  MOVWF  FA9
2C0A:  MOVFF  AA,FA8
2C0E:  BCF    FA6.6
2C10:  BCF    FA6.7
2C12:  BSF    FA6.2
2C14:  MOVFF  FF2,00
2C18:  BCF    FF2.7
2C1A:  MOVLW  55
2C1C:  MOVWF  FA7
2C1E:  MOVLW  AA
2C20:  MOVWF  FA7
2C22:  BSF    FA6.1
2C24:  BTFSC  FA6.1
2C26:  BRA    2C24
2C28:  BCF    FA6.2
2C2A:  MOVF   00,W
2C2C:  IORWF  FF2,F
....................             write_eeprom(0x02,RxD_Buff[4]); 
2C2E:  MOVLW  02
2C30:  MOVWF  FA9
2C32:  MOVFF  AB,FA8
2C36:  BCF    FA6.6
2C38:  BCF    FA6.7
2C3A:  BSF    FA6.2
2C3C:  MOVFF  FF2,00
2C40:  BCF    FF2.7
2C42:  MOVLW  55
2C44:  MOVWF  FA7
2C46:  MOVLW  AA
2C48:  MOVWF  FA7
2C4A:  BSF    FA6.1
2C4C:  BTFSC  FA6.1
2C4E:  BRA    2C4C
2C50:  BCF    FA6.2
2C52:  MOVF   00,W
2C54:  IORWF  FF2,F
....................             write_eeprom(0x03,RxD_Buff[5]); 
2C56:  MOVLW  03
2C58:  MOVWF  FA9
2C5A:  MOVFF  AC,FA8
2C5E:  BCF    FA6.6
2C60:  BCF    FA6.7
2C62:  BSF    FA6.2
2C64:  MOVFF  FF2,00
2C68:  BCF    FF2.7
2C6A:  MOVLW  55
2C6C:  MOVWF  FA7
2C6E:  MOVLW  AA
2C70:  MOVWF  FA7
2C72:  BSF    FA6.1
2C74:  BTFSC  FA6.1
2C76:  BRA    2C74
2C78:  BCF    FA6.2
2C7A:  MOVF   00,W
2C7C:  IORWF  FF2,F
....................            // write_eeprom(0x04,RxD_Buff[6]); 
....................            // write_eeprom(0x05,RxD_Buff[7]); 
....................            // write_eeprom(0x06,RxD_Buff[8]); 
....................            // write_eeprom(0x07,RxD_Buff[9]); 
....................            // write_eeprom(0x08,RxD_Buff[10]); 
....................  
....................             write_eeprom(0x04,RxD_Buff[6]);   //Fault Type 
2C7E:  MOVLW  04
2C80:  MOVWF  FA9
2C82:  MOVFF  AD,FA8
2C86:  BCF    FA6.6
2C88:  BCF    FA6.7
2C8A:  BSF    FA6.2
2C8C:  MOVFF  FF2,00
2C90:  BCF    FF2.7
2C92:  MOVLW  55
2C94:  MOVWF  FA7
2C96:  MOVLW  AA
2C98:  MOVWF  FA7
2C9A:  BSF    FA6.1
2C9C:  BTFSC  FA6.1
2C9E:  BRA    2C9C
2CA0:  BCF    FA6.2
2CA2:  MOVF   00,W
2CA4:  IORWF  FF2,F
....................             write_eeprom(0x05,RxD_Buff[7]); 
2CA6:  MOVLW  05
2CA8:  MOVWF  FA9
2CAA:  MOVFF  AE,FA8
2CAE:  BCF    FA6.6
2CB0:  BCF    FA6.7
2CB2:  BSF    FA6.2
2CB4:  MOVFF  FF2,00
2CB8:  BCF    FF2.7
2CBA:  MOVLW  55
2CBC:  MOVWF  FA7
2CBE:  MOVLW  AA
2CC0:  MOVWF  FA7
2CC2:  BSF    FA6.1
2CC4:  BTFSC  FA6.1
2CC6:  BRA    2CC4
2CC8:  BCF    FA6.2
2CCA:  MOVF   00,W
2CCC:  IORWF  FF2,F
....................             write_eeprom(0x06,RxD_Buff[8]); 
2CCE:  MOVLW  06
2CD0:  MOVWF  FA9
2CD2:  MOVFF  AF,FA8
2CD6:  BCF    FA6.6
2CD8:  BCF    FA6.7
2CDA:  BSF    FA6.2
2CDC:  MOVFF  FF2,00
2CE0:  BCF    FF2.7
2CE2:  MOVLW  55
2CE4:  MOVWF  FA7
2CE6:  MOVLW  AA
2CE8:  MOVWF  FA7
2CEA:  BSF    FA6.1
2CEC:  BTFSC  FA6.1
2CEE:  BRA    2CEC
2CF0:  BCF    FA6.2
2CF2:  MOVF   00,W
2CF4:  IORWF  FF2,F
....................             //write_eeprom(0x0C,RxD_Buff[14]); 
....................            // write_eeprom(0x0D,RxD_Buff[15]); 
....................             //write_eeprom(0x0E,RxD_Buff[16]); 
....................            // write_eeprom(0x0F,RxD_Buff[17]); 
....................            // write_eeprom(0x10,RxD_Buff[18]); 
....................  
....................             write_eeprom(0x07,RxD_Buff[9]);   //Output Type 
2CF6:  MOVLW  07
2CF8:  MOVWF  FA9
2CFA:  MOVFF  B0,FA8
2CFE:  BCF    FA6.6
2D00:  BCF    FA6.7
2D02:  BSF    FA6.2
2D04:  MOVFF  FF2,00
2D08:  BCF    FF2.7
2D0A:  MOVLW  55
2D0C:  MOVWF  FA7
2D0E:  MOVLW  AA
2D10:  MOVWF  FA7
2D12:  BSF    FA6.1
2D14:  BTFSC  FA6.1
2D16:  BRA    2D14
2D18:  BCF    FA6.2
2D1A:  MOVF   00,W
2D1C:  IORWF  FF2,F
....................             write_eeprom(0x08,RxD_Buff[10]); 
2D1E:  MOVLW  08
2D20:  MOVWF  FA9
2D22:  MOVFF  B1,FA8
2D26:  BCF    FA6.6
2D28:  BCF    FA6.7
2D2A:  BSF    FA6.2
2D2C:  MOVFF  FF2,00
2D30:  BCF    FF2.7
2D32:  MOVLW  55
2D34:  MOVWF  FA7
2D36:  MOVLW  AA
2D38:  MOVWF  FA7
2D3A:  BSF    FA6.1
2D3C:  BTFSC  FA6.1
2D3E:  BRA    2D3C
2D40:  BCF    FA6.2
2D42:  MOVF   00,W
2D44:  IORWF  FF2,F
....................             write_eeprom(0x09,RxD_Buff[11]); 
2D46:  MOVLW  09
2D48:  MOVWF  FA9
2D4A:  MOVFF  B2,FA8
2D4E:  BCF    FA6.6
2D50:  BCF    FA6.7
2D52:  BSF    FA6.2
2D54:  MOVFF  FF2,00
2D58:  BCF    FF2.7
2D5A:  MOVLW  55
2D5C:  MOVWF  FA7
2D5E:  MOVLW  AA
2D60:  MOVWF  FA7
2D62:  BSF    FA6.1
2D64:  BTFSC  FA6.1
2D66:  BRA    2D64
2D68:  BCF    FA6.2
2D6A:  MOVF   00,W
2D6C:  IORWF  FF2,F
....................            // write_eeprom(0x14,RxD_Buff[22]); 
....................            // write_eeprom(0x15,RxD_Buff[23]); 
....................           //  write_eeprom(0x16,RxD_Buff[24]); 
....................            // write_eeprom(0x17,RxD_Buff[25]); 
....................            // write_eeprom(0x18,RxD_Buff[26]); 
....................  
....................             write_eeprom(0x0A,RxD_Buff[12]);   //Output Both 
2D6E:  MOVLW  0A
2D70:  MOVWF  FA9
2D72:  MOVFF  B3,FA8
2D76:  BCF    FA6.6
2D78:  BCF    FA6.7
2D7A:  BSF    FA6.2
2D7C:  MOVFF  FF2,00
2D80:  BCF    FF2.7
2D82:  MOVLW  55
2D84:  MOVWF  FA7
2D86:  MOVLW  AA
2D88:  MOVWF  FA7
2D8A:  BSF    FA6.1
2D8C:  BTFSC  FA6.1
2D8E:  BRA    2D8C
2D90:  BCF    FA6.2
2D92:  MOVF   00,W
2D94:  IORWF  FF2,F
....................             write_eeprom(0x0B,RxD_Buff[13]); 
2D96:  MOVLW  0B
2D98:  MOVWF  FA9
2D9A:  MOVFF  B4,FA8
2D9E:  BCF    FA6.6
2DA0:  BCF    FA6.7
2DA2:  BSF    FA6.2
2DA4:  MOVFF  FF2,00
2DA8:  BCF    FF2.7
2DAA:  MOVLW  55
2DAC:  MOVWF  FA7
2DAE:  MOVLW  AA
2DB0:  MOVWF  FA7
2DB2:  BSF    FA6.1
2DB4:  BTFSC  FA6.1
2DB6:  BRA    2DB4
2DB8:  BCF    FA6.2
2DBA:  MOVF   00,W
2DBC:  IORWF  FF2,F
....................             write_eeprom(0x0C,RxD_Buff[14]); 
2DBE:  MOVLW  0C
2DC0:  MOVWF  FA9
2DC2:  MOVFF  B5,FA8
2DC6:  BCF    FA6.6
2DC8:  BCF    FA6.7
2DCA:  BSF    FA6.2
2DCC:  MOVFF  FF2,00
2DD0:  BCF    FF2.7
2DD2:  MOVLW  55
2DD4:  MOVWF  FA7
2DD6:  MOVLW  AA
2DD8:  MOVWF  FA7
2DDA:  BSF    FA6.1
2DDC:  BTFSC  FA6.1
2DDE:  BRA    2DDC
2DE0:  BCF    FA6.2
2DE2:  MOVF   00,W
2DE4:  IORWF  FF2,F
....................            // write_eeprom(0x1C,RxD_Buff[30]); 
....................            // write_eeprom(0x1D,RxD_Buff[31]); 
....................            // write_eeprom(0x1E,RxD_Buff[32]); 
....................            // write_eeprom(0x1F,RxD_Buff[33]); 
....................            // write_eeprom(0x20,RxD_Buff[34]); 
....................  
....................             write_eeprom(0x0D,RxD_Buff[15]);   //Alarm / Indicator 
2DE6:  MOVLW  0D
2DE8:  MOVWF  FA9
2DEA:  MOVFF  B6,FA8
2DEE:  BCF    FA6.6
2DF0:  BCF    FA6.7
2DF2:  BSF    FA6.2
2DF4:  MOVFF  FF2,00
2DF8:  BCF    FF2.7
2DFA:  MOVLW  55
2DFC:  MOVWF  FA7
2DFE:  MOVLW  AA
2E00:  MOVWF  FA7
2E02:  BSF    FA6.1
2E04:  BTFSC  FA6.1
2E06:  BRA    2E04
2E08:  BCF    FA6.2
2E0A:  MOVF   00,W
2E0C:  IORWF  FF2,F
....................             write_eeprom(0x0E,RxD_Buff[16]); 
2E0E:  MOVLW  0E
2E10:  MOVWF  FA9
2E12:  MOVFF  B7,FA8
2E16:  BCF    FA6.6
2E18:  BCF    FA6.7
2E1A:  BSF    FA6.2
2E1C:  MOVFF  FF2,00
2E20:  BCF    FF2.7
2E22:  MOVLW  55
2E24:  MOVWF  FA7
2E26:  MOVLW  AA
2E28:  MOVWF  FA7
2E2A:  BSF    FA6.1
2E2C:  BTFSC  FA6.1
2E2E:  BRA    2E2C
2E30:  BCF    FA6.2
2E32:  MOVF   00,W
2E34:  IORWF  FF2,F
....................             write_eeprom(0x0F,RxD_Buff[17]); 
2E36:  MOVLW  0F
2E38:  MOVWF  FA9
2E3A:  MOVFF  B8,FA8
2E3E:  BCF    FA6.6
2E40:  BCF    FA6.7
2E42:  BSF    FA6.2
2E44:  MOVFF  FF2,00
2E48:  BCF    FF2.7
2E4A:  MOVLW  55
2E4C:  MOVWF  FA7
2E4E:  MOVLW  AA
2E50:  MOVWF  FA7
2E52:  BSF    FA6.1
2E54:  BTFSC  FA6.1
2E56:  BRA    2E54
2E58:  BCF    FA6.2
2E5A:  MOVF   00,W
2E5C:  IORWF  FF2,F
....................            // write_eeprom(0x24,RxD_Buff[38]); 
....................            // write_eeprom(0x25,RxD_Buff[39]); 
....................            // write_eeprom(0x26,RxD_Buff[40]); 
....................            // write_eeprom(0x27,RxD_Buff[41]); 
....................            // write_eeprom(0x28,RxD_Buff[42]); 
....................           
....................             // LED Colour Config 
....................             write_eeprom(0x10,RxD_Buff[18]); //Red1_8 
2E5E:  MOVLW  10
2E60:  MOVWF  FA9
2E62:  MOVFF  B9,FA8
2E66:  BCF    FA6.6
2E68:  BCF    FA6.7
2E6A:  BSF    FA6.2
2E6C:  MOVFF  FF2,00
2E70:  BCF    FF2.7
2E72:  MOVLW  55
2E74:  MOVWF  FA7
2E76:  MOVLW  AA
2E78:  MOVWF  FA7
2E7A:  BSF    FA6.1
2E7C:  BTFSC  FA6.1
2E7E:  BRA    2E7C
2E80:  BCF    FA6.2
2E82:  MOVF   00,W
2E84:  IORWF  FF2,F
....................             write_eeprom(0x11,RxD_Buff[19]); //Red9_10 
2E86:  MOVLW  11
2E88:  MOVWF  FA9
2E8A:  MOVFF  BA,FA8
2E8E:  BCF    FA6.6
2E90:  BCF    FA6.7
2E92:  BSF    FA6.2
2E94:  MOVFF  FF2,00
2E98:  BCF    FF2.7
2E9A:  MOVLW  55
2E9C:  MOVWF  FA7
2E9E:  MOVLW  AA
2EA0:  MOVWF  FA7
2EA2:  BSF    FA6.1
2EA4:  BTFSC  FA6.1
2EA6:  BRA    2EA4
2EA8:  BCF    FA6.2
2EAA:  MOVF   00,W
2EAC:  IORWF  FF2,F
....................             write_eeprom(0x12,RxD_Buff[20]); //Red11_18 
2EAE:  MOVLW  12
2EB0:  MOVWF  FA9
2EB2:  MOVFF  BB,FA8
2EB6:  BCF    FA6.6
2EB8:  BCF    FA6.7
2EBA:  BSF    FA6.2
2EBC:  MOVFF  FF2,00
2EC0:  BCF    FF2.7
2EC2:  MOVLW  55
2EC4:  MOVWF  FA7
2EC6:  MOVLW  AA
2EC8:  MOVWF  FA7
2ECA:  BSF    FA6.1
2ECC:  BTFSC  FA6.1
2ECE:  BRA    2ECC
2ED0:  BCF    FA6.2
2ED2:  MOVF   00,W
2ED4:  IORWF  FF2,F
....................             write_eeprom(0x13,RxD_Buff[21]); //Red19_20 
2ED6:  MOVLW  13
2ED8:  MOVWF  FA9
2EDA:  MOVFF  BC,FA8
2EDE:  BCF    FA6.6
2EE0:  BCF    FA6.7
2EE2:  BSF    FA6.2
2EE4:  MOVFF  FF2,00
2EE8:  BCF    FF2.7
2EEA:  MOVLW  55
2EEC:  MOVWF  FA7
2EEE:  MOVLW  AA
2EF0:  MOVWF  FA7
2EF2:  BSF    FA6.1
2EF4:  BTFSC  FA6.1
2EF6:  BRA    2EF4
2EF8:  BCF    FA6.2
2EFA:  MOVF   00,W
2EFC:  IORWF  FF2,F
....................             write_eeprom(0x14,RxD_Buff[22]); //Green1_8 
2EFE:  MOVLW  14
2F00:  MOVWF  FA9
2F02:  MOVFF  BD,FA8
2F06:  BCF    FA6.6
2F08:  BCF    FA6.7
2F0A:  BSF    FA6.2
2F0C:  MOVFF  FF2,00
2F10:  BCF    FF2.7
2F12:  MOVLW  55
2F14:  MOVWF  FA7
2F16:  MOVLW  AA
2F18:  MOVWF  FA7
2F1A:  BSF    FA6.1
2F1C:  BTFSC  FA6.1
2F1E:  BRA    2F1C
2F20:  BCF    FA6.2
2F22:  MOVF   00,W
2F24:  IORWF  FF2,F
....................             write_eeprom(0x15,RxD_Buff[23]); //Green9_10 
2F26:  MOVLW  15
2F28:  MOVWF  FA9
2F2A:  MOVFF  BE,FA8
2F2E:  BCF    FA6.6
2F30:  BCF    FA6.7
2F32:  BSF    FA6.2
2F34:  MOVFF  FF2,00
2F38:  BCF    FF2.7
2F3A:  MOVLW  55
2F3C:  MOVWF  FA7
2F3E:  MOVLW  AA
2F40:  MOVWF  FA7
2F42:  BSF    FA6.1
2F44:  BTFSC  FA6.1
2F46:  BRA    2F44
2F48:  BCF    FA6.2
2F4A:  MOVF   00,W
2F4C:  IORWF  FF2,F
....................             write_eeprom(0x16,RxD_Buff[24]); //Green11_18 
2F4E:  MOVLW  16
2F50:  MOVWF  FA9
2F52:  MOVFF  BF,FA8
2F56:  BCF    FA6.6
2F58:  BCF    FA6.7
2F5A:  BSF    FA6.2
2F5C:  MOVFF  FF2,00
2F60:  BCF    FF2.7
2F62:  MOVLW  55
2F64:  MOVWF  FA7
2F66:  MOVLW  AA
2F68:  MOVWF  FA7
2F6A:  BSF    FA6.1
2F6C:  BTFSC  FA6.1
2F6E:  BRA    2F6C
2F70:  BCF    FA6.2
2F72:  MOVF   00,W
2F74:  IORWF  FF2,F
....................             write_eeprom(0x17,RxD_Buff[25]); //Green19_20 
2F76:  MOVLW  17
2F78:  MOVWF  FA9
2F7A:  MOVFF  C0,FA8
2F7E:  BCF    FA6.6
2F80:  BCF    FA6.7
2F82:  BSF    FA6.2
2F84:  MOVFF  FF2,00
2F88:  BCF    FF2.7
2F8A:  MOVLW  55
2F8C:  MOVWF  FA7
2F8E:  MOVLW  AA
2F90:  MOVWF  FA7
2F92:  BSF    FA6.1
2F94:  BTFSC  FA6.1
2F96:  BRA    2F94
2F98:  BCF    FA6.2
2F9A:  MOVF   00,W
2F9C:  IORWF  FF2,F
....................                 
....................             write_eeprom(0x18,RxD_Buff[26]);   //Auto acknowledge 
2F9E:  MOVLW  18
2FA0:  MOVWF  FA9
2FA2:  MOVFF  C1,FA8
2FA6:  BCF    FA6.6
2FA8:  BCF    FA6.7
2FAA:  BSF    FA6.2
2FAC:  MOVFF  FF2,00
2FB0:  BCF    FF2.7
2FB2:  MOVLW  55
2FB4:  MOVWF  FA7
2FB6:  MOVLW  AA
2FB8:  MOVWF  FA7
2FBA:  BSF    FA6.1
2FBC:  BTFSC  FA6.1
2FBE:  BRA    2FBC
2FC0:  BCF    FA6.2
2FC2:  MOVF   00,W
2FC4:  IORWF  FF2,F
....................             write_eeprom(0x19,RxD_Buff[27]);   //Auto acknowledge Time 
2FC6:  MOVLW  19
2FC8:  MOVWF  FA9
2FCA:  MOVFF  C2,FA8
2FCE:  BCF    FA6.6
2FD0:  BCF    FA6.7
2FD2:  BSF    FA6.2
2FD4:  MOVFF  FF2,00
2FD8:  BCF    FF2.7
2FDA:  MOVLW  55
2FDC:  MOVWF  FA7
2FDE:  MOVLW  AA
2FE0:  MOVWF  FA7
2FE2:  BSF    FA6.1
2FE4:  BTFSC  FA6.1
2FE6:  BRA    2FE4
2FE8:  BCF    FA6.2
2FEA:  MOVF   00,W
2FEC:  IORWF  FF2,F
....................             write_eeprom(0x1A,RxD_Buff[28]);   //Flashing Rate 
2FEE:  MOVLW  1A
2FF0:  MOVWF  FA9
2FF2:  MOVFF  C3,FA8
2FF6:  BCF    FA6.6
2FF8:  BCF    FA6.7
2FFA:  BSF    FA6.2
2FFC:  MOVFF  FF2,00
3000:  BCF    FF2.7
3002:  MOVLW  55
3004:  MOVWF  FA7
3006:  MOVLW  AA
3008:  MOVWF  FA7
300A:  BSF    FA6.1
300C:  BTFSC  FA6.1
300E:  BRA    300C
3010:  BCF    FA6.2
3012:  MOVF   00,W
3014:  IORWF  FF2,F
....................             write_eeprom(0x1B,RxD_Buff[29]);   //No of point 
3016:  MOVLW  1B
3018:  MOVWF  FA9
301A:  MOVFF  C4,FA8
301E:  BCF    FA6.6
3020:  BCF    FA6.7
3022:  BSF    FA6.2
3024:  MOVFF  FF2,00
3028:  BCF    FF2.7
302A:  MOVLW  55
302C:  MOVWF  FA7
302E:  MOVLW  AA
3030:  MOVWF  FA7
3032:  BSF    FA6.1
3034:  BTFSC  FA6.1
3036:  BRA    3034
3038:  BCF    FA6.2
303A:  MOVF   00,W
303C:  IORWF  FF2,F
....................             write_eeprom(0x1C,RxD_Buff[30]);   //FaultDelayTime 
303E:  MOVLW  1C
3040:  MOVWF  FA9
3042:  MOVFF  C5,FA8
3046:  BCF    FA6.6
3048:  BCF    FA6.7
304A:  BSF    FA6.2
304C:  MOVFF  FF2,00
3050:  BCF    FF2.7
3052:  MOVLW  55
3054:  MOVWF  FA7
3056:  MOVLW  AA
3058:  MOVWF  FA7
305A:  BSF    FA6.1
305C:  BTFSC  FA6.1
305E:  BRA    305C
3060:  BCF    FA6.2
3062:  MOVF   00,W
3064:  IORWF  FF2,F
....................             write_eeprom(0x1D,RxD_Buff[31]);   //Communication Address 
3066:  MOVLW  1D
3068:  MOVWF  FA9
306A:  MOVFF  C6,FA8
306E:  BCF    FA6.6
3070:  BCF    FA6.7
3072:  BSF    FA6.2
3074:  MOVFF  FF2,00
3078:  BCF    FF2.7
307A:  MOVLW  55
307C:  MOVWF  FA7
307E:  MOVLW  AA
3080:  MOVWF  FA7
3082:  BSF    FA6.1
3084:  BTFSC  FA6.1
3086:  BRA    3084
3088:  BCF    FA6.2
308A:  MOVF   00,W
308C:  IORWF  FF2,F
....................     
....................             write_eeprom(0x1E,RxD_Buff[32]);   //Communication Address 
308E:  MOVLW  1E
3090:  MOVWF  FA9
3092:  MOVFF  C7,FA8
3096:  BCF    FA6.6
3098:  BCF    FA6.7
309A:  BSF    FA6.2
309C:  MOVFF  FF2,00
30A0:  BCF    FF2.7
30A2:  MOVLW  55
30A4:  MOVWF  FA7
30A6:  MOVLW  AA
30A8:  MOVWF  FA7
30AA:  BSF    FA6.1
30AC:  BTFSC  FA6.1
30AE:  BRA    30AC
30B0:  BCF    FA6.2
30B2:  MOVF   00,W
30B4:  IORWF  FF2,F
....................             write_eeprom(0x1F,RxD_Buff[33]);   //Communication Address 
30B6:  MOVLW  1F
30B8:  MOVWF  FA9
30BA:  MOVFF  C8,FA8
30BE:  BCF    FA6.6
30C0:  BCF    FA6.7
30C2:  BSF    FA6.2
30C4:  MOVFF  FF2,00
30C8:  BCF    FF2.7
30CA:  MOVLW  55
30CC:  MOVWF  FA7
30CE:  MOVLW  AA
30D0:  MOVWF  FA7
30D2:  BSF    FA6.1
30D4:  BTFSC  FA6.1
30D6:  BRA    30D4
30D8:  BCF    FA6.2
30DA:  MOVF   00,W
30DC:  IORWF  FF2,F
....................             write_eeprom(0x20,RxD_Buff[34]);   //Communication Address 
30DE:  MOVLW  20
30E0:  MOVWF  FA9
30E2:  MOVFF  C9,FA8
30E6:  BCF    FA6.6
30E8:  BCF    FA6.7
30EA:  BSF    FA6.2
30EC:  MOVFF  FF2,00
30F0:  BCF    FF2.7
30F2:  MOVLW  55
30F4:  MOVWF  FA7
30F6:  MOVLW  AA
30F8:  MOVWF  FA7
30FA:  BSF    FA6.1
30FC:  BTFSC  FA6.1
30FE:  BRA    30FC
3100:  BCF    FA6.2
3102:  MOVF   00,W
3104:  IORWF  FF2,F
....................             write_eeprom(0x21,RxD_Buff[35]);   //Communication Address 
3106:  MOVLW  21
3108:  MOVWF  FA9
310A:  MOVFF  CA,FA8
310E:  BCF    FA6.6
3110:  BCF    FA6.7
3112:  BSF    FA6.2
3114:  MOVFF  FF2,00
3118:  BCF    FF2.7
311A:  MOVLW  55
311C:  MOVWF  FA7
311E:  MOVLW  AA
3120:  MOVWF  FA7
3122:  BSF    FA6.1
3124:  BTFSC  FA6.1
3126:  BRA    3124
3128:  BCF    FA6.2
312A:  MOVF   00,W
312C:  IORWF  FF2,F
....................             write_eeprom(0x22,RxD_Buff[36]);   //Communication Address 
312E:  MOVLW  22
3130:  MOVWF  FA9
3132:  MOVFF  CB,FA8
3136:  BCF    FA6.6
3138:  BCF    FA6.7
313A:  BSF    FA6.2
313C:  MOVFF  FF2,00
3140:  BCF    FF2.7
3142:  MOVLW  55
3144:  MOVWF  FA7
3146:  MOVLW  AA
3148:  MOVWF  FA7
314A:  BSF    FA6.1
314C:  BTFSC  FA6.1
314E:  BRA    314C
3150:  BCF    FA6.2
3152:  MOVF   00,W
3154:  IORWF  FF2,F
....................             write_eeprom(0x23,RxD_Buff[37]);   //Communication Address 
3156:  MOVLW  23
3158:  MOVWF  FA9
315A:  MOVFF  CC,FA8
315E:  BCF    FA6.6
3160:  BCF    FA6.7
3162:  BSF    FA6.2
3164:  MOVFF  FF2,00
3168:  BCF    FF2.7
316A:  MOVLW  55
316C:  MOVWF  FA7
316E:  MOVLW  AA
3170:  MOVWF  FA7
3172:  BSF    FA6.1
3174:  BTFSC  FA6.1
3176:  BRA    3174
3178:  BCF    FA6.2
317A:  MOVF   00,W
317C:  IORWF  FF2,F
....................             write_eeprom(0x24,RxD_Buff[38]);   //Communication Address 
317E:  MOVLW  24
3180:  MOVWF  FA9
3182:  MOVFF  CD,FA8
3186:  BCF    FA6.6
3188:  BCF    FA6.7
318A:  BSF    FA6.2
318C:  MOVFF  FF2,00
3190:  BCF    FF2.7
3192:  MOVLW  55
3194:  MOVWF  FA7
3196:  MOVLW  AA
3198:  MOVWF  FA7
319A:  BSF    FA6.1
319C:  BTFSC  FA6.1
319E:  BRA    319C
31A0:  BCF    FA6.2
31A2:  MOVF   00,W
31A4:  IORWF  FF2,F
....................             write_eeprom(0x25,RxD_Buff[39]);   //Communication Address 
31A6:  MOVLW  25
31A8:  MOVWF  FA9
31AA:  MOVFF  CE,FA8
31AE:  BCF    FA6.6
31B0:  BCF    FA6.7
31B2:  BSF    FA6.2
31B4:  MOVFF  FF2,00
31B8:  BCF    FF2.7
31BA:  MOVLW  55
31BC:  MOVWF  FA7
31BE:  MOVLW  AA
31C0:  MOVWF  FA7
31C2:  BSF    FA6.1
31C4:  BTFSC  FA6.1
31C6:  BRA    31C4
31C8:  BCF    FA6.2
31CA:  MOVF   00,W
31CC:  IORWF  FF2,F
....................             write_eeprom(0x26,RxD_Buff[40]);   //Communication Address 
31CE:  MOVLW  26
31D0:  MOVWF  FA9
31D2:  MOVFF  CF,FA8
31D6:  BCF    FA6.6
31D8:  BCF    FA6.7
31DA:  BSF    FA6.2
31DC:  MOVFF  FF2,00
31E0:  BCF    FF2.7
31E2:  MOVLW  55
31E4:  MOVWF  FA7
31E6:  MOVLW  AA
31E8:  MOVWF  FA7
31EA:  BSF    FA6.1
31EC:  BTFSC  FA6.1
31EE:  BRA    31EC
31F0:  BCF    FA6.2
31F2:  MOVF   00,W
31F4:  IORWF  FF2,F
....................             write_eeprom(0x27,RxD_Buff[41]);   //Communication Address 
31F6:  MOVLW  27
31F8:  MOVWF  FA9
31FA:  MOVFF  D0,FA8
31FE:  BCF    FA6.6
3200:  BCF    FA6.7
3202:  BSF    FA6.2
3204:  MOVFF  FF2,00
3208:  BCF    FF2.7
320A:  MOVLW  55
320C:  MOVWF  FA7
320E:  MOVLW  AA
3210:  MOVWF  FA7
3212:  BSF    FA6.1
3214:  BTFSC  FA6.1
3216:  BRA    3214
3218:  BCF    FA6.2
321A:  MOVF   00,W
321C:  IORWF  FF2,F
....................             write_eeprom(0x28,RxD_Buff[42]);   //Communication Address 
321E:  MOVLW  28
3220:  MOVWF  FA9
3222:  MOVFF  D1,FA8
3226:  BCF    FA6.6
3228:  BCF    FA6.7
322A:  BSF    FA6.2
322C:  MOVFF  FF2,00
3230:  BCF    FF2.7
3232:  MOVLW  55
3234:  MOVWF  FA7
3236:  MOVLW  AA
3238:  MOVWF  FA7
323A:  BSF    FA6.1
323C:  BTFSC  FA6.1
323E:  BRA    323C
3240:  BCF    FA6.2
3242:  MOVF   00,W
3244:  IORWF  FF2,F
....................             write_eeprom(0x29,RxD_Buff[43]);   //Communication Address 
3246:  MOVLW  29
3248:  MOVWF  FA9
324A:  MOVFF  D2,FA8
324E:  BCF    FA6.6
3250:  BCF    FA6.7
3252:  BSF    FA6.2
3254:  MOVFF  FF2,00
3258:  BCF    FF2.7
325A:  MOVLW  55
325C:  MOVWF  FA7
325E:  MOVLW  AA
3260:  MOVWF  FA7
3262:  BSF    FA6.1
3264:  BTFSC  FA6.1
3266:  BRA    3264
3268:  BCF    FA6.2
326A:  MOVF   00,W
326C:  IORWF  FF2,F
....................             write_eeprom(0x2A,RxD_Buff[44]);   //Communication Address 
326E:  MOVLW  2A
3270:  MOVWF  FA9
3272:  MOVFF  D3,FA8
3276:  BCF    FA6.6
3278:  BCF    FA6.7
327A:  BSF    FA6.2
327C:  MOVFF  FF2,00
3280:  BCF    FF2.7
3282:  MOVLW  55
3284:  MOVWF  FA7
3286:  MOVLW  AA
3288:  MOVWF  FA7
328A:  BSF    FA6.1
328C:  BTFSC  FA6.1
328E:  BRA    328C
3290:  BCF    FA6.2
3292:  MOVF   00,W
3294:  IORWF  FF2,F
....................             write_eeprom(0x2B,RxD_Buff[45]);   //Communication Address 
3296:  MOVLW  2B
3298:  MOVWF  FA9
329A:  MOVFF  D4,FA8
329E:  BCF    FA6.6
32A0:  BCF    FA6.7
32A2:  BSF    FA6.2
32A4:  MOVFF  FF2,00
32A8:  BCF    FF2.7
32AA:  MOVLW  55
32AC:  MOVWF  FA7
32AE:  MOVLW  AA
32B0:  MOVWF  FA7
32B2:  BSF    FA6.1
32B4:  BTFSC  FA6.1
32B6:  BRA    32B4
32B8:  BCF    FA6.2
32BA:  MOVF   00,W
32BC:  IORWF  FF2,F
....................             write_eeprom(0x2C,RxD_Buff[46]);   //Communication Address 
32BE:  MOVLW  2C
32C0:  MOVWF  FA9
32C2:  MOVFF  D5,FA8
32C6:  BCF    FA6.6
32C8:  BCF    FA6.7
32CA:  BSF    FA6.2
32CC:  MOVFF  FF2,00
32D0:  BCF    FF2.7
32D2:  MOVLW  55
32D4:  MOVWF  FA7
32D6:  MOVLW  AA
32D8:  MOVWF  FA7
32DA:  BSF    FA6.1
32DC:  BTFSC  FA6.1
32DE:  BRA    32DC
32E0:  BCF    FA6.2
32E2:  MOVF   00,W
32E4:  IORWF  FF2,F
....................             write_eeprom(0x2D,RxD_Buff[47]);   //Communication Address 
32E6:  MOVLW  2D
32E8:  MOVWF  FA9
32EA:  MOVFF  D6,FA8
32EE:  BCF    FA6.6
32F0:  BCF    FA6.7
32F2:  BSF    FA6.2
32F4:  MOVFF  FF2,00
32F8:  BCF    FF2.7
32FA:  MOVLW  55
32FC:  MOVWF  FA7
32FE:  MOVLW  AA
3300:  MOVWF  FA7
3302:  BSF    FA6.1
3304:  BTFSC  FA6.1
3306:  BRA    3304
3308:  BCF    FA6.2
330A:  MOVF   00,W
330C:  IORWF  FF2,F
....................             write_eeprom(0x2E,RxD_Buff[48]);   //Communication Address 
330E:  MOVLW  2E
3310:  MOVWF  FA9
3312:  MOVFF  D7,FA8
3316:  BCF    FA6.6
3318:  BCF    FA6.7
331A:  BSF    FA6.2
331C:  MOVFF  FF2,00
3320:  BCF    FF2.7
3322:  MOVLW  55
3324:  MOVWF  FA7
3326:  MOVLW  AA
3328:  MOVWF  FA7
332A:  BSF    FA6.1
332C:  BTFSC  FA6.1
332E:  BRA    332C
3330:  BCF    FA6.2
3332:  MOVF   00,W
3334:  IORWF  FF2,F
....................             write_eeprom(0x2F,RxD_Buff[49]);   //Communication Address 
3336:  MOVLW  2F
3338:  MOVWF  FA9
333A:  MOVFF  D8,FA8
333E:  BCF    FA6.6
3340:  BCF    FA6.7
3342:  BSF    FA6.2
3344:  MOVFF  FF2,00
3348:  BCF    FF2.7
334A:  MOVLW  55
334C:  MOVWF  FA7
334E:  MOVLW  AA
3350:  MOVWF  FA7
3352:  BSF    FA6.1
3354:  BTFSC  FA6.1
3356:  BRA    3354
3358:  BCF    FA6.2
335A:  MOVF   00,W
335C:  IORWF  FF2,F
....................             write_eeprom(0x30,RxD_Buff[50]);   //Communication Address 
335E:  MOVLW  30
3360:  MOVWF  FA9
3362:  MOVFF  D9,FA8
3366:  BCF    FA6.6
3368:  BCF    FA6.7
336A:  BSF    FA6.2
336C:  MOVFF  FF2,00
3370:  BCF    FF2.7
3372:  MOVLW  55
3374:  MOVWF  FA7
3376:  MOVLW  AA
3378:  MOVWF  FA7
337A:  BSF    FA6.1
337C:  BTFSC  FA6.1
337E:  BRA    337C
3380:  BCF    FA6.2
3382:  MOVF   00,W
3384:  IORWF  FF2,F
....................             write_eeprom(0x31,RxD_Buff[51]);   //Communication Address 
3386:  MOVLW  31
3388:  MOVWF  FA9
338A:  MOVFF  DA,FA8
338E:  BCF    FA6.6
3390:  BCF    FA6.7
3392:  BSF    FA6.2
3394:  MOVFF  FF2,00
3398:  BCF    FF2.7
339A:  MOVLW  55
339C:  MOVWF  FA7
339E:  MOVLW  AA
33A0:  MOVWF  FA7
33A2:  BSF    FA6.1
33A4:  BTFSC  FA6.1
33A6:  BRA    33A4
33A8:  BCF    FA6.2
33AA:  MOVF   00,W
33AC:  IORWF  FF2,F
....................           
....................             TxD_Buff[0] = Address ;         //Address 
33AE:  MOVFF  69,6B
....................             TxD_Buff[1] = 0x21 ;            //return function code 
33B2:  MOVLW  21
33B4:  MOVWF  6C
....................     
....................             CRC(TxD_Buff,2)   ;            //Cal CRC 2 byte 
33B6:  MOVLB  1
33B8:  CLRF   xAD
33BA:  MOVLW  6B
33BC:  MOVWF  xAC
33BE:  MOVLW  02
33C0:  MOVWF  xAE
33C2:  MOVLB  0
33C4:  CALL   1A46
....................     
....................             TxD_Buff[2] = CRC_Hi ; 
33C8:  MOVFF  E4,6D
....................             TxD_Buff[3] = CRC_Lo ; 
33CC:  MOVFF  E3,6E
....................     
....................             output_bit(P485ctrl,1); 
33D0:  BSF    F8A.3
33D2:  BCF    F93.3
....................             delay_ms(10); 
33D4:  MOVLW  0A
33D6:  MOVLB  1
33D8:  MOVWF  xB3
33DA:  MOVLB  0
33DC:  CALL   05C4
....................     
....................             putc(Txd_Buff[0]); 
33E0:  MOVF   6B,W
33E2:  CALL   1AB4
....................             putc(Txd_Buff[1]); 
33E6:  MOVF   6C,W
33E8:  CALL   1AB4
....................             putc(Txd_Buff[2]); 
33EC:  MOVF   6D,W
33EE:  CALL   1AB4
....................             putc(Txd_Buff[3]); 
33F2:  MOVF   6E,W
33F4:  CALL   1AB4
....................     
....................             delay_ms(3); 
33F8:  MOVLW  03
33FA:  MOVLB  1
33FC:  MOVWF  xB3
33FE:  MOVLB  0
3400:  CALL   05C4
....................             output_bit(P485ctrl,0);            
3404:  BCF    F8A.3
3406:  BCF    F93.3
....................              
....................             reset_cpu(); 
3408:  RESET
....................             //Read_Config(); //jj 
....................          } 
....................           
....................          if(RxD_Buff[1] == 0x03)///////////// READ HOLDING REGGISTER ///////////////////// 
340A:  MOVF   xA8,W
340C:  SUBLW  03
340E:  BNZ   3498
....................          { 
....................             //Data_Buff[0] = Input9_16; //>> Start_Address ; 
....................             //Data_Buff[1] = Input1_8;// >> Start_Address ; 
....................             //Data_Buff[2] = Input25_32; 
....................             //Data_Buff[3] = Input17_24;// >> Start_Address ; 
....................             Data_Buff[0] = Input9_10;// dummy data 
3410:  MOVFF  48,EC
....................             Data_Buff[1] = Input1_8; 
3414:  MOVFF  47,ED
....................              
....................              
....................             TxD_Buff[0] = Address ;         //Address 
3418:  MOVFF  69,6B
....................             TxD_Buff[1] = 0x03 ;           //Function Code 
341C:  MOVLW  03
341E:  MOVWF  6C
....................             TxD_Buff[2] = 0x02 ;          //Byte Count 
3420:  MOVLW  02
3422:  MOVWF  6D
....................             TxD_Buff[3] = Data_Buff[0];   //first byte Data 
3424:  MOVFF  EC,6E
....................             TxD_Buff[4] = Data_Buff[1];   //first byte Data 
3428:  MOVFF  ED,6F
....................  
....................             CRC(TxD_Buff,5)   ;            //Cal CRC 5 Byte 
342C:  MOVLB  1
342E:  CLRF   xAD
3430:  MOVLW  6B
3432:  MOVWF  xAC
3434:  MOVLW  05
3436:  MOVWF  xAE
3438:  MOVLB  0
343A:  CALL   1A46
....................  
....................             TxD_Buff[5] = CRC_Hi ; 
343E:  MOVFF  E4,70
....................             TxD_Buff[6] = CRC_Lo ; 
3442:  MOVFF  E3,71
....................  
....................             //TxD_DataLen = 0x07 ; 
....................             //rs485_ctrl = 1; 
....................             //dmsec(4); 
....................             //send = 1; 
....................             //TI=1; 
....................             output_bit(P485ctrl,1); 
3446:  BSF    F8A.3
3448:  BCF    F93.3
....................             restart_wdt(); 
344A:  CLRWDT
....................             delay_ms(4); 
344C:  MOVLW  04
344E:  MOVLB  1
3450:  MOVWF  xB3
3452:  MOVLB  0
3454:  CALL   05C4
....................             restart_wdt(); 
3458:  CLRWDT
....................  
....................             putc(TxD_Buff[0]) ;               //Address 
345A:  MOVF   6B,W
345C:  CALL   1AB4
....................             putc(TxD_Buff[1]) ;               //Function Code 
3460:  MOVF   6C,W
3462:  CALL   1AB4
....................             putc(TxD_Buff[2]) ;               //Byte Count 
3466:  MOVF   6D,W
3468:  CALL   1AB4
....................             putc(TxD_Buff[3]) ; 
346C:  MOVF   6E,W
346E:  CALL   1AB4
....................             putc(TxD_Buff[4]) ; 
3472:  MOVF   6F,W
3474:  CALL   1AB4
....................             putc(TxD_Buff[5]) ; 
3478:  MOVF   70,W
347A:  CALL   1AB4
....................             putc(TxD_Buff[6]) ; 
347E:  MOVF   71,W
3480:  CALL   1AB4
....................             //putc(TxD_Buff[7]) ; 
....................             //putc(TxD_Buff[8]) ; 
....................             //putc(TxD_Buff[9]) ; 
....................  
....................             restart_wdt(); 
3484:  CLRWDT
....................             delay_ms(3); 
3486:  MOVLW  03
3488:  MOVLB  1
348A:  MOVWF  xB3
348C:  MOVLB  0
348E:  CALL   05C4
....................             restart_wdt(); 
3492:  CLRWDT
....................             output_bit(P485ctrl,0); 
3494:  BCF    F8A.3
3496:  BCF    F93.3
....................          /* 
....................             //Do Read Holding Register 
....................             Start_Address = RxD_Buff[2] ; 
....................             Start_Address = (Start_Address << 8) | RxD_Buff[3] ;   //Start Address 16 bit 
....................             No_PointCount = RxD_Buff[4] ; 
....................             No_PointCount = (No_PointCount << 8) | RxD_Buff[5] ;      //No. of Point 16 bit 
....................  
....................             if(Start_Address < 0x02 && (Start_Address + No_PointCount) <= 0x03)  //Valid point 0-1 
....................             { 
....................                if(No_PointCount == 1) Data_ByteCount = 0x01 ;         // 1 point 
....................                else if(No_PointCount == 2) Data_ByteCount = 0x02 ;    // 2 point 
....................  
....................                if(Data_ByteCount == 0x01) 
....................                { 
....................                   if(Start_Address == 0x00) 
....................                   { 
....................                       TxD_Buff[0] = Address ;         //Address 
....................                   TxD_Buff[1] = 0x03 ;         //Function Code 
....................                   TxD_Buff[2] = Data_ByteCount ;   //Byte Count 
....................                   TxD_Buff[3] = Data_Buff[0] ;      //first byte Data 
....................                   TxD_Buff[4] = Data_Buff[1] ;      //second byte Data 
....................                   TxD_Buff[5] = Data_Buff[2] ;   
....................  
....................                   CRC(TxD_Buff,6)   ;            //Cal CRC 5 Byte 
....................  
....................                   TxD_Buff[6] = CRC_Hi ; 
....................                   TxD_Buff[7] = CRC_Lo ; 
....................  
....................                   //TxD_DataLen = 0x07 ; 
....................                   //rs485_ctrl = 1; 
....................                   //dmsec(4); 
....................                   //send = 1; 
....................                   //TI=1; 
....................                   output_bit(P485ctrl,1); 
....................                   restart_wdt(); 
....................                   delay_ms(4); 
....................                   restart_wdt(); 
....................  
....................                   putc(TxD_Buff[0]) ;               //Address 
....................                   putc(TxD_Buff[1]) ;               //Function Code 
....................                   putc(TxD_Buff[2]) ;               //Byte Count 
....................                   putc(TxD_Buff[3]) ; 
....................                   putc(TxD_Buff[4]) ; 
....................                   putc(TxD_Buff[5]) ; 
....................                   putc(TxD_Buff[6]) ; 
....................                   putc(TxD_Buff[7]) ; 
....................                   //putc(TxD_Buff[8]) ; 
....................                   //putc(TxD_Buff[9]) ; 
....................  
....................                   restart_wdt(); 
....................                   delay_ms(3); 
....................                   restart_wdt(); 
....................                   output_bit(P485ctrl,0); 
....................                   } 
....................                   else if(Start_Address == 0x01) 
....................                   { 
....................                       TxD_Buff[0] = Address ;         //Address 
....................                   TxD_Buff[1] = 0x01 ;         //Function Code 
....................                   TxD_Buff[2] = Data_ByteCount ;   //Byte Count 
....................                   TxD_Buff[3] = Data_Buff[0] ;      //first byte Data 
....................                   TxD_Buff[4] = Data_Buff[1] ;      //second byte Data 
....................                   TxD_Buff[5] = Data_Buff[2] ;   
....................  
....................                   CRC(TxD_Buff,6)   ;            //Cal CRC 5 Byte 
....................  
....................                   TxD_Buff[6] = CRC_Hi ; 
....................                   TxD_Buff[7] = CRC_Lo ; 
....................  
....................                   //TxD_DataLen = 0x07 ; 
....................                   //rs485_ctrl = 1; 
....................                   //dmsec(4); 
....................                   //send = 1; 
....................                   //TI=1; 
....................                   output_bit(P485ctrl,1); 
....................                   restart_wdt(); 
....................                   delay_ms(4); 
....................                   restart_wdt(); 
....................  
....................                   putc(TxD_Buff[0]) ;               //Address 
....................                   putc(TxD_Buff[1]) ;               //Function Code 
....................                   putc(TxD_Buff[2]) ;               //Byte Count 
....................                   putc(TxD_Buff[3]) ; 
....................                   putc(TxD_Buff[4]) ; 
....................                   putc(TxD_Buff[5]) ; 
....................                   putc(TxD_Buff[6]) ; 
....................                   putc(TxD_Buff[7]) ; 
....................                   //putc(TxD_Buff[8]) ; 
....................                   //putc(TxD_Buff[9]) ; 
....................  
....................                   restart_wdt(); 
....................                   delay_ms(3); 
....................                   restart_wdt(); 
....................                   output_bit(P485ctrl,0); 
....................                   } 
....................                } 
....................                else if(Data_ByteCount == 0x02) 
....................                { 
....................                   if(Start_Address == 0x00) 
....................                   { 
....................                       TxD_Buff[0] = Address ;         //Address 
....................                   TxD_Buff[1] = 0x03 ;         //Function Code 
....................                   TxD_Buff[2] = Data_ByteCount ;   //Byte Count 
....................                   TxD_Buff[3] = Data_Buff[0] ;      //first byte Data 
....................                   TxD_Buff[4] = Data_Buff[1] ;      //second byte Data 
....................                   TxD_Buff[5] = Data_Buff[2] ;   
....................  
....................                   CRC(TxD_Buff,6)   ;            //Cal CRC 5 Byte 
....................  
....................                   TxD_Buff[6] = CRC_Hi ; 
....................                   TxD_Buff[7] = CRC_Lo ; 
....................  
....................                   //TxD_DataLen = 0x07 ; 
....................                   //rs485_ctrl = 1; 
....................                   //dmsec(4); 
....................                   //send = 1; 
....................                   //TI=1; 
....................                   output_bit(P485ctrl,1); 
....................                   restart_wdt(); 
....................                   delay_ms(4); 
....................                   restart_wdt(); 
....................  
....................                   putc(TxD_Buff[0]) ;               //Address 
....................                   putc(TxD_Buff[1]) ;               //Function Code 
....................                   putc(TxD_Buff[2]) ;               //Byte Count 
....................                   putc(TxD_Buff[3]) ; 
....................                   putc(TxD_Buff[4]) ; 
....................                   putc(TxD_Buff[5]) ; 
....................                   putc(TxD_Buff[6]) ; 
....................                   putc(TxD_Buff[7]) ; 
....................                   //putc(TxD_Buff[8]) ; 
....................                   //putc(TxD_Buff[9]) ; 
....................  
....................                   restart_wdt(); 
....................                   delay_ms(3); 
....................                   restart_wdt(); 
....................                   output_bit(P485ctrl,0); 
....................                   } 
....................                } 
....................             } 
....................             else 
....................             { 
....................                //invalid parameter 
....................                TxD_Buff[0] = Address ;         //Address 
....................                TxD_Buff[1] = 0x81 ;         //Function Code 
....................                TxD_Buff[2] = 0x02 ;         //illegal data address 
....................  
....................                CRC(TxD_Buff,3)   ;            //Cal CRC 3 Byte 
....................  
....................                TxD_Buff[3] = CRC_Hi ; 
....................                TxD_Buff[4] = CRC_Lo ; 
....................  
....................                output_bit(P485ctrl,1); 
....................                delay_ms(10); 
....................  
....................                putc(Txd_Buff[0]); 
....................                putc(Txd_Buff[1]); 
....................                putc(Txd_Buff[2]); 
....................                putc(Txd_Buff[3]); 
....................                putc(Txd_Buff[4]); 
....................  
....................                delay_ms(3); 
....................                output_bit(P485ctrl,0); 
....................             } 
....................             */ 
....................          } 
....................         
....................  
....................   
....................         
....................        /*-----JACK Comment 18/6/58----------// 
....................          else 
....................          { 
....................             //Invalid function 
....................             TxD_Buff[0] = Address ;         //Address 
....................             TxD_Buff[1] = 0x81 ;         //Function Code 
....................             TxD_Buff[2] = 0x01 ;         //illegal function 
....................  
....................             CRC(TxD_Buff,3)   ;            //Cal CRC 3 Byte 
....................  
....................             TxD_Buff[3] = CRC_Hi ; 
....................             TxD_Buff[4] = CRC_Lo ; 
....................  
....................             output_bit(P485ctrl,1); 
....................             delay_ms(10); 
....................  
....................             putc(Txd_Buff[0]); 
....................             putc(Txd_Buff[1]); 
....................             putc(Txd_Buff[2]); 
....................             putc(Txd_Buff[3]); 
....................             putc(Txd_Buff[4]); 
....................  
....................             delay_ms(3); 
....................             output_bit(P485ctrl,0); 
....................          } 
....................        *///-----JACK Comment----------// 
....................       }   
....................  
....................       Send_check_Time = 500; //5 Second 
3498:  MOVLW  01
349A:  MOVWF  xE6
349C:  MOVLW  F4
349E:  MOVWF  xE5
....................    } 
....................  
....................    recieve_completed = 0 ; 
34A0:  BCF    2D.4
....................    sequence = end_sq ; 
34A2:  MOVFF  60,68
....................    T_timeout = 0x00; 
34A6:  MOVLB  1
34A8:  CLRF   x07
....................    RxD_DataLen = 0x00 ; 
34AA:  CLRF   6A
....................    output_bit(P485ctrl,0); 
34AC:  BCF    F8A.3
34AE:  BCF    F93.3
.................... } 
34B0:  MOVLB  0
34B2:  GOTO   4F72 (RETURN)
....................  
....................  
.................... //////////////////////////////////////////////////////////////////// 
....................  
.................... void Read_Input(void) 
.................... { 
....................  
....................     ///////////////////////--Edit--/////////////////// 
....................        MCP23s17_Ip_dat = IO_INPUT_A(IO_DEVICE_0); 
*
0FF2:  MOVLB  1
0FF4:  CLRF   xAC
0FF6:  MOVLB  0
0FF8:  RCALL  0EE0
0FFA:  MOVFF  01,105
....................            
....................       if (AutoTestFlag)  // TEST FROM MODBUS 
0FFE:  BTFSS  17.4
1000:  BRA    1006
....................       { 
....................          MCP23s17_Ip_dat = ~MCP23s17_Ip_dat;          
1002:  MOVLB  1
1004:  COMF   x05,F
....................       } 
....................        
....................       FaultNow[11] = MCP23s17_Ip_dat; 
1006:  MOVLB  1
1008:  BCF    x2B.3
100A:  BTFSC  x05.0
100C:  BSF    x2B.3
....................       FaultNow[12] = MCP23s17_Ip_dat >> 1; 
100E:  BCF    FD8.0
1010:  RRCF   x05,W
1012:  BCF    x2B.4
1014:  BTFSC  FE8.0
1016:  BSF    x2B.4
....................       FaultNow[13] = MCP23s17_Ip_dat >> 2; 
1018:  RRCF   x05,W
101A:  MOVWF  00
101C:  RRCF   00,F
101E:  MOVLW  3F
1020:  ANDWF  00,F
1022:  BCF    x2B.5
1024:  BTFSC  00.0
1026:  BSF    x2B.5
....................       FaultNow[14] = MCP23s17_Ip_dat >> 3; 
1028:  RRCF   x05,W
102A:  MOVWF  00
102C:  RRCF   00,F
102E:  RRCF   00,F
1030:  MOVLW  1F
1032:  ANDWF  00,F
1034:  BCF    x2B.6
1036:  BTFSC  00.0
1038:  BSF    x2B.6
....................       FaultNow[15] = MCP23s17_Ip_dat >> 4; 
103A:  SWAPF  x05,W
103C:  MOVWF  00
103E:  MOVLW  0F
1040:  ANDWF  00,F
1042:  BCF    x2B.7
1044:  BTFSC  00.0
1046:  BSF    x2B.7
....................       FaultNow[16] = MCP23s17_Ip_dat >> 5; 
1048:  SWAPF  x05,W
104A:  MOVWF  00
104C:  RRCF   00,F
104E:  MOVLW  07
1050:  ANDWF  00,F
1052:  BCF    x2C.0
1054:  BTFSC  00.0
1056:  BSF    x2C.0
....................       FaultNow[17] = MCP23s17_Ip_dat >> 6; 
1058:  SWAPF  x05,W
105A:  MOVWF  00
105C:  RRCF   00,F
105E:  RRCF   00,F
1060:  MOVLW  03
1062:  ANDWF  00,F
1064:  BCF    x2C.1
1066:  BTFSC  00.0
1068:  BSF    x2C.1
....................       FaultNow[18] = MCP23s17_Ip_dat >> 7; 
106A:  CLRF   00
106C:  BTFSC  x05.7
106E:  BSF    00.0
1070:  BCF    x2C.2
1072:  BTFSC  00.0
1074:  BSF    x2C.2
....................        
....................        MCP23s17_Ip_dat = IO_INPUT_B(IO_DEVICE_0); 
1076:  CLRF   xAC
1078:  MOVLB  0
107A:  RCALL  0EFC
107C:  MOVFF  01,105
....................        
....................       if (AutoTestFlag)  // TEST FROM MODBUS 
1080:  BTFSS  17.4
1082:  BRA    1088
....................       { 
....................          MCP23s17_Ip_dat = ~MCP23s17_Ip_dat; 
1084:  MOVLB  1
1086:  COMF   x05,F
....................       } 
....................        
....................       FaultNow[19] = MCP23s17_Ip_dat; 
1088:  MOVLB  1
108A:  BCF    x2C.3
108C:  BTFSC  x05.0
108E:  BSF    x2C.3
....................       FaultNow[20] = MCP23s17_Ip_dat >> 1; 
1090:  BCF    FD8.0
1092:  RRCF   x05,W
1094:  BCF    x2C.4
1096:  BTFSC  FE8.0
1098:  BSF    x2C.4
....................        
....................        
....................       MCP23s17_Ip_dat = IO_INPUT_A(IO_DEVICE_1); 
109A:  MOVLW  02
109C:  MOVWF  xAC
109E:  MOVLB  0
10A0:  RCALL  0EE0
10A2:  MOVFF  01,105
....................            
....................       if (AutoTestFlag)  // TEST FROM MODBUS 
10A6:  BTFSS  17.4
10A8:  BRA    10AE
....................       { 
....................          MCP23s17_Ip_dat = ~MCP23s17_Ip_dat; 
10AA:  MOVLB  1
10AC:  COMF   x05,F
....................           
....................       } 
....................        
....................       FaultNow[1] = MCP23s17_Ip_dat; 
10AE:  MOVLB  1
10B0:  BCF    x2A.1
10B2:  BTFSC  x05.0
10B4:  BSF    x2A.1
....................       FaultNow[2] = MCP23s17_Ip_dat >> 1; 
10B6:  BCF    FD8.0
10B8:  RRCF   x05,W
10BA:  BCF    x2A.2
10BC:  BTFSC  FE8.0
10BE:  BSF    x2A.2
....................       FaultNow[3] = MCP23s17_Ip_dat >> 2; 
10C0:  RRCF   x05,W
10C2:  MOVWF  00
10C4:  RRCF   00,F
10C6:  MOVLW  3F
10C8:  ANDWF  00,F
10CA:  BCF    x2A.3
10CC:  BTFSC  00.0
10CE:  BSF    x2A.3
....................       FaultNow[4] = MCP23s17_Ip_dat >> 3; 
10D0:  RRCF   x05,W
10D2:  MOVWF  00
10D4:  RRCF   00,F
10D6:  RRCF   00,F
10D8:  MOVLW  1F
10DA:  ANDWF  00,F
10DC:  BCF    x2A.4
10DE:  BTFSC  00.0
10E0:  BSF    x2A.4
....................       FaultNow[5] = MCP23s17_Ip_dat >> 4; 
10E2:  SWAPF  x05,W
10E4:  MOVWF  00
10E6:  MOVLW  0F
10E8:  ANDWF  00,F
10EA:  BCF    x2A.5
10EC:  BTFSC  00.0
10EE:  BSF    x2A.5
....................       FaultNow[6] = MCP23s17_Ip_dat >> 5; 
10F0:  SWAPF  x05,W
10F2:  MOVWF  00
10F4:  RRCF   00,F
10F6:  MOVLW  07
10F8:  ANDWF  00,F
10FA:  BCF    x2A.6
10FC:  BTFSC  00.0
10FE:  BSF    x2A.6
....................       FaultNow[7] = MCP23s17_Ip_dat >> 6; 
1100:  SWAPF  x05,W
1102:  MOVWF  00
1104:  RRCF   00,F
1106:  RRCF   00,F
1108:  MOVLW  03
110A:  ANDWF  00,F
110C:  BCF    x2A.7
110E:  BTFSC  00.0
1110:  BSF    x2A.7
....................       FaultNow[8] = MCP23s17_Ip_dat >> 7; 
1112:  CLRF   00
1114:  BTFSC  x05.7
1116:  BSF    00.0
1118:  BCF    x2B.0
111A:  BTFSC  00.0
111C:  BSF    x2B.0
....................        
....................       MCP23s17_Ip_dat = IO_INPUT_B(IO_DEVICE_1); 
111E:  MOVLW  02
1120:  MOVWF  xAC
1122:  MOVLB  0
1124:  RCALL  0EFC
1126:  MOVFF  01,105
....................        
....................       if (AutoTestFlag)  // TEST FROM MODBUS 
112A:  BTFSS  17.4
112C:  BRA    1132
....................       { 
....................          MCP23s17_Ip_dat = ~MCP23s17_Ip_dat; 
112E:  MOVLB  1
1130:  COMF   x05,F
....................       } 
....................        
....................       FaultNow[9] = MCP23s17_Ip_dat; 
1132:  MOVLB  1
1134:  BCF    x2B.1
1136:  BTFSC  x05.0
1138:  BSF    x2B.1
....................       FaultNow[10] = MCP23s17_Ip_dat >> 1; 
113A:  BCF    FD8.0
113C:  RRCF   x05,W
113E:  BCF    x2B.2
1140:  BTFSC  FE8.0
1142:  BSF    x2B.2
....................        
....................       ///////////////---Anal Fault---////////////////// 
....................       unsigned char i; 
....................       for( i=1; i<=10; i++) 
1144:  MOVLW  01
1146:  MOVWF  xAB
1148:  MOVF   xAB,W
114A:  SUBLW  0A
114C:  BTFSS  FD8.0
114E:  BRA    1668
....................       { 
....................          if(FaultNCNO[i] ==NO) 
1150:  MOVFF  1AB,1AD
1154:  MOVLW  01
1156:  MOVWF  xAF
1158:  MOVLW  A6
115A:  MOVWF  xAE
115C:  MOVLB  0
115E:  RCALL  0F18
1160:  MOVLW  00
1162:  BTFSC  01.0
1164:  MOVLW  01
1166:  ANDLW  01
1168:  SUBLW  01
116A:  BTFSS  FD8.2
116C:  BRA    13D8
....................          { 
....................              if(FaultNow[i]==0) 
116E:  MOVFF  1AB,1AD
1172:  MOVLW  01
1174:  MOVLB  1
1176:  MOVWF  xAF
1178:  MOVLW  2A
117A:  MOVWF  xAE
117C:  MOVLB  0
117E:  RCALL  0F18
1180:  MOVLW  00
1182:  BTFSC  01.0
1184:  MOVLW  01
1186:  ANDLW  01
1188:  BTFSS  FD8.2
118A:  BRA    12B2
....................              {    
....................                if(FaultAgo[i]==0) 
118C:  MOVFF  1AB,1AD
1190:  MOVLW  01
1192:  MOVLB  1
1194:  MOVWF  xAF
1196:  MOVLW  26
1198:  MOVWF  xAE
119A:  MOVLB  0
119C:  RCALL  0F18
119E:  MOVLW  00
11A0:  BTFSC  01.0
11A2:  MOVLW  01
11A4:  ANDLW  01
11A6:  BTFSS  FD8.2
11A8:  BRA    1296
....................                { 
....................                    ReleaseTime[i]++; 
11AA:  BCF    FD8.0
11AC:  MOVLB  1
11AE:  RLCF   xAB,W
11B0:  CLRF   03
11B2:  ADDLW  2E
11B4:  MOVWF  FE9
11B6:  MOVLW  01
11B8:  ADDWFC 03,W
11BA:  MOVWF  FEA
11BC:  MOVLW  01
11BE:  ADDWF  FEE,F
11C0:  BNC   11C4
11C2:  INCF   FEF,F
....................                    
....................                    if(ReleaseTime[i]>=((FaultDelayTime[i]*75)+15)) //time per loop are 368 microSec. (1.89*10=200ms) 
11C4:  BCF    FD8.0
11C6:  RLCF   xAB,W
11C8:  CLRF   03
11CA:  ADDLW  2E
11CC:  MOVWF  FE9
11CE:  MOVLW  01
11D0:  ADDWFC 03,W
11D2:  MOVWF  FEA
11D4:  MOVFF  FEC,1AD
11D8:  MOVF   FED,F
11DA:  MOVFF  FEF,1AC
11DE:  BCF    FD8.0
11E0:  RLCF   xAB,W
11E2:  CLRF   03
11E4:  ADDLW  6A
11E6:  MOVWF  FE9
11E8:  MOVLW  01
11EA:  ADDWFC 03,W
11EC:  MOVWF  FEA
11EE:  MOVFF  FEC,1AF
11F2:  MOVF   FED,F
11F4:  MOVFF  FEF,1AE
11F8:  MOVFF  1AF,1B1
11FC:  MOVFF  1AE,1B0
1200:  CLRF   xB3
1202:  MOVLW  4B
1204:  MOVWF  xB2
1206:  MOVLB  0
1208:  RCALL  0F4A
120A:  MOVFF  02,1AF
120E:  MOVFF  01,1AE
1212:  MOVLW  0F
1214:  MOVLB  1
1216:  ADDWF  01,W
1218:  MOVWF  01
121A:  MOVLW  00
121C:  ADDWFC 02,W
121E:  MOVWF  03
1220:  MOVF   03,W
1222:  SUBWF  xAD,W
1224:  BNC   1292
1226:  BNZ   122E
1228:  MOVF   01,W
122A:  SUBWF  xAC,W
122C:  BNC   1292
....................                    {    
....................                      ReleaseTime[i] = 0; 
122E:  BCF    FD8.0
1230:  RLCF   xAB,W
1232:  CLRF   03
1234:  ADDLW  2E
1236:  MOVWF  FE9
1238:  MOVLW  01
123A:  ADDWFC 03,W
123C:  MOVWF  FEA
123E:  CLRF   FEC
1240:  MOVF   FED,F
1242:  CLRF   FEF
....................                      switch(i) 
....................                      { 
1244:  MOVLW  01
1246:  SUBWF  xAB,W
1248:  ADDLW  F6
124A:  BC    1292
124C:  ADDLW  0A
124E:  MOVLB  0
1250:  GOTO   1706
....................                         case 1: 
....................                            Inputt.B1 = 0;  
1254:  MOVLB  1
1256:  BCF    x0A.0
....................                         break; 
1258:  BRA    1292
....................                         case 2: 
....................                            Inputt.B2 = 0;  
125A:  MOVLB  1
125C:  BCF    x0A.1
....................                         break; 
125E:  BRA    1292
....................                         case 3: 
....................                            Inputt.B3 = 0;  
1260:  MOVLB  1
1262:  BCF    x0A.2
....................                         break; 
1264:  BRA    1292
....................                         case 4: 
....................                            Inputt.B4 = 0;  
1266:  MOVLB  1
1268:  BCF    x0A.3
....................                         break; 
126A:  BRA    1292
....................                         case 5: 
....................                            Inputt.B5 = 0;  
126C:  MOVLB  1
126E:  BCF    x0A.4
....................                         break; 
1270:  BRA    1292
....................                         case 6: 
....................                            Inputt.B6 = 0;  
1272:  MOVLB  1
1274:  BCF    x0A.5
....................                         break; 
1276:  BRA    1292
....................                         case 7: 
....................                            Inputt.B7 = 0;  
1278:  MOVLB  1
127A:  BCF    x0A.6
....................                          break; 
127C:  BRA    1292
....................                          case 8: 
....................                            Inputt.B8 = 0;  
127E:  MOVLB  1
1280:  BCF    x0A.7
....................                         break; 
1282:  BRA    1292
....................                         case 9: 
....................                            Inputt.B9 = 0;  
1284:  MOVLB  1
1286:  BCF    x0B.0
....................                         break; 
1288:  BRA    1292
....................                         case 10: 
....................                            Inputt.B10 = 0;  
128A:  MOVLB  1
128C:  BCF    x0B.1
....................                         break; 
128E:  BRA    1292
1290:  MOVLB  1
....................                        /*  
....................                         case 11: 
....................                            Inputt.B11 = 0;  
....................                         break; 
....................                         case 12: 
....................                            Inputt.B12 = 0;  
....................                         break; 
....................                         case 13: 
....................                            Inputt.B13 = 0;  
....................                         break; 
....................                         case 14: 
....................                            Inputt.B14 = 0;  
....................                         break; 
....................                         case 15: 
....................                            Inputt.B15 = 0;  
....................                         break; 
....................                         case 16: 
....................                             Inputt.B16 = 0;  
....................                          break; 
....................                         */            
....................                      }                  
....................                    } 
....................                } 
....................                else 
1292:  BRA    12AE
1294:  MOVLB  0
....................                { 
....................                   ReleaseTime[i] = 0; 
1296:  BCF    FD8.0
1298:  MOVLB  1
129A:  RLCF   xAB,W
129C:  CLRF   03
129E:  ADDLW  2E
12A0:  MOVWF  FE9
12A2:  MOVLW  01
12A4:  ADDWFC 03,W
12A6:  MOVWF  FEA
12A8:  CLRF   FEC
12AA:  MOVF   FED,F
12AC:  CLRF   FEF
....................                } 
....................              } 
....................              else //if(FaultNow[i]==1 
12AE:  BRA    13D6
12B0:  MOVLB  0
....................              { 
....................                if(FaultAgo[i]==1) 
12B2:  MOVFF  1AB,1AD
12B6:  MOVLW  01
12B8:  MOVLB  1
12BA:  MOVWF  xAF
12BC:  MOVLW  26
12BE:  MOVWF  xAE
12C0:  MOVLB  0
12C2:  RCALL  0F18
12C4:  MOVLW  00
12C6:  BTFSC  01.0
12C8:  MOVLW  01
12CA:  ANDLW  01
12CC:  SUBLW  01
12CE:  BTFSS  FD8.2
12D0:  BRA    13BE
....................                { 
....................                    ReleaseTime[i]++; 
12D2:  BCF    FD8.0
12D4:  MOVLB  1
12D6:  RLCF   xAB,W
12D8:  CLRF   03
12DA:  ADDLW  2E
12DC:  MOVWF  FE9
12DE:  MOVLW  01
12E0:  ADDWFC 03,W
12E2:  MOVWF  FEA
12E4:  MOVLW  01
12E6:  ADDWF  FEE,F
12E8:  BNC   12EC
12EA:  INCF   FEF,F
....................                    
....................                    if(ReleaseTime[i]>=((FaultDelayTime[i]*75)+15)) //time per loop are 368 microSec. (1.89*10=200ms) 
12EC:  BCF    FD8.0
12EE:  RLCF   xAB,W
12F0:  CLRF   03
12F2:  ADDLW  2E
12F4:  MOVWF  FE9
12F6:  MOVLW  01
12F8:  ADDWFC 03,W
12FA:  MOVWF  FEA
12FC:  MOVFF  FEC,1AD
1300:  MOVF   FED,F
1302:  MOVFF  FEF,1AC
1306:  BCF    FD8.0
1308:  RLCF   xAB,W
130A:  CLRF   03
130C:  ADDLW  6A
130E:  MOVWF  FE9
1310:  MOVLW  01
1312:  ADDWFC 03,W
1314:  MOVWF  FEA
1316:  MOVFF  FEC,1AF
131A:  MOVF   FED,F
131C:  MOVFF  FEF,1AE
1320:  MOVFF  1AF,1B1
1324:  MOVFF  1AE,1B0
1328:  CLRF   xB3
132A:  MOVLW  4B
132C:  MOVWF  xB2
132E:  MOVLB  0
1330:  RCALL  0F4A
1332:  MOVFF  02,1AF
1336:  MOVFF  01,1AE
133A:  MOVLW  0F
133C:  MOVLB  1
133E:  ADDWF  01,W
1340:  MOVWF  01
1342:  MOVLW  00
1344:  ADDWFC 02,W
1346:  MOVWF  03
1348:  MOVF   03,W
134A:  SUBWF  xAD,W
134C:  BNC   13BA
134E:  BNZ   1356
1350:  MOVF   01,W
1352:  SUBWF  xAC,W
1354:  BNC   13BA
....................                    {    
....................                      ReleaseTime[i] = 1; 
1356:  BCF    FD8.0
1358:  RLCF   xAB,W
135A:  CLRF   03
135C:  ADDLW  2E
135E:  MOVWF  FE9
1360:  MOVLW  01
1362:  ADDWFC 03,W
1364:  MOVWF  FEA
1366:  CLRF   FEC
1368:  MOVF   FED,F
136A:  MOVLW  01
136C:  MOVWF  FEF
....................                      switch(i) 
....................                      { 
136E:  SUBWF  xAB,W
1370:  ADDLW  F6
1372:  BC    13BA
1374:  ADDLW  0A
1376:  MOVLB  0
1378:  GOTO   173E
....................                         case 1: 
....................                            Inputt.B1 = 1;  
137C:  MOVLB  1
137E:  BSF    x0A.0
....................                         break; 
1380:  BRA    13BA
....................                         case 2: 
....................                            Inputt.B2 = 1;  
1382:  MOVLB  1
1384:  BSF    x0A.1
....................                         break; 
1386:  BRA    13BA
....................                         case 3: 
....................                            Inputt.B3 = 1;  
1388:  MOVLB  1
138A:  BSF    x0A.2
....................                         break; 
138C:  BRA    13BA
....................                         case 4: 
....................                            Inputt.B4 = 1;  
138E:  MOVLB  1
1390:  BSF    x0A.3
....................                         break; 
1392:  BRA    13BA
....................                         case 5: 
....................                            Inputt.B5 = 1;  
1394:  MOVLB  1
1396:  BSF    x0A.4
....................                         break; 
1398:  BRA    13BA
....................                         case 6: 
....................                            Inputt.B6 = 1;  
139A:  MOVLB  1
139C:  BSF    x0A.5
....................                         break; 
139E:  BRA    13BA
....................                         case 7: 
....................                            Inputt.B7 = 1;  
13A0:  MOVLB  1
13A2:  BSF    x0A.6
....................                          break; 
13A4:  BRA    13BA
....................                          case 8: 
....................                            Inputt.B8 = 1;  
13A6:  MOVLB  1
13A8:  BSF    x0A.7
....................                         break; 
13AA:  BRA    13BA
....................                         case 9: 
....................                            Inputt.B9 = 1;  
13AC:  MOVLB  1
13AE:  BSF    x0B.0
....................                         break; 
13B0:  BRA    13BA
....................                         case 10: 
....................                            Inputt.B10 = 1;  
13B2:  MOVLB  1
13B4:  BSF    x0B.1
....................                         break; 
13B6:  BRA    13BA
13B8:  MOVLB  1
....................                         /* 
....................                         case 11: 
....................                            Inputt.B11 = 1;  
....................                         break; 
....................                         case 12: 
....................                            Inputt.B12 = 1;  
....................                         break; 
....................                         case 13: 
....................                            Inputt.B13 = 1;  
....................                         break; 
....................                         case 14: 
....................                            Inputt.B14 = 1;  
....................                         break; 
....................                         case 15: 
....................                            Inputt.B15 = 1;  
....................                         break; 
....................                         case 16: 
....................                             Inputt.B16 = 1; 
....................                          break; 
....................                          */           
....................                      }                  
....................                    } 
....................                } 
....................                else 
13BA:  BRA    13D6
13BC:  MOVLB  0
....................                { 
....................                   ReleaseTime[i] = 0; 
13BE:  BCF    FD8.0
13C0:  MOVLB  1
13C2:  RLCF   xAB,W
13C4:  CLRF   03
13C6:  ADDLW  2E
13C8:  MOVWF  FE9
13CA:  MOVLW  01
13CC:  ADDWFC 03,W
13CE:  MOVWF  FEA
13D0:  CLRF   FEC
13D2:  MOVF   FED,F
13D4:  CLRF   FEF
....................                } 
....................               
....................              /* 
....................                   ReleaseTime[i] = 0; 
....................                   switch(i) 
....................                   { 
....................                       case 1: 
....................                          Inputt.B1 = 1;  
....................                       break; 
....................                       case 2: 
....................                          Inputt.B2 = 1;  
....................                       break; 
....................                       case 3: 
....................                          Inputt.B3 = 1;  
....................                       break; 
....................                       case 4: 
....................                          Inputt.B4 = 1;  
....................                       break; 
....................                       case 5: 
....................                          Inputt.B5 = 1;  
....................                       break; 
....................                       case 6: 
....................                          Inputt.B6 = 1;  
....................                       break; 
....................                       case 7: 
....................                          Inputt.B7 = 1;  
....................                       break; 
....................                       case 8: 
....................                          Inputt.B8 = 1;  
....................                       break; 
....................                       case 9: 
....................                          Inputt.B9 = 1;  
....................                       break; 
....................                       case 10: 
....................                          Inputt.B10 = 1;  
....................                       break; 
....................                       case 11: 
....................                          Inputt.B11 = 1;  
....................                       break; 
....................                       case 12: 
....................                          Inputt.B12 = 1;  
....................                       break; 
....................                       case 13: 
....................                          Inputt.B13 = 1;  
....................                       break; 
....................                       case 14: 
....................                          Inputt.B14 = 1;  
....................                       break; 
....................                       case 15: 
....................                          Inputt.B15 = 1;  
....................                       break; 
....................                       case 16: 
....................                          Inputt.B16 = 1;  
....................                       break; 
....................                           
....................                   } 
....................                   */ 
....................              } 
....................           } 
....................           else if(FaultNCNO[i] ==NC) 
13D6:  BRA    1660
13D8:  MOVFF  1AB,1AD
13DC:  MOVLW  01
13DE:  MOVLB  1
13E0:  MOVWF  xAF
13E2:  MOVLW  A6
13E4:  MOVWF  xAE
13E6:  MOVLB  0
13E8:  RCALL  0F18
13EA:  MOVLW  00
13EC:  BTFSC  01.0
13EE:  MOVLW  01
13F0:  ANDLW  01
13F2:  BTFSS  FD8.2
13F4:  BRA    1662
....................           { 
....................              if(FaultNow[i]==1) 
13F6:  MOVFF  1AB,1AD
13FA:  MOVLW  01
13FC:  MOVLB  1
13FE:  MOVWF  xAF
1400:  MOVLW  2A
1402:  MOVWF  xAE
1404:  MOVLB  0
1406:  RCALL  0F18
1408:  MOVLW  00
140A:  BTFSC  01.0
140C:  MOVLW  01
140E:  ANDLW  01
1410:  SUBLW  01
1412:  BTFSS  FD8.2
1414:  BRA    153E
....................              { 
....................                if(FaultAgo[i]==1) 
1416:  MOVFF  1AB,1AD
141A:  MOVLW  01
141C:  MOVLB  1
141E:  MOVWF  xAF
1420:  MOVLW  26
1422:  MOVWF  xAE
1424:  MOVLB  0
1426:  RCALL  0F18
1428:  MOVLW  00
142A:  BTFSC  01.0
142C:  MOVLW  01
142E:  ANDLW  01
1430:  SUBLW  01
1432:  BTFSS  FD8.2
1434:  BRA    1522
....................                { 
....................                    ReleaseTime[i]++; 
1436:  BCF    FD8.0
1438:  MOVLB  1
143A:  RLCF   xAB,W
143C:  CLRF   03
143E:  ADDLW  2E
1440:  MOVWF  FE9
1442:  MOVLW  01
1444:  ADDWFC 03,W
1446:  MOVWF  FEA
1448:  MOVLW  01
144A:  ADDWF  FEE,F
144C:  BNC   1450
144E:  INCF   FEF,F
....................                    if(ReleaseTime[i]>=((FaultDelayTime[i]*75)+15)) //time per loop are 368 microSec. (1.89*10=200ms) 
1450:  BCF    FD8.0
1452:  RLCF   xAB,W
1454:  CLRF   03
1456:  ADDLW  2E
1458:  MOVWF  FE9
145A:  MOVLW  01
145C:  ADDWFC 03,W
145E:  MOVWF  FEA
1460:  MOVFF  FEC,1AD
1464:  MOVF   FED,F
1466:  MOVFF  FEF,1AC
146A:  BCF    FD8.0
146C:  RLCF   xAB,W
146E:  CLRF   03
1470:  ADDLW  6A
1472:  MOVWF  FE9
1474:  MOVLW  01
1476:  ADDWFC 03,W
1478:  MOVWF  FEA
147A:  MOVFF  FEC,1AF
147E:  MOVF   FED,F
1480:  MOVFF  FEF,1AE
1484:  MOVFF  1AF,1B1
1488:  MOVFF  1AE,1B0
148C:  CLRF   xB3
148E:  MOVLW  4B
1490:  MOVWF  xB2
1492:  MOVLB  0
1494:  RCALL  0F4A
1496:  MOVFF  02,1AF
149A:  MOVFF  01,1AE
149E:  MOVLW  0F
14A0:  MOVLB  1
14A2:  ADDWF  01,W
14A4:  MOVWF  01
14A6:  MOVLW  00
14A8:  ADDWFC 02,W
14AA:  MOVWF  03
14AC:  MOVF   03,W
14AE:  SUBWF  xAD,W
14B0:  BNC   151E
14B2:  BNZ   14BA
14B4:  MOVF   01,W
14B6:  SUBWF  xAC,W
14B8:  BNC   151E
....................                    {    
....................                      ReleaseTime[i] = 0; 
14BA:  BCF    FD8.0
14BC:  RLCF   xAB,W
14BE:  CLRF   03
14C0:  ADDLW  2E
14C2:  MOVWF  FE9
14C4:  MOVLW  01
14C6:  ADDWFC 03,W
14C8:  MOVWF  FEA
14CA:  CLRF   FEC
14CC:  MOVF   FED,F
14CE:  CLRF   FEF
....................                      switch(i) 
....................                      { 
14D0:  MOVLW  01
14D2:  SUBWF  xAB,W
14D4:  ADDLW  F6
14D6:  BC    151E
14D8:  ADDLW  0A
14DA:  MOVLB  0
14DC:  GOTO   1776
....................                         case 1: 
....................                            Inputt.B1 = 1;  
14E0:  MOVLB  1
14E2:  BSF    x0A.0
....................                         break; 
14E4:  BRA    151E
....................                         case 2: 
....................                            Inputt.B2 = 1;  
14E6:  MOVLB  1
14E8:  BSF    x0A.1
....................                         break; 
14EA:  BRA    151E
....................                         case 3: 
....................                            Inputt.B3 = 1;  
14EC:  MOVLB  1
14EE:  BSF    x0A.2
....................                         break; 
14F0:  BRA    151E
....................                         case 4: 
....................                            Inputt.B4 = 1;  
14F2:  MOVLB  1
14F4:  BSF    x0A.3
....................                         break; 
14F6:  BRA    151E
....................                         case 5: 
....................                            Inputt.B5 = 1;  
14F8:  MOVLB  1
14FA:  BSF    x0A.4
....................                         break; 
14FC:  BRA    151E
....................                         case 6: 
....................                            Inputt.B6 = 1;  
14FE:  MOVLB  1
1500:  BSF    x0A.5
....................                         break; 
1502:  BRA    151E
....................                         case 7: 
....................                            Inputt.B7 = 1;  
1504:  MOVLB  1
1506:  BSF    x0A.6
....................                          break; 
1508:  BRA    151E
....................                          case 8: 
....................                            Inputt.B8 = 1;  
150A:  MOVLB  1
150C:  BSF    x0A.7
....................                         break; 
150E:  BRA    151E
....................                         case 9: 
....................                            Inputt.B9 = 1;  
1510:  MOVLB  1
1512:  BSF    x0B.0
....................                         break; 
1514:  BRA    151E
....................                         case 10: 
....................                            Inputt.B10 = 1;  
1516:  MOVLB  1
1518:  BSF    x0B.1
....................                         break; 
151A:  BRA    151E
151C:  MOVLB  1
....................                         /* 
....................                         case 11: 
....................                            Inputt.B11 = 1;  
....................                         break; 
....................                         case 12: 
....................                            Inputt.B12 = 1;  
....................                         break; 
....................                         case 13: 
....................                            Inputt.B13 = 1;  
....................                         break; 
....................                         case 14: 
....................                            Inputt.B14 = 1;  
....................                         break; 
....................                         case 15: 
....................                            Inputt.B15 = 1;  
....................                         break; 
....................                         case 16: 
....................                             Inputt.B16 = 1;  
....................                          break; 
....................                          */                                           
....................                      }                  
....................                   } 
....................                } 
....................                else 
151E:  BRA    153A
1520:  MOVLB  0
....................                { 
....................                   ReleaseTime[i] = 0; 
1522:  BCF    FD8.0
1524:  MOVLB  1
1526:  RLCF   xAB,W
1528:  CLRF   03
152A:  ADDLW  2E
152C:  MOVWF  FE9
152E:  MOVLW  01
1530:  ADDWFC 03,W
1532:  MOVWF  FEA
1534:  CLRF   FEC
1536:  MOVF   FED,F
1538:  CLRF   FEF
....................                } 
....................              } 
....................              else //if(FaultNow[i]==0 
153A:  BRA    1660
153C:  MOVLB  0
....................              { 
....................                if(FaultAgo[i]==0) 
153E:  MOVFF  1AB,1AD
1542:  MOVLW  01
1544:  MOVLB  1
1546:  MOVWF  xAF
1548:  MOVLW  26
154A:  MOVWF  xAE
154C:  MOVLB  0
154E:  RCALL  0F18
1550:  MOVLW  00
1552:  BTFSC  01.0
1554:  MOVLW  01
1556:  ANDLW  01
1558:  BTFSS  FD8.2
155A:  BRA    1648
....................                { 
....................                    ReleaseTime[i]++; 
155C:  BCF    FD8.0
155E:  MOVLB  1
1560:  RLCF   xAB,W
1562:  CLRF   03
1564:  ADDLW  2E
1566:  MOVWF  FE9
1568:  MOVLW  01
156A:  ADDWFC 03,W
156C:  MOVWF  FEA
156E:  MOVLW  01
1570:  ADDWF  FEE,F
1572:  BNC   1576
1574:  INCF   FEF,F
....................                    
....................                    if(ReleaseTime[i]>=((FaultDelayTime[i]*75)+15)) //time per loop are 368 microSec. (1.89*10=200ms) 
1576:  BCF    FD8.0
1578:  RLCF   xAB,W
157A:  CLRF   03
157C:  ADDLW  2E
157E:  MOVWF  FE9
1580:  MOVLW  01
1582:  ADDWFC 03,W
1584:  MOVWF  FEA
1586:  MOVFF  FEC,1AD
158A:  MOVF   FED,F
158C:  MOVFF  FEF,1AC
1590:  BCF    FD8.0
1592:  RLCF   xAB,W
1594:  CLRF   03
1596:  ADDLW  6A
1598:  MOVWF  FE9
159A:  MOVLW  01
159C:  ADDWFC 03,W
159E:  MOVWF  FEA
15A0:  MOVFF  FEC,1AF
15A4:  MOVF   FED,F
15A6:  MOVFF  FEF,1AE
15AA:  MOVFF  1AF,1B1
15AE:  MOVFF  1AE,1B0
15B2:  CLRF   xB3
15B4:  MOVLW  4B
15B6:  MOVWF  xB2
15B8:  MOVLB  0
15BA:  RCALL  0F4A
15BC:  MOVFF  02,1AF
15C0:  MOVFF  01,1AE
15C4:  MOVLW  0F
15C6:  MOVLB  1
15C8:  ADDWF  01,W
15CA:  MOVWF  01
15CC:  MOVLW  00
15CE:  ADDWFC 02,W
15D0:  MOVWF  03
15D2:  MOVF   03,W
15D4:  SUBWF  xAD,W
15D6:  BNC   1644
15D8:  BNZ   15E0
15DA:  MOVF   01,W
15DC:  SUBWF  xAC,W
15DE:  BNC   1644
....................                    {    
....................                      ReleaseTime[i] = 0; 
15E0:  BCF    FD8.0
15E2:  RLCF   xAB,W
15E4:  CLRF   03
15E6:  ADDLW  2E
15E8:  MOVWF  FE9
15EA:  MOVLW  01
15EC:  ADDWFC 03,W
15EE:  MOVWF  FEA
15F0:  CLRF   FEC
15F2:  MOVF   FED,F
15F4:  CLRF   FEF
....................                      switch(i) 
....................                      { 
15F6:  MOVLW  01
15F8:  SUBWF  xAB,W
15FA:  ADDLW  F6
15FC:  BC    1644
15FE:  ADDLW  0A
1600:  MOVLB  0
1602:  GOTO   17AE
....................                         case 1: 
....................                            Inputt.B1 = 0;  
1606:  MOVLB  1
1608:  BCF    x0A.0
....................                         break; 
160A:  BRA    1644
....................                         case 2: 
....................                            Inputt.B2 = 0;  
160C:  MOVLB  1
160E:  BCF    x0A.1
....................                         break; 
1610:  BRA    1644
....................                         case 3: 
....................                            Inputt.B3 = 0;  
1612:  MOVLB  1
1614:  BCF    x0A.2
....................                         break; 
1616:  BRA    1644
....................                         case 4: 
....................                            Inputt.B4 = 0;  
1618:  MOVLB  1
161A:  BCF    x0A.3
....................                         break; 
161C:  BRA    1644
....................                         case 5: 
....................                            Inputt.B5 = 0;  
161E:  MOVLB  1
1620:  BCF    x0A.4
....................                         break; 
1622:  BRA    1644
....................                         case 6: 
....................                            Inputt.B6 = 0;  
1624:  MOVLB  1
1626:  BCF    x0A.5
....................                         break; 
1628:  BRA    1644
....................                         case 7: 
....................                            Inputt.B7 = 0;  
162A:  MOVLB  1
162C:  BCF    x0A.6
....................                          break; 
162E:  BRA    1644
....................                          case 8: 
....................                            Inputt.B8 = 0;  
1630:  MOVLB  1
1632:  BCF    x0A.7
....................                         break; 
1634:  BRA    1644
....................                         case 9: 
....................                            Inputt.B9 = 0;  
1636:  MOVLB  1
1638:  BCF    x0B.0
....................                         break; 
163A:  BRA    1644
....................                         case 10: 
....................                            Inputt.B10 = 0;  
163C:  MOVLB  1
163E:  BCF    x0B.1
....................                         break; 
1640:  BRA    1644
1642:  MOVLB  1
....................                         /* 
....................                         case 11: 
....................                            Inputt.B11 = 0;  
....................                         break; 
....................                         case 12: 
....................                            Inputt.B12 = 0;  
....................                         break; 
....................                         case 13: 
....................                            Inputt.B13 = 0;  
....................                         break; 
....................                         case 14: 
....................                            Inputt.B14 = 0;  
....................                         break; 
....................                         case 15: 
....................                            Inputt.B15 = 0;  
....................                         break; 
....................                         case 16: 
....................                             Inputt.B16 = 0; 
....................                          break; 
....................                         */            
....................                      }                  
....................                    } 
....................                } 
....................                else 
1644:  BRA    1660
1646:  MOVLB  0
....................                { 
....................                   ReleaseTime[i] = 0; 
1648:  BCF    FD8.0
164A:  MOVLB  1
164C:  RLCF   xAB,W
164E:  CLRF   03
1650:  ADDLW  2E
1652:  MOVWF  FE9
1654:  MOVLW  01
1656:  ADDWFC 03,W
1658:  MOVWF  FEA
165A:  CLRF   FEC
165C:  MOVF   FED,F
165E:  CLRF   FEF
1660:  MOVLB  0
....................                } 
....................                   /* 
....................                   ReleaseTime[i] = 0; 
....................                   switch(i) 
....................                   { 
....................                       case 1: 
....................                          Inputt.B1 = 0;  
....................                       break; 
....................                       case 2: 
....................                          Inputt.B2 = 0;  
....................                       break; 
....................                       case 3: 
....................                          Inputt.B3 = 0;  
....................                       break; 
....................                       case 4: 
....................                          Inputt.B4 = 0;  
....................                       break; 
....................                       case 5: 
....................                          Inputt.B5 = 0;  
....................                       break; 
....................                       case 6: 
....................                          Inputt.B6 = 0;  
....................                       break; 
....................                       case 7: 
....................                          Inputt.B7 = 0;  
....................                       break; 
....................                       case 8: 
....................                          Inputt.B8 = 0;  
....................                       break; 
....................                       case 9: 
....................                          Inputt.B9 = 0;  
....................                       break; 
....................                       case 10: 
....................                          Inputt.B10 = 0;  
....................                       break; 
....................                       case 11: 
....................                          Inputt.B11 = 0;  
....................                       break; 
....................                       case 12: 
....................                          Inputt.B12 = 0;  
....................                       break; 
....................                       case 13: 
....................                          Inputt.B13 = 0;  
....................                       break; 
....................                       case 14: 
....................                          Inputt.B14 = 0;  
....................                       break; 
....................                       case 15: 
....................                          Inputt.B15 = 0;  
....................                       break; 
....................                       case 16: 
....................                          Inputt.B16 = 0;  
....................                       break; 
....................                               
....................                   } 
....................                   */ 
....................              } 
....................           } 
....................       } 
1662:  MOVLB  1
1664:  INCF   xAB,F
1666:  BRA    1148
....................          
....................       StoreReleaseFault(); 
1668:  MOVLB  0
166A:  BRA    0FAE
....................        
....................       ///////////////---Anal Fault---////////////////// 
....................        
....................       ///////////////////////--Edit--/////////////////// 
....................       /*      
....................       Input11_18 = 0x00; 
....................       Input11_18 = Input11_18 | ~Inputt.B18; 
....................       Input11_18 = (Input11_18 << 1) | ~Inputt.B17; 
....................       Input11_18 = (Input11_18 << 1) | ~Inputt.B16; 
....................       Input11_18 = (Input11_18 << 1) | ~Inputt.B15; 
....................       Input11_18 = (Input11_18 << 1) | ~Inputt.B14; 
....................       Input11_18 = (Input11_18 << 1) | ~Inputt.B13; 
....................       Input11_18 = (Input11_18 << 1) | ~Inputt.B12; 
....................       Input11_18 = (Input11_18 << 1) | ~Inputt.B11; 
....................        
....................       
....................     
....................       Input19_20 = 0x00; 
....................       Input19_20 = Input19_20 | ~Inputt.B20; 
....................       Input19_20 = (Input19_20 << 1) | ~Inputt.B19; 
....................       */ 
....................    //} 
....................     
....................       Input1_8 = 0x00; 
166C:  CLRF   47
....................       Input1_8 = Input1_8 | ~Inputt.B8; 
166E:  MOVLW  00
1670:  MOVLB  1
1672:  BTFSS  x0A.7
1674:  MOVLW  01
1676:  IORWF  47,F
....................       Input1_8 = (Input1_8 << 1) | ~Inputt.B7; 
1678:  BCF    FD8.0
167A:  RLCF   47,W
167C:  MOVWF  xAC
167E:  MOVLW  00
1680:  BTFSS  x0A.6
1682:  MOVLW  01
1684:  IORWF  xAC,W
1686:  MOVWF  47
....................       Input1_8 = (Input1_8 << 1) | ~Inputt.B6; 
1688:  BCF    FD8.0
168A:  RLCF   47,W
168C:  MOVWF  xAC
168E:  MOVLW  00
1690:  BTFSS  x0A.5
1692:  MOVLW  01
1694:  IORWF  xAC,W
1696:  MOVWF  47
....................       Input1_8 = (Input1_8 << 1) | ~Inputt.B5; 
1698:  BCF    FD8.0
169A:  RLCF   47,W
169C:  MOVWF  xAC
169E:  MOVLW  00
16A0:  BTFSS  x0A.4
16A2:  MOVLW  01
16A4:  IORWF  xAC,W
16A6:  MOVWF  47
....................       Input1_8 = (Input1_8 << 1) | ~Inputt.B4; 
16A8:  BCF    FD8.0
16AA:  RLCF   47,W
16AC:  MOVWF  xAC
16AE:  MOVLW  00
16B0:  BTFSS  x0A.3
16B2:  MOVLW  01
16B4:  IORWF  xAC,W
16B6:  MOVWF  47
....................       Input1_8 = (Input1_8 << 1) | ~Inputt.B3; 
16B8:  BCF    FD8.0
16BA:  RLCF   47,W
16BC:  MOVWF  xAC
16BE:  MOVLW  00
16C0:  BTFSS  x0A.2
16C2:  MOVLW  01
16C4:  IORWF  xAC,W
16C6:  MOVWF  47
....................       Input1_8 = (Input1_8 << 1) | ~Inputt.B2; 
16C8:  BCF    FD8.0
16CA:  RLCF   47,W
16CC:  MOVWF  xAC
16CE:  MOVLW  00
16D0:  BTFSS  x0A.1
16D2:  MOVLW  01
16D4:  IORWF  xAC,W
16D6:  MOVWF  47
....................       Input1_8 = (Input1_8 << 1) | ~Inputt.B1; 
16D8:  BCF    FD8.0
16DA:  RLCF   47,W
16DC:  MOVWF  xAC
16DE:  MOVLW  00
16E0:  BTFSS  x0A.0
16E2:  MOVLW  01
16E4:  IORWF  xAC,W
16E6:  MOVWF  47
....................      
....................     
....................  
....................       Input9_10 = 0x00; 
16E8:  CLRF   48
....................       Input9_10 = Input9_10 | ~Inputt.B10; 
16EA:  MOVLW  00
16EC:  BTFSS  x0B.1
16EE:  MOVLW  01
16F0:  IORWF  48,F
....................       Input9_10 = (Input9_10 << 1) | ~Inputt.B9; 
16F2:  BCF    FD8.0
16F4:  RLCF   48,W
16F6:  MOVWF  xAC
16F8:  MOVLW  00
16FA:  BTFSS  x0B.0
16FC:  MOVLW  01
16FE:  IORWF  xAC,W
1700:  MOVWF  48
....................        
....................       //+++++++++++++++++++++++++++++++++++++++++++ 
....................    //} 
....................   
....................  
.................... /* 
....................  //////////////////////////////////////////////////////////////// 
....................  ////////////////////////////////////////////////////////////////// 
....................  /////////////////////////////////////////////////////////////////// 
....................  ////////////////////////////////////////////////////////////////////// 
....................  //////////////////////////////////////////////////////////////////////// 
....................    //if(NoOfPoint >= 10) 
....................    //{ 
....................       // if(NoOfPoint >= 20) 
....................    //{    
....................       MCP23s17_Ip_dat = IO_INPUT_A(IO_DEVICE_0); 
....................            
....................       if (AutoTestFlag)  // TEST FROM MODBUS 
....................       { 
....................          MCP23s17_Ip_dat = ~MCP23s17_Ip_dat;          
....................       } 
....................        
....................       Inputt.B11 = MCP23s17_Ip_dat; 
....................       Inputt.B12 = MCP23s17_Ip_dat >> 1; 
....................       Inputt.B13 = MCP23s17_Ip_dat >> 2; 
....................       Inputt.B14 = MCP23s17_Ip_dat >> 3; 
....................       Inputt.B15 = MCP23s17_Ip_dat >> 4; 
....................       Inputt.B16 = MCP23s17_Ip_dat >> 5; 
....................       Inputt.B17 = MCP23s17_Ip_dat >> 6; 
....................       Inputt.B18 = MCP23s17_Ip_dat >> 7; 
....................  
....................       Input11_18 = 0x00; 
....................       Input11_18 = Input1_8 | ~Inputt.B18; 
....................       Input11_18 = (Input1_8 << 1) | ~Inputt.B17; 
....................       Input11_18 = (Input1_8 << 1) | ~Inputt.B16; 
....................       Input11_18 = (Input1_8 << 1) | ~Inputt.B15; 
....................       Input11_18 = (Input1_8 << 1) | ~Inputt.B14; 
....................       Input11_18 = (Input1_8 << 1) | ~Inputt.B13; 
....................       Input11_18 = (Input1_8 << 1) | ~Inputt.B12; 
....................       Input11_18 = (Input1_8 << 1) | ~Inputt.B11; 
....................      
....................       MCP23s17_Ip_dat = IO_INPUT_B(IO_DEVICE_0); 
....................        
....................       if (AutoTestFlag)  // TEST FROM MODBUS 
....................       { 
....................          MCP23s17_Ip_dat = ~MCP23s17_Ip_dat; 
....................       } 
....................        
....................       Inputt.B19 = MCP23s17_Ip_dat; 
....................       Inputt.B20 = MCP23s17_Ip_dat >> 1; 
....................        
....................  
....................       Input19_20 = 0x00; 
....................       Input19_20 = Input9_10 | ~Inputt.B20; 
....................       Input19_20 = (Input9_10 << 1) | ~Inputt.B19; 
....................    //} 
....................     
....................       MCP23s17_Ip_dat = IO_INPUT_A(IO_DEVICE_1); 
....................            
....................       if (AutoTestFlag)  // TEST FROM MODBUS 
....................       { 
....................          MCP23s17_Ip_dat = ~MCP23s17_Ip_dat; 
....................           
....................       } 
....................        
....................       Inputt.B1 = MCP23s17_Ip_dat; 
....................       Inputt.B2 = MCP23s17_Ip_dat >> 1; 
....................       Inputt.B3 = MCP23s17_Ip_dat >> 2; 
....................       Inputt.B4 = MCP23s17_Ip_dat >> 3; 
....................       Inputt.B5 = MCP23s17_Ip_dat >> 4; 
....................       Inputt.B6 = MCP23s17_Ip_dat >> 5; 
....................       Inputt.B7 = MCP23s17_Ip_dat >> 6; 
....................       Inputt.B8 = MCP23s17_Ip_dat >> 7; 
....................  
....................       Input1_8 = 0x00; 
....................       Input1_8 = Input1_8 | ~Inputt.B8; 
....................       Input1_8 = (Input1_8 << 1) | ~Inputt.B7; 
....................       Input1_8 = (Input1_8 << 1) | ~Inputt.B6; 
....................       Input1_8 = (Input1_8 << 1) | ~Inputt.B5; 
....................       Input1_8 = (Input1_8 << 1) | ~Inputt.B4; 
....................       Input1_8 = (Input1_8 << 1) | ~Inputt.B3; 
....................       Input1_8 = (Input1_8 << 1) | ~Inputt.B2; 
....................       Input1_8 = (Input1_8 << 1) | ~Inputt.B1; 
....................      
....................       MCP23s17_Ip_dat = IO_INPUT_B(IO_DEVICE_1); 
....................        
....................       if (AutoTestFlag)  // TEST FROM MODBUS 
....................       { 
....................          MCP23s17_Ip_dat = ~MCP23s17_Ip_dat; 
....................       } 
....................        
....................       Inputt.B9 = MCP23s17_Ip_dat; 
....................       Inputt.B10 = MCP23s17_Ip_dat >> 1; 
....................        
....................  
....................       Input9_10 = 0x00; 
....................       Input9_10 = Input9_10 | ~Inputt.B10; 
....................       Input9_10 = (Input9_10 << 1) | ~Inputt.B9; 
....................       //+++++++++++++++++++++++++++++++++++++++++++ 
....................    //} 
....................     
.................... */   
.................... } 
1702:  MOVLB  0
1704:  RETLW  00
.................... /*----------------------------------------------------------------------------*/ 
....................  
....................  
.................... void Read_Config(void) 
.................... { 
....................     
....................  
....................    EEpDat = read_eeprom(0x01);   // Input type 1-8 
*
06E2:  MOVFF  FF2,1AB
06E6:  BCF    FF2.7
06E8:  MOVLW  01
06EA:  MOVWF  FA9
06EC:  BCF    FA6.6
06EE:  BCF    FA6.7
06F0:  BSF    FA6.0
06F2:  MOVF   FA8,W
06F4:  MOVLB  1
06F6:  BTFSC  xAB.7
06F8:  BSF    FF2.7
06FA:  MOVWF  37
....................    InputType1_8 = EEpDat; 
06FC:  MOVFF  37,38
....................  
....................    InputType.B1 = EEpDat; 
0700:  BCF    x0E.0
0702:  BTFSC  37.0
0704:  BSF    x0E.0
....................    InputType.B2 = EEpDat >> 1; 
0706:  BCF    FD8.0
0708:  RRCF   37,W
070A:  BCF    x0E.1
070C:  BTFSC  FE8.0
070E:  BSF    x0E.1
....................    InputType.B3 = EEpDat >> 2; 
0710:  RRCF   37,W
0712:  MOVWF  00
0714:  RRCF   00,F
0716:  MOVLW  3F
0718:  ANDWF  00,F
071A:  BCF    x0E.2
071C:  BTFSC  00.0
071E:  BSF    x0E.2
....................    InputType.B4 = EEpDat >> 3; 
0720:  RRCF   37,W
0722:  MOVWF  00
0724:  RRCF   00,F
0726:  RRCF   00,F
0728:  MOVLW  1F
072A:  ANDWF  00,F
072C:  BCF    x0E.3
072E:  BTFSC  00.0
0730:  BSF    x0E.3
....................    InputType.B5 = EEpDat >> 4; 
0732:  SWAPF  37,W
0734:  MOVWF  00
0736:  MOVLW  0F
0738:  ANDWF  00,F
073A:  BCF    x0E.4
073C:  BTFSC  00.0
073E:  BSF    x0E.4
....................    InputType.B6 = EEpDat >> 5; 
0740:  SWAPF  37,W
0742:  MOVWF  00
0744:  RRCF   00,F
0746:  MOVLW  07
0748:  ANDWF  00,F
074A:  BCF    x0E.5
074C:  BTFSC  00.0
074E:  BSF    x0E.5
....................    InputType.B7 = EEpDat >> 6; 
0750:  SWAPF  37,W
0752:  MOVWF  00
0754:  RRCF   00,F
0756:  RRCF   00,F
0758:  MOVLW  03
075A:  ANDWF  00,F
075C:  BCF    x0E.6
075E:  BTFSC  00.0
0760:  BSF    x0E.6
....................    InputType.B8 = EEpDat >> 7; 
0762:  CLRF   00
0764:  BTFSC  37.7
0766:  BSF    00.0
0768:  BCF    x0E.7
076A:  BTFSC  00.0
076C:  BSF    x0E.7
....................  
....................    EEpDat = read_eeprom(0x02);   // Input type 9-16 
076E:  MOVFF  FF2,1AB
0772:  BCF    FF2.7
0774:  MOVLW  02
0776:  MOVWF  FA9
0778:  BCF    FA6.6
077A:  BCF    FA6.7
077C:  BSF    FA6.0
077E:  MOVF   FA8,W
0780:  BTFSC  xAB.7
0782:  BSF    FF2.7
0784:  MOVWF  37
....................    InputType9_16 = EEpDat; 
0786:  MOVFF  37,39
....................  
....................    InputType.B9 = EEpDat; 
078A:  BCF    x0F.0
078C:  BTFSC  37.0
078E:  BSF    x0F.0
....................    InputType.B10 = EEpDat >> 1; 
0790:  BCF    FD8.0
0792:  RRCF   37,W
0794:  BCF    x0F.1
0796:  BTFSC  FE8.0
0798:  BSF    x0F.1
....................    /* 
....................    InputType.B11 = EEpDat >> 2; 
....................    InputType.B12 = EEpDat >> 3; 
....................    InputType.B13 = EEpDat >> 4; 
....................    InputType.B14 = EEpDat >> 5; 
....................    InputType.B15 = EEpDat >> 6; 
....................    InputType.B16 = EEpDat >> 7; 
....................     
....................    EEpDat = read_eeprom(0x03);   // Input type 9-16 
....................    InputType17_24 = EEpDat; 
....................  
....................    InputType.B17 = EEpDat; 
....................    InputType.B18 = EEpDat >> 1; 
....................    InputType.B19 = EEpDat >> 2; 
....................    InputType.B20 = EEpDat >> 3; 
....................    InputType.B21 = EEpDat >> 4; 
....................    InputType.B22 = EEpDat >> 5; 
....................    InputType.B23 = EEpDat >> 6; 
....................    InputType.B24 = EEpDat >> 7; 
....................    */ 
....................     
....................    FaultNCNO[1] = InputType.B1; 
079A:  BCF    xA6.1
079C:  BTFSC  x0E.0
079E:  BSF    xA6.1
....................    FaultNCNO[2] = InputType.B2; 
07A0:  BCF    xA6.2
07A2:  BTFSC  x0E.1
07A4:  BSF    xA6.2
....................    FaultNCNO[3] = InputType.B3; 
07A6:  BCF    xA6.3
07A8:  BTFSC  x0E.2
07AA:  BSF    xA6.3
....................    FaultNCNO[4] = InputType.B4; 
07AC:  BCF    xA6.4
07AE:  BTFSC  x0E.3
07B0:  BSF    xA6.4
....................    FaultNCNO[5] = InputType.B5; 
07B2:  BCF    xA6.5
07B4:  BTFSC  x0E.4
07B6:  BSF    xA6.5
....................    FaultNCNO[6] = InputType.B6; 
07B8:  BCF    xA6.6
07BA:  BTFSC  x0E.5
07BC:  BSF    xA6.6
....................    FaultNCNO[7] = InputType.B7; 
07BE:  BCF    xA6.7
07C0:  BTFSC  x0E.6
07C2:  BSF    xA6.7
....................    FaultNCNO[8] = InputType.B8; 
07C4:  BCF    xA7.0
07C6:  BTFSC  x0E.7
07C8:  BSF    xA7.0
....................    FaultNCNO[9] = InputType.B9; 
07CA:  BCF    xA7.1
07CC:  BTFSC  x0F.0
07CE:  BSF    xA7.1
....................    FaultNCNO[10] = InputType.B10; 
07D0:  BCF    xA7.2
07D2:  BTFSC  x0F.1
07D4:  BSF    xA7.2
....................  
....................    //////////////////////////////////////// 
....................  
....................    EEpDat = read_eeprom(0x04);   // Fault type 1-8 
07D6:  MOVFF  FF2,1AB
07DA:  BCF    FF2.7
07DC:  MOVLW  04
07DE:  MOVWF  FA9
07E0:  BCF    FA6.6
07E2:  BCF    FA6.7
07E4:  BSF    FA6.0
07E6:  MOVF   FA8,W
07E8:  BTFSC  xAB.7
07EA:  BSF    FF2.7
07EC:  MOVWF  37
....................    FaultType1_8 = EEpDat; 
07EE:  MOVFF  37,3B
....................  
....................    FaultType.B1 = EEpDat; 
07F2:  BCF    x10.0
07F4:  BTFSC  37.0
07F6:  BSF    x10.0
....................    FaultType.B2 = EEpDat >> 1; 
07F8:  BCF    FD8.0
07FA:  RRCF   37,W
07FC:  BCF    x10.1
07FE:  BTFSC  FE8.0
0800:  BSF    x10.1
....................    FaultType.B3 = EEpDat >> 2; 
0802:  RRCF   37,W
0804:  MOVWF  00
0806:  RRCF   00,F
0808:  MOVLW  3F
080A:  ANDWF  00,F
080C:  BCF    x10.2
080E:  BTFSC  00.0
0810:  BSF    x10.2
....................    FaultType.B4 = EEpDat >> 3; 
0812:  RRCF   37,W
0814:  MOVWF  00
0816:  RRCF   00,F
0818:  RRCF   00,F
081A:  MOVLW  1F
081C:  ANDWF  00,F
081E:  BCF    x10.3
0820:  BTFSC  00.0
0822:  BSF    x10.3
....................    FaultType.B5 = EEpDat >> 4; 
0824:  SWAPF  37,W
0826:  MOVWF  00
0828:  MOVLW  0F
082A:  ANDWF  00,F
082C:  BCF    x10.4
082E:  BTFSC  00.0
0830:  BSF    x10.4
....................    FaultType.B6 = EEpDat >> 5; 
0832:  SWAPF  37,W
0834:  MOVWF  00
0836:  RRCF   00,F
0838:  MOVLW  07
083A:  ANDWF  00,F
083C:  BCF    x10.5
083E:  BTFSC  00.0
0840:  BSF    x10.5
....................    FaultType.B7 = EEpDat >> 6; 
0842:  SWAPF  37,W
0844:  MOVWF  00
0846:  RRCF   00,F
0848:  RRCF   00,F
084A:  MOVLW  03
084C:  ANDWF  00,F
084E:  BCF    x10.6
0850:  BTFSC  00.0
0852:  BSF    x10.6
....................    FaultType.B8 = EEpDat >> 7; 
0854:  CLRF   00
0856:  BTFSC  37.7
0858:  BSF    00.0
085A:  BCF    x10.7
085C:  BTFSC  00.0
085E:  BSF    x10.7
....................  
....................    EEpDat = read_eeprom(0x05);   // Fault type 9-16 
0860:  MOVFF  FF2,1AB
0864:  BCF    FF2.7
0866:  MOVLW  05
0868:  MOVWF  FA9
086A:  BCF    FA6.6
086C:  BCF    FA6.7
086E:  BSF    FA6.0
0870:  MOVF   FA8,W
0872:  BTFSC  xAB.7
0874:  BSF    FF2.7
0876:  MOVWF  37
....................    FaultType9_16 = EEpDat; 
0878:  MOVFF  37,3C
....................  
....................    FaultType.B9 = EEpDat; 
087C:  BCF    x11.0
087E:  BTFSC  37.0
0880:  BSF    x11.0
....................    FaultType.B10 = EEpDat >> 1; 
0882:  BCF    FD8.0
0884:  RRCF   37,W
0886:  BCF    x11.1
0888:  BTFSC  FE8.0
088A:  BSF    x11.1
....................    /* 
....................    FaultType.B11 = EEpDat >> 2; 
....................    FaultType.B12 = EEpDat >> 3; 
....................    FaultType.B13 = EEpDat >> 4; 
....................    FaultType.B14 = EEpDat >> 5; 
....................    FaultType.B15 = EEpDat >> 6; 
....................    FaultType.B16 = EEpDat >> 7; 
....................     
....................    EEpDat = read_eeprom(0x06);   // Fault type 9-16 
....................    FaultType17_24 = EEpDat; 
....................  
....................    FaultType.B17 = EEpDat; 
....................    FaultType.B18 = EEpDat >> 1; 
....................    FaultType.B19 = EEpDat >> 2; 
....................    FaultType.B20 = EEpDat >> 3; 
....................    FaultType.B21 = EEpDat >> 4; 
....................    FaultType.B22 = EEpDat >> 5; 
....................    FaultType.B23 = EEpDat >> 6; 
....................    FaultType.B24 = EEpDat >> 7; 
....................    */ 
....................  
....................    //////////////////////////////////////////////// 
....................  
....................    EEpDat = read_eeprom(0x07);   // Output type 1-8 
088C:  MOVFF  FF2,1AB
0890:  BCF    FF2.7
0892:  MOVLW  07
0894:  MOVWF  FA9
0896:  BCF    FA6.6
0898:  BCF    FA6.7
089A:  BSF    FA6.0
089C:  MOVF   FA8,W
089E:  BTFSC  xAB.7
08A0:  BSF    FF2.7
08A2:  MOVWF  37
....................    OutputType1_8 = EEpDat; 
08A4:  MOVFF  37,3E
....................  
....................    OutputType.B1 = EEpDat; 
08A8:  BCF    x12.0
08AA:  BTFSC  37.0
08AC:  BSF    x12.0
....................    OutputType.B2 = EEpDat >> 1; 
08AE:  BCF    FD8.0
08B0:  RRCF   37,W
08B2:  BCF    x12.1
08B4:  BTFSC  FE8.0
08B6:  BSF    x12.1
....................    OutputType.B3 = EEpDat >> 2; 
08B8:  RRCF   37,W
08BA:  MOVWF  00
08BC:  RRCF   00,F
08BE:  MOVLW  3F
08C0:  ANDWF  00,F
08C2:  BCF    x12.2
08C4:  BTFSC  00.0
08C6:  BSF    x12.2
....................    OutputType.B4 = EEpDat >> 3; 
08C8:  RRCF   37,W
08CA:  MOVWF  00
08CC:  RRCF   00,F
08CE:  RRCF   00,F
08D0:  MOVLW  1F
08D2:  ANDWF  00,F
08D4:  BCF    x12.3
08D6:  BTFSC  00.0
08D8:  BSF    x12.3
....................    OutputType.B5 = EEpDat >> 4; 
08DA:  SWAPF  37,W
08DC:  MOVWF  00
08DE:  MOVLW  0F
08E0:  ANDWF  00,F
08E2:  BCF    x12.4
08E4:  BTFSC  00.0
08E6:  BSF    x12.4
....................    OutputType.B6 = EEpDat >> 5; 
08E8:  SWAPF  37,W
08EA:  MOVWF  00
08EC:  RRCF   00,F
08EE:  MOVLW  07
08F0:  ANDWF  00,F
08F2:  BCF    x12.5
08F4:  BTFSC  00.0
08F6:  BSF    x12.5
....................    OutputType.B7 = EEpDat >> 6; 
08F8:  SWAPF  37,W
08FA:  MOVWF  00
08FC:  RRCF   00,F
08FE:  RRCF   00,F
0900:  MOVLW  03
0902:  ANDWF  00,F
0904:  BCF    x12.6
0906:  BTFSC  00.0
0908:  BSF    x12.6
....................    OutputType.B8 = EEpDat >> 7; 
090A:  CLRF   00
090C:  BTFSC  37.7
090E:  BSF    00.0
0910:  BCF    x12.7
0912:  BTFSC  00.0
0914:  BSF    x12.7
....................  
....................    EEpDat = read_eeprom(0x08);   // Output type 9-16 
0916:  MOVFF  FF2,1AB
091A:  BCF    FF2.7
091C:  MOVLW  08
091E:  MOVWF  FA9
0920:  BCF    FA6.6
0922:  BCF    FA6.7
0924:  BSF    FA6.0
0926:  MOVF   FA8,W
0928:  BTFSC  xAB.7
092A:  BSF    FF2.7
092C:  MOVWF  37
....................    OutputType9_16 = EEpDat; 
092E:  MOVFF  37,3F
....................  
....................    OutputType.B9 = EEpDat; 
0932:  BCF    x13.0
0934:  BTFSC  37.0
0936:  BSF    x13.0
....................    OutputType.B10 = EEpDat >> 1; 
0938:  BCF    FD8.0
093A:  RRCF   37,W
093C:  BCF    x13.1
093E:  BTFSC  FE8.0
0940:  BSF    x13.1
....................    /* 
....................    OutputType.B11 = EEpDat >> 2; 
....................    OutputType.B12 = EEpDat >> 3; 
....................    OutputType.B13 = EEpDat >> 4; 
....................    OutputType.B14 = EEpDat >> 5; 
....................    OutputType.B15 = EEpDat >> 6; 
....................    OutputType.B16 = EEpDat >> 7; 
....................     
....................    EEpDat = read_eeprom(0x09);   // Output type 9-16 
....................    OutputType17_24 = EEpDat; 
....................  
....................    OutputType.B17 = EEpDat; 
....................    OutputType.B18 = EEpDat >> 1; 
....................    OutputType.B19 = EEpDat >> 2; 
....................    OutputType.B20 = EEpDat >> 3; 
....................    OutputType.B21 = EEpDat >> 4; 
....................    OutputType.B22 = EEpDat >> 5; 
....................    OutputType.B23 = EEpDat >> 6; 
....................    OutputType.B24 = EEpDat >> 7; 
....................    */ 
....................  
....................    //////////////////////////////////////// 
....................  
....................    EEpDat = read_eeprom(0x0A);   // Output Both 1-8 
0942:  MOVFF  FF2,1AB
0946:  BCF    FF2.7
0948:  MOVLW  0A
094A:  MOVWF  FA9
094C:  BCF    FA6.6
094E:  BCF    FA6.7
0950:  BSF    FA6.0
0952:  MOVF   FA8,W
0954:  BTFSC  xAB.7
0956:  BSF    FF2.7
0958:  MOVWF  37
....................    OutputBoth1_8 = EEpDat; 
095A:  MOVFF  37,41
....................  
....................    OutputBoth.B1 = EEpDat; 
095E:  BCF    x14.0
0960:  BTFSC  37.0
0962:  BSF    x14.0
....................    OutputBoth.B2 = EEpDat >> 1; 
0964:  BCF    FD8.0
0966:  RRCF   37,W
0968:  BCF    x14.1
096A:  BTFSC  FE8.0
096C:  BSF    x14.1
....................    OutputBoth.B3 = EEpDat >> 2; 
096E:  RRCF   37,W
0970:  MOVWF  00
0972:  RRCF   00,F
0974:  MOVLW  3F
0976:  ANDWF  00,F
0978:  BCF    x14.2
097A:  BTFSC  00.0
097C:  BSF    x14.2
....................    OutputBoth.B4 = EEpDat >> 3; 
097E:  RRCF   37,W
0980:  MOVWF  00
0982:  RRCF   00,F
0984:  RRCF   00,F
0986:  MOVLW  1F
0988:  ANDWF  00,F
098A:  BCF    x14.3
098C:  BTFSC  00.0
098E:  BSF    x14.3
....................    OutputBoth.B5 = EEpDat >> 4; 
0990:  SWAPF  37,W
0992:  MOVWF  00
0994:  MOVLW  0F
0996:  ANDWF  00,F
0998:  BCF    x14.4
099A:  BTFSC  00.0
099C:  BSF    x14.4
....................    OutputBoth.B6 = EEpDat >> 5; 
099E:  SWAPF  37,W
09A0:  MOVWF  00
09A2:  RRCF   00,F
09A4:  MOVLW  07
09A6:  ANDWF  00,F
09A8:  BCF    x14.5
09AA:  BTFSC  00.0
09AC:  BSF    x14.5
....................    OutputBoth.B7 = EEpDat >> 6; 
09AE:  SWAPF  37,W
09B0:  MOVWF  00
09B2:  RRCF   00,F
09B4:  RRCF   00,F
09B6:  MOVLW  03
09B8:  ANDWF  00,F
09BA:  BCF    x14.6
09BC:  BTFSC  00.0
09BE:  BSF    x14.6
....................    OutputBoth.B8 = EEpDat >> 7; 
09C0:  CLRF   00
09C2:  BTFSC  37.7
09C4:  BSF    00.0
09C6:  BCF    x14.7
09C8:  BTFSC  00.0
09CA:  BSF    x14.7
....................  
....................    EEpDat = read_eeprom(0x0B);   // Output Both 9-16 
09CC:  MOVFF  FF2,1AB
09D0:  BCF    FF2.7
09D2:  MOVLW  0B
09D4:  MOVWF  FA9
09D6:  BCF    FA6.6
09D8:  BCF    FA6.7
09DA:  BSF    FA6.0
09DC:  MOVF   FA8,W
09DE:  BTFSC  xAB.7
09E0:  BSF    FF2.7
09E2:  MOVWF  37
....................    OutputBoth9_16 = EEpDat; 
09E4:  MOVFF  37,42
....................  
....................    OutputBoth.B9 = EEpDat; 
09E8:  BCF    x15.0
09EA:  BTFSC  37.0
09EC:  BSF    x15.0
....................    OutputBoth.B10 = EEpDat >> 1; 
09EE:  BCF    FD8.0
09F0:  RRCF   37,W
09F2:  BCF    x15.1
09F4:  BTFSC  FE8.0
09F6:  BSF    x15.1
....................    /* 
....................    OutputBoth.B11 = EEpDat >> 2; 
....................    OutputBoth.B12 = EEpDat >> 3; 
....................    OutputBoth.B13 = EEpDat >> 4; 
....................    OutputBoth.B14 = EEpDat >> 5; 
....................    OutputBoth.B15 = EEpDat >> 6; 
....................    OutputBoth.B16 = EEpDat >> 7; 
....................     
....................    EEpDat = read_eeprom(0x0C);   // Output Both 9-16 
....................    OutputBoth17_24 = EEpDat; 
....................  
....................    OutputBoth.B17 = EEpDat; 
....................    OutputBoth.B18 = EEpDat >> 1; 
....................    OutputBoth.B19 = EEpDat >> 2; 
....................    OutputBoth.B20 = EEpDat >> 3; 
....................    OutputBoth.B21 = EEpDat >> 4; 
....................    OutputBoth.B22 = EEpDat >> 5; 
....................    OutputBoth.B23 = EEpDat >> 6; 
....................    OutputBoth.B24 = EEpDat >> 7; 
....................    */ 
....................  
....................    ///////////////////////////////////////////////// 
....................  
....................    EEpDat = read_eeprom(0x0D);   // AlarmIndicator 1-8 
09F8:  MOVFF  FF2,1AB
09FC:  BCF    FF2.7
09FE:  MOVLW  0D
0A00:  MOVWF  FA9
0A02:  BCF    FA6.6
0A04:  BCF    FA6.7
0A06:  BSF    FA6.0
0A08:  MOVF   FA8,W
0A0A:  BTFSC  xAB.7
0A0C:  BSF    FF2.7
0A0E:  MOVWF  37
....................    Alarm_Indicator1_8 = EEpDat; 
0A10:  MOVFF  37,44
....................  
....................    AlarmIndicator.B1 = EEpDat; 
0A14:  BCF    x16.0
0A16:  BTFSC  37.0
0A18:  BSF    x16.0
....................    AlarmIndicator.B2 = EEpDat >> 1; 
0A1A:  BCF    FD8.0
0A1C:  RRCF   37,W
0A1E:  BCF    x16.1
0A20:  BTFSC  FE8.0
0A22:  BSF    x16.1
....................    AlarmIndicator.B3 = EEpDat >> 2; 
0A24:  RRCF   37,W
0A26:  MOVWF  00
0A28:  RRCF   00,F
0A2A:  MOVLW  3F
0A2C:  ANDWF  00,F
0A2E:  BCF    x16.2
0A30:  BTFSC  00.0
0A32:  BSF    x16.2
....................    AlarmIndicator.B4 = EEpDat >> 3; 
0A34:  RRCF   37,W
0A36:  MOVWF  00
0A38:  RRCF   00,F
0A3A:  RRCF   00,F
0A3C:  MOVLW  1F
0A3E:  ANDWF  00,F
0A40:  BCF    x16.3
0A42:  BTFSC  00.0
0A44:  BSF    x16.3
....................    AlarmIndicator.B5 = EEpDat >> 4; 
0A46:  SWAPF  37,W
0A48:  MOVWF  00
0A4A:  MOVLW  0F
0A4C:  ANDWF  00,F
0A4E:  BCF    x16.4
0A50:  BTFSC  00.0
0A52:  BSF    x16.4
....................    AlarmIndicator.B6 = EEpDat >> 5; 
0A54:  SWAPF  37,W
0A56:  MOVWF  00
0A58:  RRCF   00,F
0A5A:  MOVLW  07
0A5C:  ANDWF  00,F
0A5E:  BCF    x16.5
0A60:  BTFSC  00.0
0A62:  BSF    x16.5
....................    AlarmIndicator.B7 = EEpDat >> 6; 
0A64:  SWAPF  37,W
0A66:  MOVWF  00
0A68:  RRCF   00,F
0A6A:  RRCF   00,F
0A6C:  MOVLW  03
0A6E:  ANDWF  00,F
0A70:  BCF    x16.6
0A72:  BTFSC  00.0
0A74:  BSF    x16.6
....................    AlarmIndicator.B8 = EEpDat >> 7; 
0A76:  CLRF   00
0A78:  BTFSC  37.7
0A7A:  BSF    00.0
0A7C:  BCF    x16.7
0A7E:  BTFSC  00.0
0A80:  BSF    x16.7
....................  
....................    EEpDat = read_eeprom(0x0E);   // AlarmIndicator 9-16 
0A82:  MOVFF  FF2,1AB
0A86:  BCF    FF2.7
0A88:  MOVLW  0E
0A8A:  MOVWF  FA9
0A8C:  BCF    FA6.6
0A8E:  BCF    FA6.7
0A90:  BSF    FA6.0
0A92:  MOVF   FA8,W
0A94:  BTFSC  xAB.7
0A96:  BSF    FF2.7
0A98:  MOVWF  37
....................    Alarm_Indicator9_16 = EEpDat; 
0A9A:  MOVFF  37,45
....................  
....................    AlarmIndicator.B9 = EEpDat; 
0A9E:  BCF    x17.0
0AA0:  BTFSC  37.0
0AA2:  BSF    x17.0
....................    AlarmIndicator.B10 = EEpDat >> 1; 
0AA4:  BCF    FD8.0
0AA6:  RRCF   37,W
0AA8:  BCF    x17.1
0AAA:  BTFSC  FE8.0
0AAC:  BSF    x17.1
....................    /* 
....................    AlarmIndicator.B11 = EEpDat >> 2; 
....................    AlarmIndicator.B12 = EEpDat >> 3; 
....................    AlarmIndicator.B13 = EEpDat >> 4; 
....................    AlarmIndicator.B14 = EEpDat >> 5; 
....................    AlarmIndicator.B15 = EEpDat >> 6; 
....................    AlarmIndicator.B16 = EEpDat >> 7; 
....................     
....................    EEpDat = read_eeprom(0x0F);   // AlarmIndicator 9-16 
....................    Alarm_Indicator17_24 = EEpDat; 
....................  
....................    AlarmIndicator.B17 = EEpDat; 
....................    AlarmIndicator.B18 = EEpDat >> 1; 
....................    AlarmIndicator.B19 = EEpDat >> 2; 
....................    AlarmIndicator.B20 = EEpDat >> 3; 
....................    AlarmIndicator.B21 = EEpDat >> 4; 
....................    AlarmIndicator.B22 = EEpDat >> 5; 
....................    AlarmIndicator.B23 = EEpDat >> 6; 
....................    AlarmIndicator.B24 = EEpDat >> 7; 
....................    */ 
....................    ////////////////////////////////////////////////// 
....................    EEpDat = read_eeprom(0x10); 
0AAE:  MOVFF  FF2,1AB
0AB2:  BCF    FF2.7
0AB4:  MOVLW  10
0AB6:  MOVWF  FA9
0AB8:  BCF    FA6.6
0ABA:  BCF    FA6.7
0ABC:  BSF    FA6.0
0ABE:  MOVF   FA8,W
0AC0:  BTFSC  xAB.7
0AC2:  BSF    FF2.7
0AC4:  MOVWF  37
....................    //Red1_8 = EEpDat; 
....................    RED_Colour.B1 = EEpDat; 
0AC6:  BCF    x22.0
0AC8:  BTFSC  37.0
0ACA:  BSF    x22.0
....................    RED_Colour.B2 = EEpDat >> 1; 
0ACC:  BCF    FD8.0
0ACE:  RRCF   37,W
0AD0:  BCF    x22.1
0AD2:  BTFSC  FE8.0
0AD4:  BSF    x22.1
....................    RED_Colour.B3 = EEpDat >> 2; 
0AD6:  RRCF   37,W
0AD8:  MOVWF  00
0ADA:  RRCF   00,F
0ADC:  MOVLW  3F
0ADE:  ANDWF  00,F
0AE0:  BCF    x22.2
0AE2:  BTFSC  00.0
0AE4:  BSF    x22.2
....................    RED_Colour.B4 = EEpDat >> 3; 
0AE6:  RRCF   37,W
0AE8:  MOVWF  00
0AEA:  RRCF   00,F
0AEC:  RRCF   00,F
0AEE:  MOVLW  1F
0AF0:  ANDWF  00,F
0AF2:  BCF    x22.3
0AF4:  BTFSC  00.0
0AF6:  BSF    x22.3
....................    RED_Colour.B5 = EEpDat >> 4; 
0AF8:  SWAPF  37,W
0AFA:  MOVWF  00
0AFC:  MOVLW  0F
0AFE:  ANDWF  00,F
0B00:  BCF    x22.4
0B02:  BTFSC  00.0
0B04:  BSF    x22.4
....................    RED_Colour.B6 = EEpDat >> 5; 
0B06:  SWAPF  37,W
0B08:  MOVWF  00
0B0A:  RRCF   00,F
0B0C:  MOVLW  07
0B0E:  ANDWF  00,F
0B10:  BCF    x22.5
0B12:  BTFSC  00.0
0B14:  BSF    x22.5
....................    RED_Colour.B7 = EEpDat >> 6; 
0B16:  SWAPF  37,W
0B18:  MOVWF  00
0B1A:  RRCF   00,F
0B1C:  RRCF   00,F
0B1E:  MOVLW  03
0B20:  ANDWF  00,F
0B22:  BCF    x22.6
0B24:  BTFSC  00.0
0B26:  BSF    x22.6
....................    RED_Colour.B8 = EEpDat >> 7; 
0B28:  CLRF   00
0B2A:  BTFSC  37.7
0B2C:  BSF    00.0
0B2E:  BCF    x22.7
0B30:  BTFSC  00.0
0B32:  BSF    x22.7
....................     
....................    EEpDat = read_eeprom(0x11); 
0B34:  MOVFF  FF2,1AB
0B38:  BCF    FF2.7
0B3A:  MOVLW  11
0B3C:  MOVWF  FA9
0B3E:  BCF    FA6.6
0B40:  BCF    FA6.7
0B42:  BSF    FA6.0
0B44:  MOVF   FA8,W
0B46:  BTFSC  xAB.7
0B48:  BSF    FF2.7
0B4A:  MOVWF  37
....................    //Green9_10 = EEpDat; 
....................    RED_Colour.B9 = EEpDat; 
0B4C:  BCF    x23.0
0B4E:  BTFSC  37.0
0B50:  BSF    x23.0
....................    RED_Colour.B10 = EEpDat >> 1; 
0B52:  BCF    FD8.0
0B54:  RRCF   37,W
0B56:  BCF    x23.1
0B58:  BTFSC  FE8.0
0B5A:  BSF    x23.1
....................     
....................    /* 
....................    EEpDat = read_eeprom(0x12); 
....................    //Red11_18 = EEpDat; 
....................    RED_Colour.B11 = EEpDat; 
....................    RED_Colour.B12 = EEpDat >> 1; 
....................    RED_Colour.B13 = EEpDat >> 2; 
....................    RED_Colour.B14 = EEpDat >> 3; 
....................    RED_Colour.B15 = EEpDat >> 4; 
....................    RED_Colour.B16 = EEpDat >> 5; 
....................    RED_Colour.B17 = EEpDat >> 6; 
....................    RED_Colour.B18 = EEpDat >> 7; 
....................     
....................    EEpDat = read_eeprom(0x13); 
....................    //Red19_20 = EEpDat; 
....................    RED_Colour.B19 = EEpDat; 
....................    RED_Colour.B20 = EEpDat >> 1; 
....................    */ 
....................     
....................    EEpDat = read_eeprom(0x14); 
0B5C:  MOVFF  FF2,1AB
0B60:  BCF    FF2.7
0B62:  MOVLW  14
0B64:  MOVWF  FA9
0B66:  BCF    FA6.6
0B68:  BCF    FA6.7
0B6A:  BSF    FA6.0
0B6C:  MOVF   FA8,W
0B6E:  BTFSC  xAB.7
0B70:  BSF    FF2.7
0B72:  MOVWF  37
....................    //Green1_8 = EEpDat; 
....................    GREEN_Colour.B1 = EEpDat; 
0B74:  BCF    x24.0
0B76:  BTFSC  37.0
0B78:  BSF    x24.0
....................    GREEN_Colour.B2 = EEpDat >> 1; 
0B7A:  BCF    FD8.0
0B7C:  RRCF   37,W
0B7E:  BCF    x24.1
0B80:  BTFSC  FE8.0
0B82:  BSF    x24.1
....................    GREEN_Colour.B3 = EEpDat >> 2; 
0B84:  RRCF   37,W
0B86:  MOVWF  00
0B88:  RRCF   00,F
0B8A:  MOVLW  3F
0B8C:  ANDWF  00,F
0B8E:  BCF    x24.2
0B90:  BTFSC  00.0
0B92:  BSF    x24.2
....................    GREEN_Colour.B4 = EEpDat >> 3; 
0B94:  RRCF   37,W
0B96:  MOVWF  00
0B98:  RRCF   00,F
0B9A:  RRCF   00,F
0B9C:  MOVLW  1F
0B9E:  ANDWF  00,F
0BA0:  BCF    x24.3
0BA2:  BTFSC  00.0
0BA4:  BSF    x24.3
....................    GREEN_Colour.B5 = EEpDat >> 4; 
0BA6:  SWAPF  37,W
0BA8:  MOVWF  00
0BAA:  MOVLW  0F
0BAC:  ANDWF  00,F
0BAE:  BCF    x24.4
0BB0:  BTFSC  00.0
0BB2:  BSF    x24.4
....................    GREEN_Colour.B6 = EEpDat >> 5; 
0BB4:  SWAPF  37,W
0BB6:  MOVWF  00
0BB8:  RRCF   00,F
0BBA:  MOVLW  07
0BBC:  ANDWF  00,F
0BBE:  BCF    x24.5
0BC0:  BTFSC  00.0
0BC2:  BSF    x24.5
....................    GREEN_Colour.B7 = EEpDat >> 6; 
0BC4:  SWAPF  37,W
0BC6:  MOVWF  00
0BC8:  RRCF   00,F
0BCA:  RRCF   00,F
0BCC:  MOVLW  03
0BCE:  ANDWF  00,F
0BD0:  BCF    x24.6
0BD2:  BTFSC  00.0
0BD4:  BSF    x24.6
....................    GREEN_Colour.B8 = EEpDat >> 7; 
0BD6:  CLRF   00
0BD8:  BTFSC  37.7
0BDA:  BSF    00.0
0BDC:  BCF    x24.7
0BDE:  BTFSC  00.0
0BE0:  BSF    x24.7
....................     
....................    EEpDat = read_eeprom(0x15); 
0BE2:  MOVFF  FF2,1AB
0BE6:  BCF    FF2.7
0BE8:  MOVLW  15
0BEA:  MOVWF  FA9
0BEC:  BCF    FA6.6
0BEE:  BCF    FA6.7
0BF0:  BSF    FA6.0
0BF2:  MOVF   FA8,W
0BF4:  BTFSC  xAB.7
0BF6:  BSF    FF2.7
0BF8:  MOVWF  37
....................    //Green9_10 = EEpDat; 
....................    GREEN_Colour.B9 = EEpDat; 
0BFA:  BCF    x25.0
0BFC:  BTFSC  37.0
0BFE:  BSF    x25.0
....................    GREEN_Colour.B10 = EEpDat >> 1; 
0C00:  BCF    FD8.0
0C02:  RRCF   37,W
0C04:  BCF    x25.1
0C06:  BTFSC  FE8.0
0C08:  BSF    x25.1
....................     
....................    /* 
....................    EEpDat = read_eeprom(0x16); 
....................    //Green11_18 = EEpDat; 
....................    GREEN_Colour.B11 = EEpDat; 
....................    GREEN_Colour.B12 = EEpDat >> 1; 
....................    GREEN_Colour.B13 = EEpDat >> 2; 
....................    GREEN_Colour.B14 = EEpDat >> 3; 
....................    GREEN_Colour.B15 = EEpDat >> 4; 
....................    GREEN_Colour.B16 = EEpDat >> 5; 
....................    GREEN_Colour.B17 = EEpDat >> 6; 
....................    GREEN_Colour.B18 = EEpDat >> 7; 
....................     
....................    EEpDat = read_eeprom(0x17); 
....................    //Green19_20 = EEpDat; 
....................    GREEN_Colour.B19 = EEpDat; 
....................    GREEN_Colour.B20 = EEpDat >> 1; 
....................    */ 
....................    
....................  
....................    ////////////////////////////////////////////////// 
....................  
....................    AutoAck = read_eeprom(0x18);          // Auto Acknoeledge 
0C0A:  MOVFF  FF2,1AB
0C0E:  BCF    FF2.7
0C10:  MOVLW  18
0C12:  MOVWF  FA9
0C14:  BCF    FA6.6
0C16:  BCF    FA6.7
0C18:  BSF    FA6.0
0C1A:  MOVF   FA8,W
0C1C:  BTFSC  xAB.7
0C1E:  BSF    FF2.7
0C20:  MOVWF  5B
....................    AutoAckTime = read_eeprom(0x19);      // Auto Acknoeledge Time 
0C22:  MOVFF  FF2,1AB
0C26:  BCF    FF2.7
0C28:  MOVLW  19
0C2A:  MOVWF  FA9
0C2C:  BCF    FA6.6
0C2E:  BCF    FA6.7
0C30:  BSF    FA6.0
0C32:  MOVF   FA8,W
0C34:  BTFSC  xAB.7
0C36:  BSF    FF2.7
0C38:  MOVWF  5C
....................    FlashingRate = read_eeprom(0x1A); // Flashing rate 
0C3A:  MOVFF  FF2,1AB
0C3E:  BCF    FF2.7
0C40:  MOVLW  1A
0C42:  MOVWF  FA9
0C44:  BCF    FA6.6
0C46:  BCF    FA6.7
0C48:  BSF    FA6.0
0C4A:  MOVF   FA8,W
0C4C:  BTFSC  xAB.7
0C4E:  BSF    FF2.7
0C50:  MOVWF  5D
....................    NoOfPoint = read_eeprom(0x1B);        // Number of total point 
0C52:  MOVFF  FF2,1AB
0C56:  BCF    FF2.7
0C58:  MOVLW  1B
0C5A:  MOVWF  FA9
0C5C:  BCF    FA6.6
0C5E:  BCF    FA6.7
0C60:  BSF    FA6.0
0C62:  MOVF   FA8,W
0C64:  BTFSC  xAB.7
0C66:  BSF    FF2.7
0C68:  MOVWF  5E
....................    FaultDelayTime[0] = read_eeprom(0x1C);  // Master or slave sync(flashing) 
0C6A:  MOVFF  FF2,1AB
0C6E:  BCF    FF2.7
0C70:  MOVLW  1C
0C72:  MOVWF  FA9
0C74:  BCF    FA6.6
0C76:  BCF    FA6.7
0C78:  BSF    FA6.0
0C7A:  MOVF   FA8,W
0C7C:  BTFSC  xAB.7
0C7E:  BSF    FF2.7
0C80:  CLRF   x6B
0C82:  MOVWF  x6A
....................  
....................    Address = read_eeprom(0x1D);          //Communication address 
0C84:  MOVFF  FF2,1AB
0C88:  BCF    FF2.7
0C8A:  MOVLW  1D
0C8C:  MOVWF  FA9
0C8E:  BCF    FA6.6
0C90:  BCF    FA6.7
0C92:  BSF    FA6.0
0C94:  MOVF   FA8,W
0C96:  BTFSC  xAB.7
0C98:  BSF    FF2.7
0C9A:  MOVWF  69
....................     
....................    FaultDelayTime[1] = read_eeprom(0x1E); 
0C9C:  MOVFF  FF2,1AB
0CA0:  BCF    FF2.7
0CA2:  MOVLW  1E
0CA4:  MOVWF  FA9
0CA6:  BCF    FA6.6
0CA8:  BCF    FA6.7
0CAA:  BSF    FA6.0
0CAC:  MOVF   FA8,W
0CAE:  BTFSC  xAB.7
0CB0:  BSF    FF2.7
0CB2:  CLRF   x6D
0CB4:  MOVWF  x6C
....................    FaultDelayTime[2] = read_eeprom(0x1F); 
0CB6:  MOVFF  FF2,1AB
0CBA:  BCF    FF2.7
0CBC:  MOVLW  1F
0CBE:  MOVWF  FA9
0CC0:  BCF    FA6.6
0CC2:  BCF    FA6.7
0CC4:  BSF    FA6.0
0CC6:  MOVF   FA8,W
0CC8:  BTFSC  xAB.7
0CCA:  BSF    FF2.7
0CCC:  CLRF   x6F
0CCE:  MOVWF  x6E
....................    FaultDelayTime[3] = read_eeprom(0x20); 
0CD0:  MOVFF  FF2,1AB
0CD4:  BCF    FF2.7
0CD6:  MOVLW  20
0CD8:  MOVWF  FA9
0CDA:  BCF    FA6.6
0CDC:  BCF    FA6.7
0CDE:  BSF    FA6.0
0CE0:  MOVF   FA8,W
0CE2:  BTFSC  xAB.7
0CE4:  BSF    FF2.7
0CE6:  CLRF   x71
0CE8:  MOVWF  x70
....................    FaultDelayTime[4] = read_eeprom(0x21); 
0CEA:  MOVFF  FF2,1AB
0CEE:  BCF    FF2.7
0CF0:  MOVLW  21
0CF2:  MOVWF  FA9
0CF4:  BCF    FA6.6
0CF6:  BCF    FA6.7
0CF8:  BSF    FA6.0
0CFA:  MOVF   FA8,W
0CFC:  BTFSC  xAB.7
0CFE:  BSF    FF2.7
0D00:  CLRF   x73
0D02:  MOVWF  x72
....................    FaultDelayTime[5] = read_eeprom(0x22); 
0D04:  MOVFF  FF2,1AB
0D08:  BCF    FF2.7
0D0A:  MOVLW  22
0D0C:  MOVWF  FA9
0D0E:  BCF    FA6.6
0D10:  BCF    FA6.7
0D12:  BSF    FA6.0
0D14:  MOVF   FA8,W
0D16:  BTFSC  xAB.7
0D18:  BSF    FF2.7
0D1A:  CLRF   x75
0D1C:  MOVWF  x74
....................    FaultDelayTime[6] = read_eeprom(0x23); 
0D1E:  MOVFF  FF2,1AB
0D22:  BCF    FF2.7
0D24:  MOVLW  23
0D26:  MOVWF  FA9
0D28:  BCF    FA6.6
0D2A:  BCF    FA6.7
0D2C:  BSF    FA6.0
0D2E:  MOVF   FA8,W
0D30:  BTFSC  xAB.7
0D32:  BSF    FF2.7
0D34:  CLRF   x77
0D36:  MOVWF  x76
....................    FaultDelayTime[7] = read_eeprom(0x24); 
0D38:  MOVFF  FF2,1AB
0D3C:  BCF    FF2.7
0D3E:  MOVLW  24
0D40:  MOVWF  FA9
0D42:  BCF    FA6.6
0D44:  BCF    FA6.7
0D46:  BSF    FA6.0
0D48:  MOVF   FA8,W
0D4A:  BTFSC  xAB.7
0D4C:  BSF    FF2.7
0D4E:  CLRF   x79
0D50:  MOVWF  x78
....................    FaultDelayTime[8] = read_eeprom(0x25); 
0D52:  MOVFF  FF2,1AB
0D56:  BCF    FF2.7
0D58:  MOVLW  25
0D5A:  MOVWF  FA9
0D5C:  BCF    FA6.6
0D5E:  BCF    FA6.7
0D60:  BSF    FA6.0
0D62:  MOVF   FA8,W
0D64:  BTFSC  xAB.7
0D66:  BSF    FF2.7
0D68:  CLRF   x7B
0D6A:  MOVWF  x7A
....................    FaultDelayTime[9] = read_eeprom(0x26); 
0D6C:  MOVFF  FF2,1AB
0D70:  BCF    FF2.7
0D72:  MOVLW  26
0D74:  MOVWF  FA9
0D76:  BCF    FA6.6
0D78:  BCF    FA6.7
0D7A:  BSF    FA6.0
0D7C:  MOVF   FA8,W
0D7E:  BTFSC  xAB.7
0D80:  BSF    FF2.7
0D82:  CLRF   x7D
0D84:  MOVWF  x7C
....................    FaultDelayTime[10] = read_eeprom(0x27); 
0D86:  MOVFF  FF2,1AB
0D8A:  BCF    FF2.7
0D8C:  MOVLW  27
0D8E:  MOVWF  FA9
0D90:  BCF    FA6.6
0D92:  BCF    FA6.7
0D94:  BSF    FA6.0
0D96:  MOVF   FA8,W
0D98:  BTFSC  xAB.7
0D9A:  BSF    FF2.7
0D9C:  CLRF   x7F
0D9E:  MOVWF  x7E
....................    FaultDelayTime[11] = read_eeprom(0x28); 
0DA0:  MOVFF  FF2,1AB
0DA4:  BCF    FF2.7
0DA6:  MOVLW  28
0DA8:  MOVWF  FA9
0DAA:  BCF    FA6.6
0DAC:  BCF    FA6.7
0DAE:  BSF    FA6.0
0DB0:  MOVF   FA8,W
0DB2:  BTFSC  xAB.7
0DB4:  BSF    FF2.7
0DB6:  CLRF   x81
0DB8:  MOVWF  x80
....................    FaultDelayTime[12] = read_eeprom(0x29); 
0DBA:  MOVFF  FF2,1AB
0DBE:  BCF    FF2.7
0DC0:  MOVLW  29
0DC2:  MOVWF  FA9
0DC4:  BCF    FA6.6
0DC6:  BCF    FA6.7
0DC8:  BSF    FA6.0
0DCA:  MOVF   FA8,W
0DCC:  BTFSC  xAB.7
0DCE:  BSF    FF2.7
0DD0:  CLRF   x83
0DD2:  MOVWF  x82
....................    FaultDelayTime[13] = read_eeprom(0x2A); 
0DD4:  MOVFF  FF2,1AB
0DD8:  BCF    FF2.7
0DDA:  MOVLW  2A
0DDC:  MOVWF  FA9
0DDE:  BCF    FA6.6
0DE0:  BCF    FA6.7
0DE2:  BSF    FA6.0
0DE4:  MOVF   FA8,W
0DE6:  BTFSC  xAB.7
0DE8:  BSF    FF2.7
0DEA:  CLRF   x85
0DEC:  MOVWF  x84
....................    FaultDelayTime[14] = read_eeprom(0x2B); 
0DEE:  MOVFF  FF2,1AB
0DF2:  BCF    FF2.7
0DF4:  MOVLW  2B
0DF6:  MOVWF  FA9
0DF8:  BCF    FA6.6
0DFA:  BCF    FA6.7
0DFC:  BSF    FA6.0
0DFE:  MOVF   FA8,W
0E00:  BTFSC  xAB.7
0E02:  BSF    FF2.7
0E04:  CLRF   x87
0E06:  MOVWF  x86
....................    FaultDelayTime[15] = read_eeprom(0x2C); 
0E08:  MOVFF  FF2,1AB
0E0C:  BCF    FF2.7
0E0E:  MOVLW  2C
0E10:  MOVWF  FA9
0E12:  BCF    FA6.6
0E14:  BCF    FA6.7
0E16:  BSF    FA6.0
0E18:  MOVF   FA8,W
0E1A:  BTFSC  xAB.7
0E1C:  BSF    FF2.7
0E1E:  CLRF   x89
0E20:  MOVWF  x88
....................    FaultDelayTime[16] = read_eeprom(0x2D); 
0E22:  MOVFF  FF2,1AB
0E26:  BCF    FF2.7
0E28:  MOVLW  2D
0E2A:  MOVWF  FA9
0E2C:  BCF    FA6.6
0E2E:  BCF    FA6.7
0E30:  BSF    FA6.0
0E32:  MOVF   FA8,W
0E34:  BTFSC  xAB.7
0E36:  BSF    FF2.7
0E38:  CLRF   x8B
0E3A:  MOVWF  x8A
....................    FaultDelayTime[17] = read_eeprom(0x2E); 
0E3C:  MOVFF  FF2,1AB
0E40:  BCF    FF2.7
0E42:  MOVLW  2E
0E44:  MOVWF  FA9
0E46:  BCF    FA6.6
0E48:  BCF    FA6.7
0E4A:  BSF    FA6.0
0E4C:  MOVF   FA8,W
0E4E:  BTFSC  xAB.7
0E50:  BSF    FF2.7
0E52:  CLRF   x8D
0E54:  MOVWF  x8C
....................    FaultDelayTime[18] = read_eeprom(0x2F); 
0E56:  MOVFF  FF2,1AB
0E5A:  BCF    FF2.7
0E5C:  MOVLW  2F
0E5E:  MOVWF  FA9
0E60:  BCF    FA6.6
0E62:  BCF    FA6.7
0E64:  BSF    FA6.0
0E66:  MOVF   FA8,W
0E68:  BTFSC  xAB.7
0E6A:  BSF    FF2.7
0E6C:  CLRF   x8F
0E6E:  MOVWF  x8E
....................    FaultDelayTime[19] = read_eeprom(0x30); 
0E70:  MOVFF  FF2,1AB
0E74:  BCF    FF2.7
0E76:  MOVLW  30
0E78:  MOVWF  FA9
0E7A:  BCF    FA6.6
0E7C:  BCF    FA6.7
0E7E:  BSF    FA6.0
0E80:  MOVF   FA8,W
0E82:  BTFSC  xAB.7
0E84:  BSF    FF2.7
0E86:  CLRF   x91
0E88:  MOVWF  x90
....................    FaultDelayTime[20] = read_eeprom(0x31); 
0E8A:  MOVFF  FF2,1AB
0E8E:  BCF    FF2.7
0E90:  MOVLW  31
0E92:  MOVWF  FA9
0E94:  BCF    FA6.6
0E96:  BCF    FA6.7
0E98:  BSF    FA6.0
0E9A:  MOVF   FA8,W
0E9C:  BTFSC  xAB.7
0E9E:  BSF    FF2.7
0EA0:  CLRF   x93
0EA2:  MOVWF  x92
....................     
....................    //BuadRate = read_eeprom(0x61);         //Buad Rate 
....................    //NoOfbit = read_eeprom(0x62); 
....................    //Parity = read_eeprom(0x63); 
....................    //Stopbit = read_eeprom(0x64); 
.................... } 
0EA4:  MOVLB  0
0EA6:  RETLW  00
.................... ////////////////////////////////////////////////////////////////////////////////// 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... #int_RDA 
.................... void RDA_isr(void) 
.................... { 
....................  
....................    //Data = getc(); 
....................    //putc(Data); 
....................    SBUF = getc(); 
*
0518:  CLRWDT
051A:  BTFSS  F9E.5
051C:  BRA    0518
051E:  MOVFF  FAE,2B
....................    checkCommand(); 
0522:  BRA    02E2
.................... } 
0524:  BCF    F9E.5
0526:  GOTO   006C
.................... #int_TIMER1 
.................... void  TIMER1_isr(void)  
.................... { 
....................    //ReadIn_flag =1; 
.................... } 
....................  
052A:  BCF    F9E.0
052C:  GOTO   006C
.................... #int_TIMER2 
.................... void TIMER2_isr(void)      //10ms 
.................... { 
....................    StatusTime++; 
0530:  INCF   16,F
....................  
....................    if(T_timeout != 0) 
0532:  MOVLB  1
0534:  MOVF   x07,F
0536:  BZ    0546
....................    { 
....................       T_timeout--; 
0538:  DECF   x07,F
....................       if(T_timeout == 0) 
053A:  MOVF   x07,F
053C:  BNZ   0546
....................       { 
....................          //sequence = stop_sq;         //timeout 
....................          sequence = end_sq;         //timeout  
053E:  MOVFF  60,68
....................          output_bit(P485ctrl,0); 
0542:  BCF    F8A.3
0544:  BCF    F93.3
....................       } 
....................    } 
....................    ////////// Time Base 1 Second ///////////// 
....................    if(TimeBase1s != 0x00) 
0546:  MOVF   19,F
0548:  BZ    0562
....................    { 
....................       TimeBase1s--; 
054A:  DECF   19,F
....................       if(TimeBase1s == 0x00)      // <====== code in time base 1 second 
054C:  MOVF   19,F
054E:  BNZ   0562
....................       { 
....................          if(AutoAckDelayTime != 0x00) 
0550:  MOVF   1A,F
0552:  BZ    055C
....................          { 
....................             AutoAckDelayTime--; 
0554:  DECF   1A,F
....................             if(AutoAckDelayTime == 0x00) 
0556:  MOVF   1A,F
0558:  BNZ   055C
....................             { 
....................                AutoAckFlag = 1 ; 
055A:  BSF    17.2
....................             } 
....................          } 
....................          ////////////////////////////// 
....................          RefreshConfigData = 1; 
055C:  BSF    2D.3
....................          TimeBase1s = 100; 
055E:  MOVLW  64
0560:  MOVWF  19
....................       } 
....................  
....................    } 
....................    ///////////// End Time base 1 Second /////// 
....................  
....................  
....................  
....................    if(StatusTime == 50)    //500mS 
0562:  MOVF   16,W
0564:  SUBLW  32
0566:  BNZ   0590
....................    { 
....................       StatusTime = 0; 
0568:  CLRF   16
....................       if(HearthbeatInd == 0) 
056A:  BTFSC  17.0
056C:  BRA    0576
....................       { 
....................          HearthbeatInd = 1; 
056E:  BSF    17.0
....................          output_bit(Pled,1); 
0570:  BSF    F8A.5
0572:  BCF    F93.5
....................       } 
....................       else 
0574:  BRA    057C
....................       { 
....................          HearthbeatInd = 0; 
0576:  BCF    17.0
....................          output_bit(Pled,0); 
0578:  BCF    F8A.5
057A:  BCF    F93.5
....................       } 
....................       /////////////////////////////////////////// time base 500 ms 
....................       if(Test == 1)            //Test function 
057C:  BTFSS  17.6
057E:  BRA    058E
....................          { 
....................              if(T_test > 0x00) T_test --; 
0580:  MOVF   2C,F
0582:  BTFSS  FD8.2
0584:  DECF   2C,F
....................              if(T_test == 0x00) Test_fault = 1; 
0586:  MOVF   2C,F
0588:  BTFSC  FD8.2
058A:  BSF    17.5
....................          } 
....................          else 
058C:  BRA    0590
....................          { 
....................              //Test = 0; 
....................              T_test = 0x00; 
058E:  CLRF   2C
....................          } 
....................    } 
....................    /////////////////////////////// 
....................    if(FlashingRateTime != 0) 
0590:  MOVF   18,F
0592:  BZ    05BC
....................    { 
....................       FlashingRateTime--; 
0594:  DECF   18,F
....................       if(FlashingRateTime == 0) 
0596:  MOVF   18,F
0598:  BNZ   05B0
....................       { 
....................          outmcp23 = 0xff; 
059A:  MOVLW  FF
059C:  MOVWF  x09
....................           
....................          if(SyncStatus == 0) 
059E:  BTFSC  2D.1
05A0:  BRA    05AC
....................          { 
....................             if(FlashingFlag == 1) 
05A2:  BTFSS  17.1
05A4:  BRA    05AA
....................             { 
....................                FlashingFlag = 0; 
05A6:  BCF    17.1
....................                //output_bit(PSyncS,0); 
....................             } 
....................             else 
05A8:  BRA    05AC
....................             { 
....................  
....................                FlashingFlag = 1; 
05AA:  BSF    17.1
....................                //output_bit(PSyncS,1); 
....................             } 
....................          } 
....................          //FlashingFlag = ~FlashingFlag; 
....................          FlashingRateTime = FlashingRate;      //reload value 
05AC:  MOVFF  5D,18
....................       } 
....................  
....................       if(Synctimer != 0x00) 
05B0:  MOVF   2E,F
05B2:  BZ    05BC
....................       { 
....................          Synctimer--; 
05B4:  DECF   2E,F
....................          if(Synctimer == 0x00) 
05B6:  MOVF   2E,F
05B8:  BNZ   05BC
....................          { 
....................             SyncStatus = 0; 
05BA:  BCF    2D.1
....................          } 
....................       } 
....................  
....................    } 
....................     
....................     
.................... } 
....................  
.................... /////////////////////////////////////////////////////////////////////////////////////////// 
.................... /////////////////////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
05BC:  BCF    F9E.1
05BE:  MOVLB  0
05C0:  GOTO   006C
.................... void Anal_Function(void) 
.................... { 
....................    ///////////////////////////////////////////////////////////////////////////// 
....................    ////////////////////////////// MANUAL RESET ///////////////////////////////// 
....................    ///////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... //if(NoOfPoint >= 10) 
.................... //{ 
....................  
.................... //input1 
....................    if(AlarmIndicator.B1 == 1)    // Alarm Function 
*
39A6:  MOVLB  1
39A8:  BTFSS  x16.0
39AA:  BRA    3A12
....................    { 
....................       if((((Inputt.B1 ^ InputType.B1) == 1) && (FaultType.B1 == 1))|| In.B1 == 1)    // alarm1 occure and "Lock type" 
39AC:  MOVLW  00
39AE:  BTFSC  x0A.0
39B0:  MOVLW  01
39B2:  MOVWF  xB3
39B4:  MOVLW  00
39B6:  BTFSC  x0E.0
39B8:  MOVLW  01
39BA:  XORWF  xB3,W
39BC:  SUBLW  01
39BE:  BNZ   39C4
39C0:  BTFSC  x10.0
39C2:  BRA    39C8
39C4:  BTFSS  x1A.0
39C6:  BRA    3A0C
....................       //if(Inputt.B1 == 0) 
....................       { 
....................          if(Ack.B1 == 0) 
39C8:  BTFSC  x18.0
39CA:  BRA    3A0A
....................          { 
....................             if(In.B1 == 0 && AutoAck == 0x0F)   //use auto acknowlegde 
39CC:  BTFSC  x1A.0
39CE:  BRA    39DE
39D0:  MOVF   5B,W
39D2:  SUBLW  0F
39D4:  BNZ   39DE
....................             { 
....................                TimeBase1s = 100 ;            //reload again 
39D6:  MOVLW  64
39D8:  MOVWF  19
....................                AutoAckDelayTime = AutoAckTime ; 
39DA:  MOVFF  5C,1A
....................             } 
....................  
....................             In.B1 = 1;                                 // setbit in1 
39DE:  BSF    x1A.0
....................             if(FlashingFlag == 0)                                                                                                                                                                                                                                                                 
39E0:  BTFSC  17.1
39E2:  BRA    39E8
....................             { 
....................                Output.B1 = 0;           //Flash output1 
39E4:  BCF    x0C.0
....................             } 
....................             else 
39E6:  BRA    39EA
....................             { 
....................                Output.B1 = 1; 
39E8:  BSF    x0C.0
....................             } 
....................  
....................             if (~AutoTestFlag) 
39EA:  BTFSC  17.4
39EC:  BRA    3A0A
....................             { 
....................                if(OutputBoth.B1 == 0)                  //Both output 
39EE:  BTFSC  x14.0
39F0:  BRA    39FC
....................                { 
....................                   output_bit(Pbuzzer,1);   //Buzzer 
39F2:  BSF    F89.4
39F4:  BCF    F92.4
....................                   output_bit(Pbell,1);     //Bell 
39F6:  BSF    F89.3
39F8:  BCF    F92.3
....................                } 
....................                else 
39FA:  BRA    3A0A
....................                { 
....................                   if(OutputType.B1 == 1) output_bit(Pbuzzer,1);     //Buzzer 
39FC:  BTFSS  x12.0
39FE:  BRA    3A06
3A00:  BSF    F89.4
3A02:  BCF    F92.4
....................                   else output_bit(Pbell,1);                          //Bell 
3A04:  BRA    3A0A
3A06:  BSF    F89.3
3A08:  BCF    F92.3
....................                } 
....................             } 
....................         } 
....................       } 
....................       else if(FaultType.B1 == 1) Ack.B1 = 0; 
3A0A:  BRA    3A10
3A0C:  BTFSC  x10.0
3A0E:  BCF    x18.0
....................    } 
....................    else  //Indicator Function 
3A10:  BRA    3A2C
....................    { 
....................       if((Inputt.B1 ^ InputType.B1) == 1) 
3A12:  MOVLW  00
3A14:  BTFSC  x0A.0
3A16:  MOVLW  01
3A18:  MOVWF  xB3
3A1A:  MOVLW  00
3A1C:  BTFSC  x0E.0
3A1E:  MOVLW  01
3A20:  XORWF  xB3,W
3A22:  SUBLW  01
3A24:  BNZ   3A2A
....................       { 
....................          Output.B1 = 0; 
3A26:  BCF    x0C.0
....................       } 
....................       else 
3A28:  BRA    3A2C
....................       { 
....................          Output.B1 = 1; 
3A2A:  BSF    x0C.0
....................       } 
....................    } 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //input2 
....................    if(AlarmIndicator.B2 == 1)    // Alarm Function 
3A2C:  BTFSS  x16.1
3A2E:  BRA    3A96
....................    { 
....................       if((((Inputt.B2 ^ InputType.B2) == 1) && (FaultType.B2 == 1))|| In.B2 == 1)    // alarm1 occure and "Lock type" 
3A30:  MOVLW  00
3A32:  BTFSC  x0A.1
3A34:  MOVLW  01
3A36:  MOVWF  xB3
3A38:  MOVLW  00
3A3A:  BTFSC  x0E.1
3A3C:  MOVLW  01
3A3E:  XORWF  xB3,W
3A40:  SUBLW  01
3A42:  BNZ   3A48
3A44:  BTFSC  x10.1
3A46:  BRA    3A4C
3A48:  BTFSS  x1A.1
3A4A:  BRA    3A90
....................       //if(Inputt.B2 == 0) 
....................       { 
....................          if(Ack.B2 == 0) 
3A4C:  BTFSC  x18.1
3A4E:  BRA    3A8E
....................          { 
....................             if(In.B2 == 0 && AutoAck == 0x0F)   //use auto acknowlegde 
3A50:  BTFSC  x1A.1
3A52:  BRA    3A62
3A54:  MOVF   5B,W
3A56:  SUBLW  0F
3A58:  BNZ   3A62
....................             { 
....................                TimeBase1s = 100 ;            //reload again 
3A5A:  MOVLW  64
3A5C:  MOVWF  19
....................                AutoAckDelayTime = AutoAckTime ; 
3A5E:  MOVFF  5C,1A
....................             } 
....................  
....................             In.B2 = 1;                                 // setbit in1 
3A62:  BSF    x1A.1
....................             if(FlashingFlag == 0) 
3A64:  BTFSC  17.1
3A66:  BRA    3A6C
....................             { 
....................                Output.B2 = 0;           //Flash output1 
3A68:  BCF    x0C.1
....................             } 
....................             else 
3A6A:  BRA    3A6E
....................             { 
....................                Output.B2 = 1; 
3A6C:  BSF    x0C.1
....................             } 
....................  
....................             if (~AutoTestFlag) 
3A6E:  BTFSC  17.4
3A70:  BRA    3A8E
....................             { 
....................                if(OutputBoth.B2 == 0)                  //Both output 
3A72:  BTFSC  x14.1
3A74:  BRA    3A80
....................                { 
....................                   output_bit(Pbuzzer,1);   //Buzzer 
3A76:  BSF    F89.4
3A78:  BCF    F92.4
....................                   output_bit(Pbell,1);     //Bell 
3A7A:  BSF    F89.3
3A7C:  BCF    F92.3
....................                } 
....................                else 
3A7E:  BRA    3A8E
....................                { 
....................                   if(OutputType.B2 == 1) output_bit(Pbuzzer,1);     //Buzzer 
3A80:  BTFSS  x12.1
3A82:  BRA    3A8A
3A84:  BSF    F89.4
3A86:  BCF    F92.4
....................                   else output_bit(Pbell,1);                          //Bell 
3A88:  BRA    3A8E
3A8A:  BSF    F89.3
3A8C:  BCF    F92.3
....................                } 
....................             } 
....................           } 
....................  
....................       } 
....................       else if(FaultType.B2 == 1) Ack.B2 = 0; 
3A8E:  BRA    3A94
3A90:  BTFSC  x10.1
3A92:  BCF    x18.1
....................    } 
....................    else  //Indicator Function 
3A94:  BRA    3AB0
....................    { 
....................       if((Inputt.B2 ^ InputType.B2) == 1) 
3A96:  MOVLW  00
3A98:  BTFSC  x0A.1
3A9A:  MOVLW  01
3A9C:  MOVWF  xB3
3A9E:  MOVLW  00
3AA0:  BTFSC  x0E.1
3AA2:  MOVLW  01
3AA4:  XORWF  xB3,W
3AA6:  SUBLW  01
3AA8:  BNZ   3AAE
....................       { 
....................          Output.B2 = 0; 
3AAA:  BCF    x0C.1
....................       } 
....................       else 
3AAC:  BRA    3AB0
....................       { 
....................          Output.B2 = 1; 
3AAE:  BSF    x0C.1
....................       } 
....................    } 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //input3 
....................    if(AlarmIndicator.B3 == 1)    // Alarm Function 
3AB0:  BTFSS  x16.2
3AB2:  BRA    3B1A
....................    { 
....................       if((((Inputt.B3 ^ InputType.B3) == 1) && (FaultType.B3 == 1))|| In.B3 == 1)    // alarm1 occure and "Lock type" 
3AB4:  MOVLW  00
3AB6:  BTFSC  x0A.2
3AB8:  MOVLW  01
3ABA:  MOVWF  xB3
3ABC:  MOVLW  00
3ABE:  BTFSC  x0E.2
3AC0:  MOVLW  01
3AC2:  XORWF  xB3,W
3AC4:  SUBLW  01
3AC6:  BNZ   3ACC
3AC8:  BTFSC  x10.2
3ACA:  BRA    3AD0
3ACC:  BTFSS  x1A.2
3ACE:  BRA    3B14
....................       //if(Inputt.B3 == 0) 
....................       { 
....................          if(Ack.B3 == 0) 
3AD0:  BTFSC  x18.2
3AD2:  BRA    3B12
....................          { 
....................             if(In.B3 == 0 && AutoAck == 0x0F)   //use auto acknowlegde 
3AD4:  BTFSC  x1A.2
3AD6:  BRA    3AE6
3AD8:  MOVF   5B,W
3ADA:  SUBLW  0F
3ADC:  BNZ   3AE6
....................             { 
....................                TimeBase1s = 100 ;            //reload again 
3ADE:  MOVLW  64
3AE0:  MOVWF  19
....................                AutoAckDelayTime = AutoAckTime ; 
3AE2:  MOVFF  5C,1A
....................             } 
....................  
....................             In.B3 = 1;                                 // setbit in1 
3AE6:  BSF    x1A.2
....................             if(FlashingFlag == 0) 
3AE8:  BTFSC  17.1
3AEA:  BRA    3AF0
....................             { 
....................                Output.B3 = 0;           //Flash output1 
3AEC:  BCF    x0C.2
....................             } 
....................             else 
3AEE:  BRA    3AF2
....................             { 
....................                Output.B3 = 1; 
3AF0:  BSF    x0C.2
....................             } 
....................  
....................             if (~AutoTestFlag) 
3AF2:  BTFSC  17.4
3AF4:  BRA    3B12
....................             { 
....................                if(OutputBoth.B3 == 0)                  //Both output 
3AF6:  BTFSC  x14.2
3AF8:  BRA    3B04
....................                { 
....................                   output_bit(Pbuzzer,1);   //Buzzer 
3AFA:  BSF    F89.4
3AFC:  BCF    F92.4
....................                   output_bit(Pbell,1);     //Bell 
3AFE:  BSF    F89.3
3B00:  BCF    F92.3
....................                } 
....................                else 
3B02:  BRA    3B12
....................                { 
....................                   if(OutputType.B3 == 1) output_bit(Pbuzzer,1);     //Buzzer 
3B04:  BTFSS  x12.2
3B06:  BRA    3B0E
3B08:  BSF    F89.4
3B0A:  BCF    F92.4
....................                   else output_bit(Pbell,1);                          //Bell 
3B0C:  BRA    3B12
3B0E:  BSF    F89.3
3B10:  BCF    F92.3
....................                } 
....................             } 
....................           } 
....................  
....................       } 
....................       else if(FaultType.B3 == 1) Ack.B3 = 0; 
3B12:  BRA    3B18
3B14:  BTFSC  x10.2
3B16:  BCF    x18.2
....................    } 
....................    else  //Indicator Function 
3B18:  BRA    3B34
....................    { 
....................       if((Inputt.B3 ^ InputType.B3) == 1) 
3B1A:  MOVLW  00
3B1C:  BTFSC  x0A.2
3B1E:  MOVLW  01
3B20:  MOVWF  xB3
3B22:  MOVLW  00
3B24:  BTFSC  x0E.2
3B26:  MOVLW  01
3B28:  XORWF  xB3,W
3B2A:  SUBLW  01
3B2C:  BNZ   3B32
....................       { 
....................          Output.B3 = 0; 
3B2E:  BCF    x0C.2
....................       } 
....................       else 
3B30:  BRA    3B34
....................       { 
....................          Output.B3 = 1; 
3B32:  BSF    x0C.2
....................       } 
....................    } 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //input4 
....................    if(AlarmIndicator.B4 == 1)    // Alarm Function 
3B34:  BTFSS  x16.3
3B36:  BRA    3B9E
....................    { 
....................       if((((Inputt.B4 ^ InputType.B4) == 1) && (FaultType.B4 == 1))|| In.B4 == 1)    // alarm1 occure and "Lock type" 
3B38:  MOVLW  00
3B3A:  BTFSC  x0A.3
3B3C:  MOVLW  01
3B3E:  MOVWF  xB3
3B40:  MOVLW  00
3B42:  BTFSC  x0E.3
3B44:  MOVLW  01
3B46:  XORWF  xB3,W
3B48:  SUBLW  01
3B4A:  BNZ   3B50
3B4C:  BTFSC  x10.3
3B4E:  BRA    3B54
3B50:  BTFSS  x1A.3
3B52:  BRA    3B98
....................       //if(Inputt.B4 == 0) 
....................       { 
....................          if(Ack.B4 == 0) 
3B54:  BTFSC  x18.3
3B56:  BRA    3B96
....................          { 
....................             if(In.B4 == 0 && AutoAck == 0x0F)   //use auto acknowlegde 
3B58:  BTFSC  x1A.3
3B5A:  BRA    3B6A
3B5C:  MOVF   5B,W
3B5E:  SUBLW  0F
3B60:  BNZ   3B6A
....................             { 
....................                TimeBase1s = 100 ;            //reload again 
3B62:  MOVLW  64
3B64:  MOVWF  19
....................                AutoAckDelayTime = AutoAckTime ; 
3B66:  MOVFF  5C,1A
....................             } 
....................  
....................             In.B4 = 1;                                 // setbit in1 
3B6A:  BSF    x1A.3
....................             if(FlashingFlag == 0) 
3B6C:  BTFSC  17.1
3B6E:  BRA    3B74
....................             { 
....................                Output.B4 = 0;           //Flash output1 
3B70:  BCF    x0C.3
....................             } 
....................             else 
3B72:  BRA    3B76
....................             { 
....................                Output.B4 = 1; 
3B74:  BSF    x0C.3
....................             } 
....................  
....................             if (~AutoTestFlag) 
3B76:  BTFSC  17.4
3B78:  BRA    3B96
....................             { 
....................                if(OutputBoth.B4 == 0)                  //Both output 
3B7A:  BTFSC  x14.3
3B7C:  BRA    3B88
....................                { 
....................                   output_bit(Pbuzzer,1);   //Buzzer 
3B7E:  BSF    F89.4
3B80:  BCF    F92.4
....................                   output_bit(Pbell,1);     //Bell 
3B82:  BSF    F89.3
3B84:  BCF    F92.3
....................                } 
....................                else 
3B86:  BRA    3B96
....................                { 
....................                   if(OutputType.B4 == 1) output_bit(Pbuzzer,1);     //Buzzer 
3B88:  BTFSS  x12.3
3B8A:  BRA    3B92
3B8C:  BSF    F89.4
3B8E:  BCF    F92.4
....................                   else output_bit(Pbell,1);                          //Bell 
3B90:  BRA    3B96
3B92:  BSF    F89.3
3B94:  BCF    F92.3
....................                } 
....................             } 
....................           } 
....................  
....................       } 
....................       else if(FaultType.B4 == 1) Ack.B4 = 0; 
3B96:  BRA    3B9C
3B98:  BTFSC  x10.3
3B9A:  BCF    x18.3
....................    } 
....................    else  //Indicator Function 
3B9C:  BRA    3BB8
....................    { 
....................       if((Inputt.B4 ^ InputType.B4) == 1) 
3B9E:  MOVLW  00
3BA0:  BTFSC  x0A.3
3BA2:  MOVLW  01
3BA4:  MOVWF  xB3
3BA6:  MOVLW  00
3BA8:  BTFSC  x0E.3
3BAA:  MOVLW  01
3BAC:  XORWF  xB3,W
3BAE:  SUBLW  01
3BB0:  BNZ   3BB6
....................       { 
....................          Output.B4 = 0; 
3BB2:  BCF    x0C.3
....................       } 
....................       else 
3BB4:  BRA    3BB8
....................       { 
....................          Output.B4 = 1; 
3BB6:  BSF    x0C.3
....................       } 
....................    } 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //input5 
....................    if(AlarmIndicator.B5 == 1)    // Alarm Function 
3BB8:  BTFSS  x16.4
3BBA:  BRA    3C22
....................    { 
....................       if((((Inputt.B5 ^ InputType.B5) == 1) && (FaultType.B5 == 1))|| In.B5 == 1)    // alarm1 occure and "Lock type" 
3BBC:  MOVLW  00
3BBE:  BTFSC  x0A.4
3BC0:  MOVLW  01
3BC2:  MOVWF  xB3
3BC4:  MOVLW  00
3BC6:  BTFSC  x0E.4
3BC8:  MOVLW  01
3BCA:  XORWF  xB3,W
3BCC:  SUBLW  01
3BCE:  BNZ   3BD4
3BD0:  BTFSC  x10.4
3BD2:  BRA    3BD8
3BD4:  BTFSS  x1A.4
3BD6:  BRA    3C1C
....................       //if(Inputt.B5 == 0) 
....................       { 
....................          if(Ack.B5 == 0) 
3BD8:  BTFSC  x18.4
3BDA:  BRA    3C1A
....................          { 
....................             if(In.B5 == 0 && AutoAck == 0x0F)   //use auto acknowlegde 
3BDC:  BTFSC  x1A.4
3BDE:  BRA    3BEE
3BE0:  MOVF   5B,W
3BE2:  SUBLW  0F
3BE4:  BNZ   3BEE
....................             { 
....................                TimeBase1s = 100 ;            //reload again 
3BE6:  MOVLW  64
3BE8:  MOVWF  19
....................                AutoAckDelayTime = AutoAckTime ; 
3BEA:  MOVFF  5C,1A
....................             } 
....................  
....................             In.B5 = 1;                                 // setbit in1 
3BEE:  BSF    x1A.4
....................             if(FlashingFlag == 0) 
3BF0:  BTFSC  17.1
3BF2:  BRA    3BF8
....................             { 
....................                Output.B5 = 0;           //Flash output1 
3BF4:  BCF    x0C.4
....................             } 
....................             else 
3BF6:  BRA    3BFA
....................             { 
....................                Output.B5 = 1; 
3BF8:  BSF    x0C.4
....................             } 
....................  
....................             if (~AutoTestFlag) 
3BFA:  BTFSC  17.4
3BFC:  BRA    3C1A
....................             { 
....................                if(OutputBoth.B5 == 0)                  //Both output 
3BFE:  BTFSC  x14.4
3C00:  BRA    3C0C
....................                { 
....................                   output_bit(Pbuzzer,1);   //Buzzer 
3C02:  BSF    F89.4
3C04:  BCF    F92.4
....................                   output_bit(Pbell,1);     //Bell 
3C06:  BSF    F89.3
3C08:  BCF    F92.3
....................                } 
....................                else 
3C0A:  BRA    3C1A
....................                { 
....................                   if(OutputType.B5 == 1) output_bit(Pbuzzer,1);     //Buzzer 
3C0C:  BTFSS  x12.4
3C0E:  BRA    3C16
3C10:  BSF    F89.4
3C12:  BCF    F92.4
....................                   else output_bit(Pbell,1);                          //Bell 
3C14:  BRA    3C1A
3C16:  BSF    F89.3
3C18:  BCF    F92.3
....................                } 
....................             } 
....................           } 
....................  
....................       } 
....................       else if(FaultType.B5 == 1) Ack.B5 = 0; 
3C1A:  BRA    3C20
3C1C:  BTFSC  x10.4
3C1E:  BCF    x18.4
....................    } 
....................    else  //Indicator Function 
3C20:  BRA    3C3C
....................    { 
....................       if((Inputt.B5 ^ InputType.B5) == 1) 
3C22:  MOVLW  00
3C24:  BTFSC  x0A.4
3C26:  MOVLW  01
3C28:  MOVWF  xB3
3C2A:  MOVLW  00
3C2C:  BTFSC  x0E.4
3C2E:  MOVLW  01
3C30:  XORWF  xB3,W
3C32:  SUBLW  01
3C34:  BNZ   3C3A
....................       { 
....................          Output.B5 = 0; 
3C36:  BCF    x0C.4
....................       } 
....................       else 
3C38:  BRA    3C3C
....................       { 
....................          Output.B5 = 1; 
3C3A:  BSF    x0C.4
....................       } 
....................    } 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //input6 
....................    if(AlarmIndicator.B6 == 1)    // Alarm Function 
3C3C:  BTFSS  x16.5
3C3E:  BRA    3CA6
....................    { 
....................       if((((Inputt.B6 ^ InputType.B6) == 1) && (FaultType.B6 == 1))|| In.B6 == 1)    // alarm1 occure and "Lock type" 
3C40:  MOVLW  00
3C42:  BTFSC  x0A.5
3C44:  MOVLW  01
3C46:  MOVWF  xB3
3C48:  MOVLW  00
3C4A:  BTFSC  x0E.5
3C4C:  MOVLW  01
3C4E:  XORWF  xB3,W
3C50:  SUBLW  01
3C52:  BNZ   3C58
3C54:  BTFSC  x10.5
3C56:  BRA    3C5C
3C58:  BTFSS  x1A.5
3C5A:  BRA    3CA0
....................       //if(Inputt.B6 == 0) 
....................       { 
....................          if(Ack.B6 == 0) 
3C5C:  BTFSC  x18.5
3C5E:  BRA    3C9E
....................          { 
....................             if(In.B6 == 0 && AutoAck == 0x0F)   //use auto acknowlegde 
3C60:  BTFSC  x1A.5
3C62:  BRA    3C72
3C64:  MOVF   5B,W
3C66:  SUBLW  0F
3C68:  BNZ   3C72
....................             { 
....................                TimeBase1s = 100 ;            //reload again 
3C6A:  MOVLW  64
3C6C:  MOVWF  19
....................                AutoAckDelayTime = AutoAckTime ; 
3C6E:  MOVFF  5C,1A
....................             } 
....................  
....................             In.B6 = 1;                                 // setbit in1 
3C72:  BSF    x1A.5
....................             if(FlashingFlag == 0) 
3C74:  BTFSC  17.1
3C76:  BRA    3C7C
....................             { 
....................                Output.B6 = 0;           //Flash output1 
3C78:  BCF    x0C.5
....................             } 
....................             else 
3C7A:  BRA    3C7E
....................             { 
....................                Output.B6 = 1; 
3C7C:  BSF    x0C.5
....................             } 
....................  
....................             if (~AutoTestFlag) 
3C7E:  BTFSC  17.4
3C80:  BRA    3C9E
....................             { 
....................                if(OutputBoth.B6 == 0)                  //Both output 
3C82:  BTFSC  x14.5
3C84:  BRA    3C90
....................                { 
....................                   output_bit(Pbuzzer,1);   //Buzzer 
3C86:  BSF    F89.4
3C88:  BCF    F92.4
....................                   output_bit(Pbell,1);     //Bell 
3C8A:  BSF    F89.3
3C8C:  BCF    F92.3
....................                } 
....................                else 
3C8E:  BRA    3C9E
....................                { 
....................                   if(OutputType.B6 == 1) output_bit(Pbuzzer,1);     //Buzzer 
3C90:  BTFSS  x12.5
3C92:  BRA    3C9A
3C94:  BSF    F89.4
3C96:  BCF    F92.4
....................                   else output_bit(Pbell,1);                          //Bell 
3C98:  BRA    3C9E
3C9A:  BSF    F89.3
3C9C:  BCF    F92.3
....................                } 
....................             } 
....................           } 
....................  
....................       } 
....................       else if(FaultType.B6 == 1) Ack.B6 = 0; 
3C9E:  BRA    3CA4
3CA0:  BTFSC  x10.5
3CA2:  BCF    x18.5
....................    } 
....................    else  //Indicator Function 
3CA4:  BRA    3CC0
....................    { 
....................       if((Inputt.B6 ^ InputType.B6) == 1) 
3CA6:  MOVLW  00
3CA8:  BTFSC  x0A.5
3CAA:  MOVLW  01
3CAC:  MOVWF  xB3
3CAE:  MOVLW  00
3CB0:  BTFSC  x0E.5
3CB2:  MOVLW  01
3CB4:  XORWF  xB3,W
3CB6:  SUBLW  01
3CB8:  BNZ   3CBE
....................       { 
....................          Output.B6 = 0; 
3CBA:  BCF    x0C.5
....................       } 
....................       else 
3CBC:  BRA    3CC0
....................       { 
....................          Output.B6 = 1; 
3CBE:  BSF    x0C.5
....................       } 
....................    } 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //input7 
....................    if(AlarmIndicator.B7 == 1)    // Alarm Function 
3CC0:  BTFSS  x16.6
3CC2:  BRA    3D2A
....................    { 
....................       if((((Inputt.B7 ^ InputType.B7) == 1) && (FaultType.B7 == 1))|| In.B7 == 1)    // alarm1 occure and "Lock type" 
3CC4:  MOVLW  00
3CC6:  BTFSC  x0A.6
3CC8:  MOVLW  01
3CCA:  MOVWF  xB3
3CCC:  MOVLW  00
3CCE:  BTFSC  x0E.6
3CD0:  MOVLW  01
3CD2:  XORWF  xB3,W
3CD4:  SUBLW  01
3CD6:  BNZ   3CDC
3CD8:  BTFSC  x10.6
3CDA:  BRA    3CE0
3CDC:  BTFSS  x1A.6
3CDE:  BRA    3D24
....................       //if(Inputt.B7 == 0) 
....................       { 
....................          if(Ack.B7 == 0) 
3CE0:  BTFSC  x18.6
3CE2:  BRA    3D22
....................          { 
....................             if(In.B7 == 0 && AutoAck == 0x0F)   //use auto acknowlegde 
3CE4:  BTFSC  x1A.6
3CE6:  BRA    3CF6
3CE8:  MOVF   5B,W
3CEA:  SUBLW  0F
3CEC:  BNZ   3CF6
....................             { 
....................                TimeBase1s = 100 ;            //reload again 
3CEE:  MOVLW  64
3CF0:  MOVWF  19
....................                AutoAckDelayTime = AutoAckTime ; 
3CF2:  MOVFF  5C,1A
....................             } 
....................  
....................             In.B7 = 1;                                 // setbit in1 
3CF6:  BSF    x1A.6
....................             if(FlashingFlag == 0) 
3CF8:  BTFSC  17.1
3CFA:  BRA    3D00
....................             { 
....................                Output.B7 = 0;           //Flash output1 
3CFC:  BCF    x0C.6
....................             } 
....................             else 
3CFE:  BRA    3D02
....................             { 
....................                Output.B7 = 1; 
3D00:  BSF    x0C.6
....................             } 
....................  
....................             if (~AutoTestFlag) 
3D02:  BTFSC  17.4
3D04:  BRA    3D22
....................             { 
....................                if(OutputBoth.B7 == 0)                  //Both output 
3D06:  BTFSC  x14.6
3D08:  BRA    3D14
....................                { 
....................                   output_bit(Pbuzzer,1);   //Buzzer 
3D0A:  BSF    F89.4
3D0C:  BCF    F92.4
....................                   output_bit(Pbell,1);     //Bell 
3D0E:  BSF    F89.3
3D10:  BCF    F92.3
....................                } 
....................                else 
3D12:  BRA    3D22
....................                { 
....................                   if(OutputType.B7 == 1) output_bit(Pbuzzer,1);     //Buzzer 
3D14:  BTFSS  x12.6
3D16:  BRA    3D1E
3D18:  BSF    F89.4
3D1A:  BCF    F92.4
....................                   else output_bit(Pbell,1);                          //Bell 
3D1C:  BRA    3D22
3D1E:  BSF    F89.3
3D20:  BCF    F92.3
....................                } 
....................             } 
....................           } 
....................  
....................       } 
....................       else if(FaultType.B7 == 1) Ack.B7 = 0; 
3D22:  BRA    3D28
3D24:  BTFSC  x10.6
3D26:  BCF    x18.6
....................    } 
....................    else  //Indicator Function 
3D28:  BRA    3D44
....................    { 
....................       if((Inputt.B7 ^ InputType.B7) == 1) 
3D2A:  MOVLW  00
3D2C:  BTFSC  x0A.6
3D2E:  MOVLW  01
3D30:  MOVWF  xB3
3D32:  MOVLW  00
3D34:  BTFSC  x0E.6
3D36:  MOVLW  01
3D38:  XORWF  xB3,W
3D3A:  SUBLW  01
3D3C:  BNZ   3D42
....................       { 
....................          Output.B7 = 0; 
3D3E:  BCF    x0C.6
....................       } 
....................       else 
3D40:  BRA    3D44
....................       { 
....................          Output.B7 = 1; 
3D42:  BSF    x0C.6
....................       } 
....................    } 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //input8 
....................    if(AlarmIndicator.B8 == 1)    // Alarm Function 
3D44:  BTFSS  x16.7
3D46:  BRA    3DAE
....................    { 
....................       if((((Inputt.B8 ^ InputType.B8) == 1) && (FaultType.B8 == 1))|| In.B8 == 1)    // alarm1 occure and "Lock type" 
3D48:  MOVLW  00
3D4A:  BTFSC  x0A.7
3D4C:  MOVLW  01
3D4E:  MOVWF  xB3
3D50:  MOVLW  00
3D52:  BTFSC  x0E.7
3D54:  MOVLW  01
3D56:  XORWF  xB3,W
3D58:  SUBLW  01
3D5A:  BNZ   3D60
3D5C:  BTFSC  x10.7
3D5E:  BRA    3D64
3D60:  BTFSS  x1A.7
3D62:  BRA    3DA8
....................       //if(Inputt.B8 == 0) 
....................       { 
....................          if(Ack.B8 == 0) 
3D64:  BTFSC  x18.7
3D66:  BRA    3DA6
....................          { 
....................             if(In.B8 == 0 && AutoAck == 0x0F)   //use auto acknowlegde 
3D68:  BTFSC  x1A.7
3D6A:  BRA    3D7A
3D6C:  MOVF   5B,W
3D6E:  SUBLW  0F
3D70:  BNZ   3D7A
....................             { 
....................                TimeBase1s = 100 ;            //reload again 
3D72:  MOVLW  64
3D74:  MOVWF  19
....................                AutoAckDelayTime = AutoAckTime ; 
3D76:  MOVFF  5C,1A
....................             } 
....................  
....................             In.B8 = 1;                                 // setbit in1 
3D7A:  BSF    x1A.7
....................             if(FlashingFlag == 0) 
3D7C:  BTFSC  17.1
3D7E:  BRA    3D84
....................             { 
....................                Output.B8 = 0;           //Flash output1 
3D80:  BCF    x0C.7
....................             } 
....................             else 
3D82:  BRA    3D86
....................             { 
....................                Output.B8 = 1; 
3D84:  BSF    x0C.7
....................             } 
....................  
....................             if (~AutoTestFlag) 
3D86:  BTFSC  17.4
3D88:  BRA    3DA6
....................             { 
....................                if(OutputBoth.B8 == 0)                  //Both output 
3D8A:  BTFSC  x14.7
3D8C:  BRA    3D98
....................                { 
....................                   output_bit(Pbuzzer,1);   //Buzzer 
3D8E:  BSF    F89.4
3D90:  BCF    F92.4
....................                   output_bit(Pbell,1);     //Bell 
3D92:  BSF    F89.3
3D94:  BCF    F92.3
....................                } 
....................                else 
3D96:  BRA    3DA6
....................                { 
....................                   if(OutputType.B8 == 1) output_bit(Pbuzzer,1);     //Buzzer 
3D98:  BTFSS  x12.7
3D9A:  BRA    3DA2
3D9C:  BSF    F89.4
3D9E:  BCF    F92.4
....................                   else output_bit(Pbell,1);                          //Bell 
3DA0:  BRA    3DA6
3DA2:  BSF    F89.3
3DA4:  BCF    F92.3
....................                } 
....................             } 
....................        } 
....................  
....................       } 
....................       else if(FaultType.B8 == 1) Ack.B8 = 0; 
3DA6:  BRA    3DAC
3DA8:  BTFSC  x10.7
3DAA:  BCF    x18.7
....................    } 
....................    else  //Indicator Function 
3DAC:  BRA    3DC8
....................    { 
....................       if((Inputt.B8 ^ InputType.B8) == 1) 
3DAE:  MOVLW  00
3DB0:  BTFSC  x0A.7
3DB2:  MOVLW  01
3DB4:  MOVWF  xB3
3DB6:  MOVLW  00
3DB8:  BTFSC  x0E.7
3DBA:  MOVLW  01
3DBC:  XORWF  xB3,W
3DBE:  SUBLW  01
3DC0:  BNZ   3DC6
....................       { 
....................          Output.B8 = 0; 
3DC2:  BCF    x0C.7
....................       } 
....................       else 
3DC4:  BRA    3DC8
....................       { 
....................          Output.B8 = 1; 
3DC6:  BSF    x0C.7
....................       } 
....................    } 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //input9 
....................    if(AlarmIndicator.B9 == 1)    // Alarm Function 
3DC8:  BTFSS  x17.0
3DCA:  BRA    3E32
....................    { 
....................       if((((Inputt.B9 ^ InputType.B9) == 1) && (FaultType.B9 == 1))|| In.B9 == 1)    // alarm1 occure and "Lock type" 
3DCC:  MOVLW  00
3DCE:  BTFSC  x0B.0
3DD0:  MOVLW  01
3DD2:  MOVWF  xB3
3DD4:  MOVLW  00
3DD6:  BTFSC  x0F.0
3DD8:  MOVLW  01
3DDA:  XORWF  xB3,W
3DDC:  SUBLW  01
3DDE:  BNZ   3DE4
3DE0:  BTFSC  x11.0
3DE2:  BRA    3DE8
3DE4:  BTFSS  x1B.0
3DE6:  BRA    3E2C
....................       //if(Inputt.B9 == 0) 
....................       { 
....................          if(Ack.B9 == 0) 
3DE8:  BTFSC  x19.0
3DEA:  BRA    3E2A
....................          { 
....................             if(In.B9 == 0 && AutoAck == 0x0F)   //use auto acknowlegde 
3DEC:  BTFSC  x1B.0
3DEE:  BRA    3DFE
3DF0:  MOVF   5B,W
3DF2:  SUBLW  0F
3DF4:  BNZ   3DFE
....................             { 
....................                TimeBase1s = 100 ;            //reload again 
3DF6:  MOVLW  64
3DF8:  MOVWF  19
....................                AutoAckDelayTime = AutoAckTime ; 
3DFA:  MOVFF  5C,1A
....................             } 
....................  
....................             In.B9 = 1;                                 // setbit in1 
3DFE:  BSF    x1B.0
....................             if(FlashingFlag == 0) 
3E00:  BTFSC  17.1
3E02:  BRA    3E08
....................             { 
....................                Output.B9 = 0;           //Flash output1 
3E04:  BCF    x0D.0
....................             } 
....................             else 
3E06:  BRA    3E0A
....................             { 
....................                Output.B9 = 1; 
3E08:  BSF    x0D.0
....................             } 
....................  
....................             if (~AutoTestFlag) 
3E0A:  BTFSC  17.4
3E0C:  BRA    3E2A
....................             { 
....................                if(OutputBoth.B9 == 0)                  //Both output 
3E0E:  BTFSC  x15.0
3E10:  BRA    3E1C
....................                { 
....................                   output_bit(Pbuzzer,1);   //Buzzer 
3E12:  BSF    F89.4
3E14:  BCF    F92.4
....................                   output_bit(Pbell,1);     //Bell 
3E16:  BSF    F89.3
3E18:  BCF    F92.3
....................                } 
....................                else 
3E1A:  BRA    3E2A
....................                { 
....................                   if(OutputType.B9 == 1) output_bit(Pbuzzer,1);     //Buzzer 
3E1C:  BTFSS  x13.0
3E1E:  BRA    3E26
3E20:  BSF    F89.4
3E22:  BCF    F92.4
....................                   else output_bit(Pbell,1);                          //Bell 
3E24:  BRA    3E2A
3E26:  BSF    F89.3
3E28:  BCF    F92.3
....................                } 
....................             } 
....................           } 
....................  
....................       } 
....................       else if(FaultType.B9 == 1) Ack.B9 = 0; 
3E2A:  BRA    3E30
3E2C:  BTFSC  x11.0
3E2E:  BCF    x19.0
....................    } 
....................    else  //Indicator Function 
3E30:  BRA    3E4C
....................    { 
....................       if((Inputt.B9 ^ InputType.B9) == 1) 
3E32:  MOVLW  00
3E34:  BTFSC  x0B.0
3E36:  MOVLW  01
3E38:  MOVWF  xB3
3E3A:  MOVLW  00
3E3C:  BTFSC  x0F.0
3E3E:  MOVLW  01
3E40:  XORWF  xB3,W
3E42:  SUBLW  01
3E44:  BNZ   3E4A
....................       { 
....................          Output.B9 = 0; 
3E46:  BCF    x0D.0
....................       } 
....................       else 
3E48:  BRA    3E4C
....................       { 
....................          Output.B9 = 1; 
3E4A:  BSF    x0D.0
....................       } 
....................    } 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //input10 
....................    if(AlarmIndicator.B10 == 1)    // Alarm Function 
3E4C:  BTFSS  x17.1
3E4E:  BRA    3EB6
....................    { 
....................       if((((Inputt.B10 ^ InputType.B10) == 1) && (FaultType.B10 == 1))|| In.B10 == 1)    // alarm1 occure and "Lock type" 
3E50:  MOVLW  00
3E52:  BTFSC  x0B.1
3E54:  MOVLW  01
3E56:  MOVWF  xB3
3E58:  MOVLW  00
3E5A:  BTFSC  x0F.1
3E5C:  MOVLW  01
3E5E:  XORWF  xB3,W
3E60:  SUBLW  01
3E62:  BNZ   3E68
3E64:  BTFSC  x11.1
3E66:  BRA    3E6C
3E68:  BTFSS  x1B.1
3E6A:  BRA    3EB0
....................       //if(Inputt.B10 == 0) 
....................       { 
....................          if(Ack.B10 == 0) 
3E6C:  BTFSC  x19.1
3E6E:  BRA    3EAE
....................          { 
....................             if(In.B10 == 0 && AutoAck == 0x0F)   //use auto acknowlegde 
3E70:  BTFSC  x1B.1
3E72:  BRA    3E82
3E74:  MOVF   5B,W
3E76:  SUBLW  0F
3E78:  BNZ   3E82
....................             { 
....................                TimeBase1s = 100 ;            //reload again 
3E7A:  MOVLW  64
3E7C:  MOVWF  19
....................                AutoAckDelayTime = AutoAckTime ; 
3E7E:  MOVFF  5C,1A
....................             } 
....................  
....................             In.B10 = 1;                                 // setbit in1 
3E82:  BSF    x1B.1
....................             if(FlashingFlag == 0) 
3E84:  BTFSC  17.1
3E86:  BRA    3E8C
....................             { 
....................                Output.B10 = 0;           //Flash output1 
3E88:  BCF    x0D.1
....................             } 
....................             else 
3E8A:  BRA    3E8E
....................             { 
....................                Output.B10 = 1; 
3E8C:  BSF    x0D.1
....................             } 
....................  
....................             if (~AutoTestFlag) 
3E8E:  BTFSC  17.4
3E90:  BRA    3EAE
....................             { 
....................                if(OutputBoth.B10 == 0)                  //Both output 
3E92:  BTFSC  x15.1
3E94:  BRA    3EA0
....................                { 
....................                   output_bit(Pbuzzer,1);   //Buzzer 
3E96:  BSF    F89.4
3E98:  BCF    F92.4
....................                   output_bit(Pbell,1);     //Bell 
3E9A:  BSF    F89.3
3E9C:  BCF    F92.3
....................                } 
....................                else 
3E9E:  BRA    3EAE
....................                { 
....................                   if(OutputType.B10 == 1) output_bit(Pbuzzer,1);     //Buzzer 
3EA0:  BTFSS  x13.1
3EA2:  BRA    3EAA
3EA4:  BSF    F89.4
3EA6:  BCF    F92.4
....................                   else output_bit(Pbell,1);                          //Bell 
3EA8:  BRA    3EAE
3EAA:  BSF    F89.3
3EAC:  BCF    F92.3
....................                } 
....................             } 
....................           } 
....................  
....................       } 
....................       else if(FaultType.B10 == 1) Ack.B10 = 0; 
3EAE:  BRA    3EB4
3EB0:  BTFSC  x11.1
3EB2:  BCF    x19.1
....................    } 
....................    else  //Indicator Function 
3EB4:  BRA    3ED0
....................    { 
....................       if((Inputt.B10 ^ InputType.B10) == 1) 
3EB6:  MOVLW  00
3EB8:  BTFSC  x0B.1
3EBA:  MOVLW  01
3EBC:  MOVWF  xB3
3EBE:  MOVLW  00
3EC0:  BTFSC  x0F.1
3EC2:  MOVLW  01
3EC4:  XORWF  xB3,W
3EC6:  SUBLW  01
3EC8:  BNZ   3ECE
....................       { 
....................          Output.B10 = 0; 
3ECA:  BCF    x0D.1
....................       } 
....................       else 
3ECC:  BRA    3ED0
....................       { 
....................          Output.B10 = 1; 
3ECE:  BSF    x0D.1
....................       } 
....................    } 
.................... //} 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... //if(NoOfPoint >= 20) 
.................... //{ 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //input11 
.................... /* 
....................    if(AlarmIndicator.B11 == 1)    // Alarm Function 
....................    { 
....................       if((((Inputt.B11 ^ InputType.B11) == 1) && (FaultType.B11 == 1))|| In.B11 == 1)    // alarm1 occure and "Lock type" 
....................       //if(Inputt.B11 == 0) 
....................       { 
....................          if(Ack.B11 == 0) 
....................          { 
....................             if(In.B11 == 0 && AutoAck == 0x0F)   //use auto acknowlegde 
....................             { 
....................                TimeBase1s = 100 ;            //reload again 
....................                AutoAckDelayTime = AutoAckTime ; 
....................             } 
....................  
....................             In.B11 = 1;                                 // setbit in1 
....................             if(FlashingFlag == 0) 
....................             { 
....................                Output.B11 = 0;           //Flash output1 
....................             } 
....................             else 
....................             { 
....................                Output.B11 = 1; 
....................             } 
....................  
....................             if (~AutoTestFlag) 
....................             { 
....................                if(OutputBoth.B11 == 0)                  //Both output 
....................                { 
....................                   output_bit(Pbuzzer,1);   //Buzzer 
....................                   output_bit(Pbell,1);     //Bell 
....................                } 
....................                else 
....................                { 
....................                   if(OutputType.B11 == 1) output_bit(Pbuzzer,1);     //Buzzer 
....................                   else output_bit(Pbell,1);                          //Bell 
....................                } 
....................             } 
....................           } 
....................  
....................       } 
....................       else if(FaultType.B11 == 1) Ack.B11 = 0; 
....................    } 
....................    else  //Indicator Function 
....................    { 
....................       if((Inputt.B11 ^ InputType.B11) == 1) 
....................       { 
....................          Output.B11 = 0; 
....................       } 
....................       else 
....................       { 
....................          Output.B11 = 1; 
....................       } 
....................    } 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //input12 
....................    if(AlarmIndicator.B12 == 1)    // Alarm Function 
....................    { 
....................       if((((Inputt.B12 ^ InputType.B12) == 1) && (FaultType.B12 == 1))|| In.B12 == 1)    // alarm1 occure and "Lock type" 
....................       //if(Inputt.B12 == 0) 
....................       { 
....................          if(Ack.B12 == 0) 
....................          { 
....................             if(In.B12 == 0 && AutoAck == 0x0F)   //use auto acknowlegde 
....................             { 
....................                TimeBase1s = 100 ;            //reload again 
....................                AutoAckDelayTime = AutoAckTime ; 
....................             } 
....................  
....................             In.B12 = 1;                                 // setbit in1 
....................             if(FlashingFlag == 0) 
....................             { 
....................                Output.B12 = 0;           //Flash output1 
....................             } 
....................             else 
....................             { 
....................                Output.B12 = 1; 
....................             } 
....................  
....................             if (~AutoTestFlag) 
....................             { 
....................                if(OutputBoth.B12 == 0)                  //Both output 
....................                { 
....................                   output_bit(Pbuzzer,1);   //Buzzer 
....................                   output_bit(Pbell,1);     //Bell 
....................                } 
....................                else 
....................                { 
....................                   if(OutputType.B12 == 1) output_bit(Pbuzzer,1);     //Buzzer 
....................                   else output_bit(Pbell,1);                          //Bell 
....................                } 
....................             } 
....................         } 
....................  
....................       } 
....................       else if(FaultType.B12 == 1) Ack.B12 = 0; 
....................    } 
....................    else  //Indicator Function 
....................    { 
....................       if((Inputt.B12 ^ InputType.B12) == 1) 
....................       { 
....................          Output.B12 = 0; 
....................       } 
....................       else 
....................       { 
....................          Output.B12 = 1; 
....................       } 
....................    } 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //input13 
....................    if(AlarmIndicator.B13 == 1)    // Alarm Function 
....................    { 
....................       if((((Inputt.B13 ^ InputType.B13) == 1) && (FaultType.B13 == 1))|| In.B13 == 1)    // alarm1 occure and "Lock type" 
....................       //if(Inputt.B13 == 0) 
....................       { 
....................          if(Ack.B13 == 0) 
....................          { 
....................             if(In.B13 == 0 && AutoAck == 0x0F)   //use auto acknowlegde 
....................             { 
....................                TimeBase1s = 100 ;            //reload again 
....................                AutoAckDelayTime = AutoAckTime ; 
....................             } 
....................  
....................             In.B13 = 1;                                 // setbit in1 
....................             if(FlashingFlag == 0) 
....................             { 
....................                Output.B13 = 0;           //Flash output1 
....................             } 
....................             else 
....................             { 
....................                Output.B13 = 1; 
....................             } 
....................  
....................             if (~AutoTestFlag) 
....................             { 
....................                if(OutputBoth.B13 == 0)                  //Both output 
....................                { 
....................                   output_bit(Pbuzzer,1);   //Buzzer 
....................                   output_bit(Pbell,1);     //Bell 
....................                } 
....................                else 
....................                { 
....................                   if(OutputType.B13 == 1) output_bit(Pbuzzer,1);     //Buzzer 
....................                   else output_bit(Pbell,1);                          //Bell 
....................                } 
....................             } 
....................           } 
....................  
....................       } 
....................       else if(FaultType.B13 == 1) Ack.B13 = 0; 
....................    } 
....................    else  //Indicator Function 
....................    { 
....................       if((Inputt.B13 ^ InputType.B13) == 1) 
....................       { 
....................          Output.B13 = 0; 
....................       } 
....................       else 
....................       { 
....................          Output.B13 = 1; 
....................       } 
....................    } 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //input14 
....................    if(AlarmIndicator.B14 == 1)    // Alarm Function 
....................    { 
....................       if((((Inputt.B14 ^ InputType.B14) == 1) && (FaultType.B14 == 1))|| In.B14 == 1)    // alarm1 occure and "Lock type" 
....................       //if(Inputt.B14 == 0) 
....................       { 
....................          if(Ack.B14 == 0) 
....................          { 
....................             if(In.B14 == 0 && AutoAck == 0x0F)   //use auto acknowlegde 
....................             { 
....................                TimeBase1s = 100 ;            //reload again 
....................                AutoAckDelayTime = AutoAckTime ; 
....................             } 
....................  
....................             In.B14 = 1;                                 // setbit in1 
....................             if(FlashingFlag == 0) 
....................             { 
....................                Output.B14 = 0;           //Flash output1 
....................             } 
....................             else 
....................             { 
....................                Output.B14 = 1; 
....................             } 
....................  
....................             if (~AutoTestFlag) 
....................             { 
....................                if(OutputBoth.B14 == 0)                  //Both output 
....................                { 
....................                   output_bit(Pbuzzer,1);   //Buzzer 
....................                   output_bit(Pbell,1);     //Bell 
....................                } 
....................                else 
....................                { 
....................                   if(OutputType.B14 == 1) output_bit(Pbuzzer,1);     //Buzzer 
....................                   else output_bit(Pbell,1);                          //Bell 
....................                } 
....................             } 
....................           } 
....................  
....................       } 
....................       else if(FaultType.B14 == 1) Ack.B14 = 0; 
....................    } 
....................    else  //Indicator Function 
....................    { 
....................       if((Inputt.B14 ^ InputType.B14) == 1) 
....................       { 
....................          Output.B14 = 0; 
....................       } 
....................       else 
....................       { 
....................          Output.B14 = 1; 
....................       } 
....................    } 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //input15 
....................    if(AlarmIndicator.B15 == 1)    // Alarm Function 
....................    { 
....................       if((((Inputt.B15 ^ InputType.B15) == 1) && (FaultType.B15 == 1))|| In.B15 == 1)    // alarm1 occure and "Lock type" 
....................       //if(Inputt.B15 == 0) 
....................       { 
....................          if(Ack.B15 == 0) 
....................          { 
....................             if(In.B15 == 0 && AutoAck == 0x0F)   //use auto acknowlegde 
....................             { 
....................                TimeBase1s = 100 ;            //reload again 
....................                AutoAckDelayTime = AutoAckTime ; 
....................             } 
....................  
....................             In.B15 = 1;                                 // setbit in1 
....................             if(FlashingFlag == 0) 
....................             { 
....................                Output.B15 = 0;           //Flash output1 
....................             } 
....................             else 
....................             { 
....................                Output.B15 = 1; 
....................             } 
....................  
....................             if (~AutoTestFlag) 
....................             { 
....................                if(OutputBoth.B15 == 0)                  //Both output 
....................                { 
....................                   output_bit(Pbuzzer,1);   //Buzzer 
....................                   output_bit(Pbell,1);     //Bell 
....................                } 
....................                else 
....................                { 
....................                   if(OutputType.B15 == 1) output_bit(Pbuzzer,1);     //Buzzer 
....................                   else output_bit(Pbell,1);                          //Bell 
....................                } 
....................             } 
....................           } 
....................  
....................       } 
....................       else if(FaultType.B15 == 1) Ack.B15 = 0; 
....................    } 
....................    else  //Indicator Function 
....................    { 
....................       if((Inputt.B15 ^ InputType.B15) == 1) 
....................       { 
....................          Output.B15 = 0; 
....................       } 
....................       else 
....................       { 
....................          Output.B15 = 1; 
....................       } 
....................    } 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //input16 
....................    if(AlarmIndicator.B16 == 1)    // Alarm Function 
....................    { 
....................       if((((Inputt.B16 ^ InputType.B16) == 1) && (FaultType.B16 == 1))|| In.B16 == 1)    // alarm1 occure and "Lock type" 
....................       //if(Inputt.B16 == 0) 
....................       { 
....................          if(Ack.B16 == 0) 
....................          { 
....................             if(In.B16 == 0 && AutoAck == 0x0F)   //use auto acknowlegde 
....................             { 
....................                TimeBase1s = 100 ;            //reload again 
....................                AutoAckDelayTime = AutoAckTime ; 
....................             } 
....................  
....................             In.B16 = 1;                                 // setbit in1 
....................             if(FlashingFlag == 0) 
....................             { 
....................                Output.B16 = 0;           //Flash output1 
....................             } 
....................             else 
....................             { 
....................                Output.B16 = 1; 
....................             } 
....................  
....................  
....................             if (~AutoTestFlag) 
....................             { 
....................                if(OutputBoth.B16 == 0)                  //Both output 
....................                { 
....................                   output_bit(Pbuzzer,1);   //Buzzer 
....................                   output_bit(Pbell,1);     //Bell 
....................                } 
....................                else 
....................                { 
....................                   if(OutputType.B16 == 1) output_bit(Pbuzzer,1);     //Buzzer 
....................                   else output_bit(Pbell,1);                          //Bell 
....................                } 
....................             } 
....................           } 
....................  
....................       } 
....................       else if(FaultType.B16 == 1) Ack.B16 = 0; 
....................    } 
....................    else  //Indicator Function 
....................    { 
....................       if((Inputt.B16 ^ InputType.B16) == 1) 
....................       { 
....................          Output.B16 = 0; 
....................       } 
....................       else 
....................       { 
....................          Output.B16 = 1; 
....................       } 
....................    } 
.................... //} 
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //input17 
....................     
....................    if(AlarmIndicator.B17 == 1)    // Alarm Function 
....................    { 
....................       if((((Inputt.B17 ^ InputType.B17) == 1) && (FaultType.B17 == 1))|| In.B17 == 1)    // alarm1 occure and "Lock type" 
....................       //if(Inputt.B17 == 0) 
....................       { 
....................          if(Ack.B17 == 0) 
....................          { 
....................             if(In.B17 == 0 && AutoAck == 0x0F)   //use auto acknowlegde 
....................             { 
....................                TimeBase1s = 100 ;            //reload again 
....................                AutoAckDelayTime = AutoAckTime ; 
....................             } 
....................  
....................             In.B17 = 1;                                 // setbit in1 
....................             if(FlashingFlag == 0) 
....................             { 
....................                Output.B17 = 0;           //Flash output1 
....................             } 
....................             else 
....................             { 
....................                Output.B17 = 1; 
....................             } 
....................  
....................  
....................             if (~AutoTestFlag) 
....................             { 
....................                if(OutputBoth.B17 == 0)                  //Both output 
....................                { 
....................                   output_bit(Pbuzzer,1);   //Buzzer 
....................                   output_bit(Pbell,1);     //Bell 
....................                } 
....................                else 
....................                { 
....................                   if(OutputType.B17 == 1) output_bit(Pbuzzer,1);     //Buzzer 
....................                   else output_bit(Pbell,1);                          //Bell 
....................                } 
....................             } 
....................           } 
....................  
....................       } 
....................       else if(FaultType.B17 == 1) Ack.B17 = 0; 
....................    } 
....................    else  //Indicator Function 
....................    { 
....................       if((Inputt.B17 ^ InputType.B17) == 1) 
....................       { 
....................          Output.B17 = 0; 
....................       } 
....................       else 
....................       { 
....................          Output.B17 = 1; 
....................       } 
....................    } 
.................... //} 
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
....................  
.................... //input18 
....................    if(AlarmIndicator.B18 == 1)    // Alarm Function 
....................    { 
....................       if((((Inputt.B18 ^ InputType.B18) == 1) && (FaultType.B18 == 1))|| In.B18 == 1)    // alarm1 occure and "Lock type" 
....................       //if(Inputt.B18 == 0) 
....................       { 
....................          if(Ack.B18 == 0) 
....................          { 
....................             if(In.B18 == 0 && AutoAck == 0x0F)   //use auto acknowlegde 
....................             { 
....................                TimeBase1s = 100 ;            //reload again 
....................                AutoAckDelayTime = AutoAckTime ; 
....................             } 
....................  
....................             In.B18 = 1;                                 // setbit in1 
....................             if(FlashingFlag == 0) 
....................             { 
....................                Output.B18 = 0;           //Flash output1 
....................             } 
....................             else 
....................             { 
....................                Output.B18 = 1; 
....................             } 
....................  
....................  
....................             if (~AutoTestFlag) 
....................             { 
....................                if(OutputBoth.B18 == 0)                  //Both output 
....................                { 
....................                   output_bit(Pbuzzer,1);   //Buzzer 
....................                   output_bit(Pbell,1);     //Bell 
....................                } 
....................                else 
....................                { 
....................                   if(OutputType.B18 == 1) output_bit(Pbuzzer,1);     //Buzzer 
....................                   else output_bit(Pbell,1);                          //Bell 
....................                } 
....................             } 
....................           } 
....................  
....................       } 
....................       else if(FaultType.B18 == 1) Ack.B18 = 0; 
....................    } 
....................    else  //Indicator Function 
....................    { 
....................       if((Inputt.B18 ^ InputType.B18) == 1) 
....................       { 
....................          Output.B18 = 0; 
....................       } 
....................       else 
....................       { 
....................          Output.B18 = 1; 
....................       } 
....................    } 
.................... //} 
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //input19 
....................    if(AlarmIndicator.B19 == 1)    // Alarm Function 
....................    { 
....................       if((((Inputt.B19 ^ InputType.B19) == 1) && (FaultType.B19 == 1))|| In.B19 == 1)    // alarm1 occure and "Lock type" 
....................       //if(Inputt.B19 == 0) 
....................       { 
....................          if(Ack.B19 == 0) 
....................          { 
....................             if(In.B19 == 0 && AutoAck == 0x0F)   //use auto acknowlegde 
....................             { 
....................                TimeBase1s = 100 ;            //reload again 
....................                AutoAckDelayTime = AutoAckTime ; 
....................             } 
....................  
....................             In.B19 = 1;                                 // setbit in1 
....................             if(FlashingFlag == 0) 
....................             { 
....................                Output.B19 = 0;           //Flash output1 
....................             } 
....................             else 
....................             { 
....................                Output.B19 = 1; 
....................             } 
....................  
....................  
....................             if (~AutoTestFlag) 
....................             { 
....................                if(OutputBoth.B19 == 0)                  //Both output 
....................                { 
....................                   output_bit(Pbuzzer,1);   //Buzzer 
....................                   output_bit(Pbell,1);     //Bell 
....................                } 
....................                else 
....................                { 
....................                   if(OutputType.B19 == 1) output_bit(Pbuzzer,1);     //Buzzer 
....................                   else output_bit(Pbell,1);                          //Bell 
....................                } 
....................             } 
....................           } 
....................  
....................       } 
....................       else if(FaultType.B19 == 1) Ack.B19 = 0; 
....................    } 
....................    else  //Indicator Function 
....................    { 
....................       if((Inputt.B19 ^ InputType.B19) == 1) 
....................       { 
....................          Output.B19 = 0; 
....................       } 
....................       else 
....................       { 
....................          Output.B19 = 1; 
....................       } 
....................    } 
.................... //} 
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //input20 
....................    if(AlarmIndicator.B20 == 1)    // Alarm Function 
....................    { 
....................       if((((Inputt.B20 ^ InputType.B20) == 1) && (FaultType.B20 == 1))|| In.B20 == 1)    // alarm1 occure and "Lock type" 
....................       //if(Inputt.B18 == 0) 
....................       { 
....................          if(Ack.B20 == 0) 
....................          { 
....................             if(In.B20 == 0 && AutoAck == 0x0F)   //use auto acknowlegde 
....................             { 
....................                TimeBase1s = 100 ;            //reload again 
....................                AutoAckDelayTime = AutoAckTime ; 
....................             } 
....................  
....................             In.B20 = 1;                                 // setbit in1 
....................             if(FlashingFlag == 0) 
....................             { 
....................                Output.B20 = 0;           //Flash output1 
....................             } 
....................             else 
....................             { 
....................                Output.B20 = 1; 
....................             } 
....................  
....................  
....................             if (~AutoTestFlag) 
....................             { 
....................                if(OutputBoth.B20 == 0)                  //Both output 
....................                { 
....................                   output_bit(Pbuzzer,1);   //Buzzer 
....................                   output_bit(Pbell,1);     //Bell 
....................                } 
....................                else 
....................                { 
....................                   if(OutputType.B20 == 1) output_bit(Pbuzzer,1);     //Buzzer 
....................                   else output_bit(Pbell,1);                          //Bell 
....................                } 
....................             } 
....................           } 
....................  
....................       } 
....................       else if(FaultType.B20 == 1) Ack.B20 = 0; 
....................    } 
....................    else  //Indicator Function 
....................    { 
....................       if((Inputt.B20 ^ InputType.B20) == 1) 
....................       { 
....................          Output.B20 = 0; 
....................       } 
....................       else 
....................       { 
....................          Output.B20 = 1; 
....................       } 
....................    } 
....................    */ 
.................... //} 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... /////////////////////////////////////////////////////////////////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////////////////// 
.................... /////////////////////////// END MANUAL RESET ////////////////////////////////////////// 
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... ////////////////////////////// AUTO RESET /////////////////////////////////// 
.................... ///////////////////////////////////////////////////////////////////////////// 
....................  
.................... //if(NoOfPoint >= 10) 
.................... //{ 
....................  
.................... static unsigned char inputflag = 0; 
....................  
.................... //input1 
....................    if((((Inputt.B1 ^ InputType.B1) == 1) && (FaultType.B1 == 0))||Test_fault==1)    // alarm1 occure and " Non Lock type" 
3ED0:  MOVLW  00
3ED2:  BTFSC  x0A.0
3ED4:  MOVLW  01
3ED6:  MOVWF  xB3
3ED8:  MOVLW  00
3EDA:  BTFSC  x0E.0
3EDC:  MOVLW  01
3EDE:  XORWF  xB3,W
3EE0:  SUBLW  01
3EE2:  BNZ   3EE8
3EE4:  BTFSS  x10.0
3EE6:  BRA    3EEC
3EE8:  BTFSS  17.5
3EEA:  BRA    3F38
....................    { 
....................       if(In2.B1 == 0 && AutoAck == 0x0F && Ack.B1 == 0)   //use auto acknowlegde 
3EEC:  BTFSC  x1C.0
3EEE:  BRA    3F02
3EF0:  MOVF   5B,W
3EF2:  SUBLW  0F
3EF4:  BNZ   3F02
3EF6:  BTFSC  x18.0
3EF8:  BRA    3F02
....................       { 
....................             TimeBase1s = 100 ;            //reload again 
3EFA:  MOVLW  64
3EFC:  MOVWF  19
....................             AutoAckDelayTime = AutoAckTime ; 
3EFE:  MOVFF  5C,1A
....................       } 
....................  
....................       In2.B1 = 1; 
3F02:  BSF    x1C.0
....................       if(Ack.B1 == 0) 
3F04:  BTFSC  x18.0
3F06:  BRA    3F32
....................       { 
....................          if(FlashingFlag == 0) 
3F08:  BTFSC  17.1
3F0A:  BRA    3F10
....................          { 
....................             Output.B1 = 0;           //Flash output1 
3F0C:  BCF    x0C.0
....................          } 
....................          else 
3F0E:  BRA    3F12
....................          { 
....................             Output.B1 = 1; 
3F10:  BSF    x0C.0
....................          } 
....................          if (~AutoTestFlag) 
3F12:  BTFSC  17.4
3F14:  BRA    3F32
....................          { 
....................              if(OutputBoth.B1 == 0)        //Both output 
3F16:  BTFSC  x14.0
3F18:  BRA    3F24
....................              { 
....................                output_bit(Pbuzzer,1);   //Buzzer 
3F1A:  BSF    F89.4
3F1C:  BCF    F92.4
....................                output_bit(Pbell,1);     //Bell 
3F1E:  BSF    F89.3
3F20:  BCF    F92.3
....................              } 
....................              else 
3F22:  BRA    3F32
....................              { 
....................                if(OutputType.B1 == 1) output_bit(Pbuzzer,1);     //Buzzer 
3F24:  BTFSS  x12.0
3F26:  BRA    3F2E
3F28:  BSF    F89.4
3F2A:  BCF    F92.4
....................                else output_bit(Pbell,1);                          //Bell 
3F2C:  BRA    3F32
3F2E:  BSF    F89.3
3F30:  BCF    F92.3
....................              } 
....................          } 
....................        } 
....................       inputflag =1; 
3F32:  MOVLW  01
3F34:  MOVWF  xA8
....................    } 
....................    else if(FaultType.B1 == 0) 
3F36:  BRA    3FB6
3F38:  BTFSC  x10.0
3F3A:  BRA    3FB6
....................    { 
....................       In2.B1 = 0x00; 
3F3C:  BCF    x1C.0
....................       Ack.B1 = 0; 
3F3E:  BCF    x18.0
....................       Output.B1 = 1;      //Off LED 
3F40:  BSF    x0C.0
....................  
....................       if((OutputType.B1 == 1 || OutputBoth.B1 == 0)&& inputflag ==0)       //If Buzzer or Both 
3F42:  BTFSC  x12.0
3F44:  BRA    3F4A
3F46:  BTFSC  x14.0
3F48:  BRA    3F64
3F4A:  MOVF   xA8,F
3F4C:  BNZ   3F64
....................       { 
....................          if(CheckAutoReset(0x01) == 1);   //Check other Input "Ack" or not if not,do nothing 
3F4E:  MOVLW  01
3F50:  MOVWF  xB3
3F52:  MOVLB  0
3F54:  CALL   3516
3F58:  DECFSZ 01,W
3F5A:  BRA    3F5E
....................          else 
3F5C:  BRA    3F62
....................          { 
....................             output_bit(Pbuzzer,0);   //Clear Buzzer 
3F5E:  BCF    F89.4
3F60:  BCF    F92.4
3F62:  MOVLB  1
....................          } 
....................       } 
....................  
....................  
....................       if((OutputType.B1 == 0 || OutputBoth.B1 == 0)&& inputflag ==0)   //If Bell or Both 
3F64:  BTFSS  x12.0
3F66:  BRA    3F6C
3F68:  BTFSC  x14.0
3F6A:  BRA    3F86
3F6C:  MOVF   xA8,F
3F6E:  BNZ   3F86
....................       { 
....................          if(CheckAutoReset(0x02) == 1); 
3F70:  MOVLW  02
3F72:  MOVWF  xB3
3F74:  MOVLB  0
3F76:  CALL   3516
3F7A:  DECFSZ 01,W
3F7C:  BRA    3F80
....................          else 
3F7E:  BRA    3F84
....................          { 
....................             output_bit(Pbell,0);      //Clear Bell 
3F80:  BCF    F89.3
3F82:  BCF    F92.3
3F84:  MOVLB  1
....................          } 
....................       } 
....................       // jj modify 
....................       if(In2.B1 ==0 && In2.B2 ==0 && In2.B3 ==0 && In2.B4 ==0 && In2.B5 ==0 && In2.B6 ==0 && In2.B7 ==0 && In2.B8 ==0 && In2.B9 ==0 && In2.B10 ==0) 
3F86:  BTFSC  x1C.0
3F88:  BRA    3FB6
3F8A:  BTFSC  x1C.1
3F8C:  BRA    3FB6
3F8E:  BTFSC  x1C.2
3F90:  BRA    3FB6
3F92:  BTFSC  x1C.3
3F94:  BRA    3FB6
3F96:  BTFSC  x1C.4
3F98:  BRA    3FB6
3F9A:  BTFSC  x1C.5
3F9C:  BRA    3FB6
3F9E:  BTFSC  x1C.6
3FA0:  BRA    3FB6
3FA2:  BTFSC  x1C.7
3FA4:  BRA    3FB6
3FA6:  BTFSC  x1D.0
3FA8:  BRA    3FB6
3FAA:  BTFSC  x1D.1
3FAC:  BRA    3FB6
....................       { 
....................          output_bit(Pbell,0);      //Clear Bell 
3FAE:  BCF    F89.3
3FB0:  BCF    F92.3
....................          output_bit(Pbuzzer,0);   //Clear Buzzer 
3FB2:  BCF    F89.4
3FB4:  BCF    F92.4
....................       } 
....................    } 
....................    //////////////////////////////////////////////////////////////////////////////////////////////////// 
.................... //input2 
....................    if((((Inputt.B2 ^ InputType.B2) == 1) && (FaultType.B2 == 0))||Test_fault==1)    // alarm1 occure and " Non Lock type" 
3FB6:  MOVLW  00
3FB8:  BTFSC  x0A.1
3FBA:  MOVLW  01
3FBC:  MOVWF  xB3
3FBE:  MOVLW  00
3FC0:  BTFSC  x0E.1
3FC2:  MOVLW  01
3FC4:  XORWF  xB3,W
3FC6:  SUBLW  01
3FC8:  BNZ   3FCE
3FCA:  BTFSS  x10.1
3FCC:  BRA    3FD2
3FCE:  BTFSS  17.5
3FD0:  BRA    401E
....................    { 
....................       if(In2.B2 == 0 && AutoAck == 0x0F && Ack.B2 == 0)   //use auto acknowlegde 
3FD2:  BTFSC  x1C.1
3FD4:  BRA    3FE8
3FD6:  MOVF   5B,W
3FD8:  SUBLW  0F
3FDA:  BNZ   3FE8
3FDC:  BTFSC  x18.1
3FDE:  BRA    3FE8
....................       { 
....................             TimeBase1s = 100 ;            //reload again 
3FE0:  MOVLW  64
3FE2:  MOVWF  19
....................             AutoAckDelayTime = AutoAckTime ; 
3FE4:  MOVFF  5C,1A
....................       } 
....................  
....................       In2.B2 = 1; 
3FE8:  BSF    x1C.1
....................       if(Ack.B2 == 0) 
3FEA:  BTFSC  x18.1
3FEC:  BRA    4018
....................       { 
....................          if(FlashingFlag == 0) 
3FEE:  BTFSC  17.1
3FF0:  BRA    3FF6
....................             { 
....................                Output.B2 = 0;           //Flash output1 
3FF2:  BCF    x0C.1
....................             } 
....................             else 
3FF4:  BRA    3FF8
....................             { 
....................                Output.B2 = 1; 
3FF6:  BSF    x0C.1
....................             } 
....................          if (~AutoTestFlag) 
3FF8:  BTFSC  17.4
3FFA:  BRA    4018
....................          { 
....................              if(OutputBoth.B2 == 0)        //Both output 
3FFC:  BTFSC  x14.1
3FFE:  BRA    400A
....................              { 
....................                output_bit(Pbuzzer,1);   //Buzzer 
4000:  BSF    F89.4
4002:  BCF    F92.4
....................                output_bit(Pbell,1);     //Bell 
4004:  BSF    F89.3
4006:  BCF    F92.3
....................              } 
....................              else 
4008:  BRA    4018
....................              { 
....................                if(OutputType.B2 == 1) output_bit(Pbuzzer,1);     //Buzzer 
400A:  BTFSS  x12.1
400C:  BRA    4014
400E:  BSF    F89.4
4010:  BCF    F92.4
....................                else output_bit(Pbell,1);                          //Bell 
4012:  BRA    4018
4014:  BSF    F89.3
4016:  BCF    F92.3
....................              } 
....................          } 
....................        } 
....................       inputflag =1; 
4018:  MOVLW  01
401A:  MOVWF  xA8
....................    } 
....................    else if(FaultType.B2 == 0) 
401C:  BRA    409C
401E:  BTFSC  x10.1
4020:  BRA    409C
....................    { 
....................       In2.B2 = 0x00; 
4022:  BCF    x1C.1
....................       Ack.B2 = 0; 
4024:  BCF    x18.1
....................       Output.B2 = 1;      //Off LED 
4026:  BSF    x0C.1
....................  
....................       if((OutputType.B2 == 1 || OutputBoth.B2 == 0)&& inputflag ==0)       //If Buzzer or Both 
4028:  BTFSC  x12.1
402A:  BRA    4030
402C:  BTFSC  x14.1
402E:  BRA    404A
4030:  MOVF   xA8,F
4032:  BNZ   404A
....................       { 
....................          if(CheckAutoReset(0x01) == 1);   //Check other Input "Ack" or not if not,do nothing 
4034:  MOVLW  01
4036:  MOVWF  xB3
4038:  MOVLB  0
403A:  CALL   3516
403E:  DECFSZ 01,W
4040:  BRA    4044
....................          else 
4042:  BRA    4048
....................          { 
....................             output_bit(Pbuzzer,0);   //Clear Buzzer 
4044:  BCF    F89.4
4046:  BCF    F92.4
4048:  MOVLB  1
....................          } 
....................       } 
....................  
....................  
....................       if((OutputType.B2 == 0 || OutputBoth.B2 == 0)&& inputflag ==0)   //If Bell or Both 
404A:  BTFSS  x12.1
404C:  BRA    4052
404E:  BTFSC  x14.1
4050:  BRA    406C
4052:  MOVF   xA8,F
4054:  BNZ   406C
....................       { 
....................          if(CheckAutoReset(0x02) == 1); 
4056:  MOVLW  02
4058:  MOVWF  xB3
405A:  MOVLB  0
405C:  CALL   3516
4060:  DECFSZ 01,W
4062:  BRA    4066
....................          else 
4064:  BRA    406A
....................          { 
....................             output_bit(Pbell,0);      //Clear Bell 
4066:  BCF    F89.3
4068:  BCF    F92.3
406A:  MOVLB  1
....................          } 
....................       } 
....................       // jj modify 
....................       if(In2.B1 ==0 && In2.B2 ==0 && In2.B3 ==0 && In2.B4 ==0 && In2.B5 ==0 && In2.B6 ==0 && In2.B7 ==0 && In2.B8 ==0 && In2.B9 ==0 && In2.B10 ==0) 
406C:  BTFSC  x1C.0
406E:  BRA    409C
4070:  BTFSC  x1C.1
4072:  BRA    409C
4074:  BTFSC  x1C.2
4076:  BRA    409C
4078:  BTFSC  x1C.3
407A:  BRA    409C
407C:  BTFSC  x1C.4
407E:  BRA    409C
4080:  BTFSC  x1C.5
4082:  BRA    409C
4084:  BTFSC  x1C.6
4086:  BRA    409C
4088:  BTFSC  x1C.7
408A:  BRA    409C
408C:  BTFSC  x1D.0
408E:  BRA    409C
4090:  BTFSC  x1D.1
4092:  BRA    409C
....................       { 
....................          output_bit(Pbell,0);      //Clear Bell 
4094:  BCF    F89.3
4096:  BCF    F92.3
....................          output_bit(Pbuzzer,0);   //Clear Buzzer 
4098:  BCF    F89.4
409A:  BCF    F92.4
....................       } 
....................    } 
....................    //////////////////////////////////////////////////////////////////////////////////////////////////// 
.................... //input3 
....................    if((((Inputt.B3 ^ InputType.B3) == 1) && (FaultType.B3 == 0))||Test_fault==1)    // alarm1 occure and " Non Lock type" 
409C:  MOVLW  00
409E:  BTFSC  x0A.2
40A0:  MOVLW  01
40A2:  MOVWF  xB3
40A4:  MOVLW  00
40A6:  BTFSC  x0E.2
40A8:  MOVLW  01
40AA:  XORWF  xB3,W
40AC:  SUBLW  01
40AE:  BNZ   40B4
40B0:  BTFSS  x10.2
40B2:  BRA    40B8
40B4:  BTFSS  17.5
40B6:  BRA    4104
....................    { 
....................       if(In2.B3 == 0 && AutoAck == 0x0F && Ack.B3 == 0)   //use auto acknowlegde 
40B8:  BTFSC  x1C.2
40BA:  BRA    40CE
40BC:  MOVF   5B,W
40BE:  SUBLW  0F
40C0:  BNZ   40CE
40C2:  BTFSC  x18.2
40C4:  BRA    40CE
....................       { 
....................             TimeBase1s = 100 ;            //reload again 
40C6:  MOVLW  64
40C8:  MOVWF  19
....................             AutoAckDelayTime = AutoAckTime ; 
40CA:  MOVFF  5C,1A
....................       } 
....................  
....................       In2.B3 = 1; 
40CE:  BSF    x1C.2
....................       if(Ack.B3 == 0) 
40D0:  BTFSC  x18.2
40D2:  BRA    40FE
....................       { 
....................          if(FlashingFlag == 0) 
40D4:  BTFSC  17.1
40D6:  BRA    40DC
....................             { 
....................                Output.B3 = 0;           //Flash output1 
40D8:  BCF    x0C.2
....................             } 
....................             else 
40DA:  BRA    40DE
....................             { 
....................                Output.B3 = 1; 
40DC:  BSF    x0C.2
....................             } 
....................          if (~AutoTestFlag) 
40DE:  BTFSC  17.4
40E0:  BRA    40FE
....................          { 
....................              if(OutputBoth.B3 == 0)        //Both output 
40E2:  BTFSC  x14.2
40E4:  BRA    40F0
....................              { 
....................                output_bit(Pbuzzer,1);   //Buzzer 
40E6:  BSF    F89.4
40E8:  BCF    F92.4
....................                output_bit(Pbell,1);     //Bell 
40EA:  BSF    F89.3
40EC:  BCF    F92.3
....................              } 
....................              else 
40EE:  BRA    40FE
....................              { 
....................                if(OutputType.B3 == 1) output_bit(Pbuzzer,1);     //Buzzer 
40F0:  BTFSS  x12.2
40F2:  BRA    40FA
40F4:  BSF    F89.4
40F6:  BCF    F92.4
....................                else output_bit(Pbell,1);                          //Bell 
40F8:  BRA    40FE
40FA:  BSF    F89.3
40FC:  BCF    F92.3
....................              } 
....................          } 
....................        } 
....................       inputflag =1; 
40FE:  MOVLW  01
4100:  MOVWF  xA8
....................    } 
....................    else if(FaultType.B3 == 0) 
4102:  BRA    4182
4104:  BTFSC  x10.2
4106:  BRA    4182
....................    { 
....................       In2.B3 = 0x00; 
4108:  BCF    x1C.2
....................       Ack.B3 = 0; 
410A:  BCF    x18.2
....................       Output.B3 = 1;      //Off LED 
410C:  BSF    x0C.2
....................  
....................       if((OutputType.B3 == 1 || OutputBoth.B3 == 0)&& inputflag ==0)       //If Buzzer or Both 
410E:  BTFSC  x12.2
4110:  BRA    4116
4112:  BTFSC  x14.2
4114:  BRA    4130
4116:  MOVF   xA8,F
4118:  BNZ   4130
....................       { 
....................          if(CheckAutoReset(0x01) == 1);   //Check other Input "Ack" or not if not,do nothing 
411A:  MOVLW  01
411C:  MOVWF  xB3
411E:  MOVLB  0
4120:  CALL   3516
4124:  DECFSZ 01,W
4126:  BRA    412A
....................          else 
4128:  BRA    412E
....................          { 
....................             output_bit(Pbuzzer,0);   //Clear Buzzer 
412A:  BCF    F89.4
412C:  BCF    F92.4
412E:  MOVLB  1
....................          } 
....................       } 
....................  
....................  
....................       if((OutputType.B3 == 0 || OutputBoth.B3 == 0)&& inputflag ==0)   //If Bell or Both 
4130:  BTFSS  x12.2
4132:  BRA    4138
4134:  BTFSC  x14.2
4136:  BRA    4152
4138:  MOVF   xA8,F
413A:  BNZ   4152
....................       { 
....................          if(CheckAutoReset(0x02) == 1); 
413C:  MOVLW  02
413E:  MOVWF  xB3
4140:  MOVLB  0
4142:  CALL   3516
4146:  DECFSZ 01,W
4148:  BRA    414C
....................          else 
414A:  BRA    4150
....................          { 
....................             output_bit(Pbell,0);      //Clear Bell 
414C:  BCF    F89.3
414E:  BCF    F92.3
4150:  MOVLB  1
....................          } 
....................       } 
....................       // jj modify 
....................       if(In2.B1 ==0 && In2.B2 ==0 && In2.B3 ==0 && In2.B4 ==0 && In2.B5 ==0 && In2.B6 ==0 && In2.B7 ==0 && In2.B8 ==0 && In2.B9 ==0 && In2.B10 ==0) 
4152:  BTFSC  x1C.0
4154:  BRA    4182
4156:  BTFSC  x1C.1
4158:  BRA    4182
415A:  BTFSC  x1C.2
415C:  BRA    4182
415E:  BTFSC  x1C.3
4160:  BRA    4182
4162:  BTFSC  x1C.4
4164:  BRA    4182
4166:  BTFSC  x1C.5
4168:  BRA    4182
416A:  BTFSC  x1C.6
416C:  BRA    4182
416E:  BTFSC  x1C.7
4170:  BRA    4182
4172:  BTFSC  x1D.0
4174:  BRA    4182
4176:  BTFSC  x1D.1
4178:  BRA    4182
....................       { 
....................          output_bit(Pbell,0);      //Clear Bell 
417A:  BCF    F89.3
417C:  BCF    F92.3
....................          output_bit(Pbuzzer,0);   //Clear Buzzer 
417E:  BCF    F89.4
4180:  BCF    F92.4
....................       } 
....................    } 
....................    //////////////////////////////////////////////////////////////////////////////////////////////////// 
.................... //input4 
....................    if((((Inputt.B4 ^ InputType.B4) == 1) && (FaultType.B4 == 0))||Test_fault==1)    // alarm1 occure and " Non Lock type" 
4182:  MOVLW  00
4184:  BTFSC  x0A.3
4186:  MOVLW  01
4188:  MOVWF  xB3
418A:  MOVLW  00
418C:  BTFSC  x0E.3
418E:  MOVLW  01
4190:  XORWF  xB3,W
4192:  SUBLW  01
4194:  BNZ   419A
4196:  BTFSS  x10.3
4198:  BRA    419E
419A:  BTFSS  17.5
419C:  BRA    41EA
....................    { 
....................       if(In2.B4 == 0 && AutoAck == 0x0F && Ack.B4 == 0)   //use auto acknowlegde 
419E:  BTFSC  x1C.3
41A0:  BRA    41B4
41A2:  MOVF   5B,W
41A4:  SUBLW  0F
41A6:  BNZ   41B4
41A8:  BTFSC  x18.3
41AA:  BRA    41B4
....................       { 
....................             TimeBase1s = 100 ;            //reload again 
41AC:  MOVLW  64
41AE:  MOVWF  19
....................             AutoAckDelayTime = AutoAckTime ; 
41B0:  MOVFF  5C,1A
....................       } 
....................  
....................       In2.B4 = 1; 
41B4:  BSF    x1C.3
....................       if(Ack.B4 == 0) 
41B6:  BTFSC  x18.3
41B8:  BRA    41E4
....................       { 
....................          if(FlashingFlag == 0) 
41BA:  BTFSC  17.1
41BC:  BRA    41C2
....................             { 
....................                Output.B4 = 0;           //Flash output1 
41BE:  BCF    x0C.3
....................             } 
....................             else 
41C0:  BRA    41C4
....................             { 
....................                Output.B4 = 1; 
41C2:  BSF    x0C.3
....................             } 
....................          if (~AutoTestFlag) 
41C4:  BTFSC  17.4
41C6:  BRA    41E4
....................          { 
....................              if(OutputBoth.B4 == 0)        //Both output 
41C8:  BTFSC  x14.3
41CA:  BRA    41D6
....................              { 
....................                output_bit(Pbuzzer,1);   //Buzzer 
41CC:  BSF    F89.4
41CE:  BCF    F92.4
....................                output_bit(Pbell,1);     //Bell 
41D0:  BSF    F89.3
41D2:  BCF    F92.3
....................              } 
....................              else 
41D4:  BRA    41E4
....................              { 
....................                if(OutputType.B4 == 1) output_bit(Pbuzzer,1);     //Buzzer 
41D6:  BTFSS  x12.3
41D8:  BRA    41E0
41DA:  BSF    F89.4
41DC:  BCF    F92.4
....................                else output_bit(Pbell,1);                          //Bell 
41DE:  BRA    41E4
41E0:  BSF    F89.3
41E2:  BCF    F92.3
....................              } 
....................          } 
....................        } 
....................       inputflag =1; 
41E4:  MOVLW  01
41E6:  MOVWF  xA8
....................    } 
....................    else if(FaultType.B4 == 0) 
41E8:  BRA    4268
41EA:  BTFSC  x10.3
41EC:  BRA    4268
....................    { 
....................       In2.B4 = 0x00; 
41EE:  BCF    x1C.3
....................       Ack.B4 = 0; 
41F0:  BCF    x18.3
....................       Output.B4 = 1;      //Off LED 
41F2:  BSF    x0C.3
....................  
....................       if((OutputType.B4 == 1 || OutputBoth.B4 == 0)&& inputflag ==0)       //If Buzzer or Both 
41F4:  BTFSC  x12.3
41F6:  BRA    41FC
41F8:  BTFSC  x14.3
41FA:  BRA    4216
41FC:  MOVF   xA8,F
41FE:  BNZ   4216
....................       { 
....................          if(CheckAutoReset(0x01) == 1);   //Check other Input "Ack" or not if not,do nothing 
4200:  MOVLW  01
4202:  MOVWF  xB3
4204:  MOVLB  0
4206:  CALL   3516
420A:  DECFSZ 01,W
420C:  BRA    4210
....................          else 
420E:  BRA    4214
....................          { 
....................             output_bit(Pbuzzer,0);   //Clear Buzzer 
4210:  BCF    F89.4
4212:  BCF    F92.4
4214:  MOVLB  1
....................          } 
....................       } 
....................  
....................  
....................       if((OutputType.B4 == 0 || OutputBoth.B4 == 0)&& inputflag ==0)   //If Bell or Both 
4216:  BTFSS  x12.3
4218:  BRA    421E
421A:  BTFSC  x14.3
421C:  BRA    4238
421E:  MOVF   xA8,F
4220:  BNZ   4238
....................       { 
....................          if(CheckAutoReset(0x02) == 1); 
4222:  MOVLW  02
4224:  MOVWF  xB3
4226:  MOVLB  0
4228:  CALL   3516
422C:  DECFSZ 01,W
422E:  BRA    4232
....................          else 
4230:  BRA    4236
....................          { 
....................             output_bit(Pbell,0);      //Clear Bell 
4232:  BCF    F89.3
4234:  BCF    F92.3
4236:  MOVLB  1
....................          } 
....................       } 
....................       // jj modify 
....................       if(In2.B1 ==0 && In2.B2 ==0 && In2.B3 ==0 && In2.B4 ==0 && In2.B5 ==0 && In2.B6 ==0 && In2.B7 ==0 && In2.B8 ==0 && In2.B9 ==0 && In2.B10 ==0) 
4238:  BTFSC  x1C.0
423A:  BRA    4268
423C:  BTFSC  x1C.1
423E:  BRA    4268
4240:  BTFSC  x1C.2
4242:  BRA    4268
4244:  BTFSC  x1C.3
4246:  BRA    4268
4248:  BTFSC  x1C.4
424A:  BRA    4268
424C:  BTFSC  x1C.5
424E:  BRA    4268
4250:  BTFSC  x1C.6
4252:  BRA    4268
4254:  BTFSC  x1C.7
4256:  BRA    4268
4258:  BTFSC  x1D.0
425A:  BRA    4268
425C:  BTFSC  x1D.1
425E:  BRA    4268
....................       { 
....................          output_bit(Pbell,0);      //Clear Bell 
4260:  BCF    F89.3
4262:  BCF    F92.3
....................          output_bit(Pbuzzer,0);   //Clear Buzzer 
4264:  BCF    F89.4
4266:  BCF    F92.4
....................       } 
....................    } 
....................    //////////////////////////////////////////////////////////////////////////////////////////////////// 
.................... //input5 
....................    if((((Inputt.B5 ^ InputType.B5) == 1) && (FaultType.B5 == 0))||Test_fault==1)    // alarm1 occure and " Non Lock type" 
4268:  MOVLW  00
426A:  BTFSC  x0A.4
426C:  MOVLW  01
426E:  MOVWF  xB3
4270:  MOVLW  00
4272:  BTFSC  x0E.4
4274:  MOVLW  01
4276:  XORWF  xB3,W
4278:  SUBLW  01
427A:  BNZ   4280
427C:  BTFSS  x10.4
427E:  BRA    4284
4280:  BTFSS  17.5
4282:  BRA    42D0
....................    { 
....................       if(In2.B5 == 0 && AutoAck == 0x0F && Ack.B5 == 0)   //use auto acknowlegde 
4284:  BTFSC  x1C.4
4286:  BRA    429A
4288:  MOVF   5B,W
428A:  SUBLW  0F
428C:  BNZ   429A
428E:  BTFSC  x18.4
4290:  BRA    429A
....................       { 
....................             TimeBase1s = 100 ;            //reload again 
4292:  MOVLW  64
4294:  MOVWF  19
....................             AutoAckDelayTime = AutoAckTime ; 
4296:  MOVFF  5C,1A
....................       } 
....................  
....................       In2.B5 = 1; 
429A:  BSF    x1C.4
....................       if(Ack.B5 == 0) 
429C:  BTFSC  x18.4
429E:  BRA    42CA
....................       { 
....................          if(FlashingFlag == 0) 
42A0:  BTFSC  17.1
42A2:  BRA    42A8
....................             { 
....................                Output.B5 = 0;           //Flash output1 
42A4:  BCF    x0C.4
....................             } 
....................             else 
42A6:  BRA    42AA
....................             { 
....................                Output.B5 = 1; 
42A8:  BSF    x0C.4
....................             } 
....................          if (~AutoTestFlag) 
42AA:  BTFSC  17.4
42AC:  BRA    42CA
....................          { 
....................              if(OutputBoth.B5 == 0)        //Both output 
42AE:  BTFSC  x14.4
42B0:  BRA    42BC
....................              { 
....................                output_bit(Pbuzzer,1);   //Buzzer 
42B2:  BSF    F89.4
42B4:  BCF    F92.4
....................                output_bit(Pbell,1);     //Bell 
42B6:  BSF    F89.3
42B8:  BCF    F92.3
....................              } 
....................              else 
42BA:  BRA    42CA
....................              { 
....................                if(OutputType.B5 == 1) output_bit(Pbuzzer,1);     //Buzzer 
42BC:  BTFSS  x12.4
42BE:  BRA    42C6
42C0:  BSF    F89.4
42C2:  BCF    F92.4
....................                else output_bit(Pbell,1);                          //Bell 
42C4:  BRA    42CA
42C6:  BSF    F89.3
42C8:  BCF    F92.3
....................              } 
....................          } 
....................        } 
....................       inputflag =1; 
42CA:  MOVLW  01
42CC:  MOVWF  xA8
....................    } 
....................    else if(FaultType.B5 == 0) 
42CE:  BRA    434E
42D0:  BTFSC  x10.4
42D2:  BRA    434E
....................    { 
....................       In2.B5 = 0x00; 
42D4:  BCF    x1C.4
....................       Ack.B5 = 0; 
42D6:  BCF    x18.4
....................       Output.B5 = 1;      //Off LED 
42D8:  BSF    x0C.4
....................  
....................       if((OutputType.B5 == 1 || OutputBoth.B5 == 0)&& inputflag ==0)       //If Buzzer or Both 
42DA:  BTFSC  x12.4
42DC:  BRA    42E2
42DE:  BTFSC  x14.4
42E0:  BRA    42FC
42E2:  MOVF   xA8,F
42E4:  BNZ   42FC
....................       { 
....................          if(CheckAutoReset(0x01) == 1);   //Check other Input "Ack" or not if not,do nothing 
42E6:  MOVLW  01
42E8:  MOVWF  xB3
42EA:  MOVLB  0
42EC:  CALL   3516
42F0:  DECFSZ 01,W
42F2:  BRA    42F6
....................          else 
42F4:  BRA    42FA
....................          { 
....................             output_bit(Pbuzzer,0);   //Clear Buzzer 
42F6:  BCF    F89.4
42F8:  BCF    F92.4
42FA:  MOVLB  1
....................          } 
....................       } 
....................  
....................  
....................       if((OutputType.B5 == 0 || OutputBoth.B5 == 0)&& inputflag ==0)   //If Bell or Both 
42FC:  BTFSS  x12.4
42FE:  BRA    4304
4300:  BTFSC  x14.4
4302:  BRA    431E
4304:  MOVF   xA8,F
4306:  BNZ   431E
....................       { 
....................          if(CheckAutoReset(0x02) == 1); 
4308:  MOVLW  02
430A:  MOVWF  xB3
430C:  MOVLB  0
430E:  CALL   3516
4312:  DECFSZ 01,W
4314:  BRA    4318
....................          else 
4316:  BRA    431C
....................          { 
....................             output_bit(Pbell,0);      //Clear Bell 
4318:  BCF    F89.3
431A:  BCF    F92.3
431C:  MOVLB  1
....................          } 
....................       } 
....................       // jj modify 
....................       if(In2.B1 ==0 && In2.B2 ==0 && In2.B3 ==0 && In2.B4 ==0 && In2.B5 ==0 && In2.B6 ==0 && In2.B7 ==0 && In2.B8 ==0 && In2.B9 ==0 && In2.B10 ==0) 
431E:  BTFSC  x1C.0
4320:  BRA    434E
4322:  BTFSC  x1C.1
4324:  BRA    434E
4326:  BTFSC  x1C.2
4328:  BRA    434E
432A:  BTFSC  x1C.3
432C:  BRA    434E
432E:  BTFSC  x1C.4
4330:  BRA    434E
4332:  BTFSC  x1C.5
4334:  BRA    434E
4336:  BTFSC  x1C.6
4338:  BRA    434E
433A:  BTFSC  x1C.7
433C:  BRA    434E
433E:  BTFSC  x1D.0
4340:  BRA    434E
4342:  BTFSC  x1D.1
4344:  BRA    434E
....................       { 
....................          output_bit(Pbell,0);      //Clear Bell 
4346:  BCF    F89.3
4348:  BCF    F92.3
....................          output_bit(Pbuzzer,0);   //Clear Buzzer 
434A:  BCF    F89.4
434C:  BCF    F92.4
....................       } 
....................    } 
....................    //////////////////////////////////////////////////////////////////////////////////////////////////// 
.................... //input6 
....................    if((((Inputt.B6 ^ InputType.B6) == 1) && (FaultType.B6 == 0))||Test_fault==1)    // alarm1 occure and " Non Lock type" 
434E:  MOVLW  00
4350:  BTFSC  x0A.5
4352:  MOVLW  01
4354:  MOVWF  xB3
4356:  MOVLW  00
4358:  BTFSC  x0E.5
435A:  MOVLW  01
435C:  XORWF  xB3,W
435E:  SUBLW  01
4360:  BNZ   4366
4362:  BTFSS  x10.5
4364:  BRA    436A
4366:  BTFSS  17.5
4368:  BRA    43B6
....................    { 
....................       if(In2.B6 == 0 && AutoAck == 0x0F && Ack.B6 == 0)   //use auto acknowlegde 
436A:  BTFSC  x1C.5
436C:  BRA    4380
436E:  MOVF   5B,W
4370:  SUBLW  0F
4372:  BNZ   4380
4374:  BTFSC  x18.5
4376:  BRA    4380
....................       { 
....................             TimeBase1s = 100 ;            //reload again 
4378:  MOVLW  64
437A:  MOVWF  19
....................             AutoAckDelayTime = AutoAckTime ; 
437C:  MOVFF  5C,1A
....................       } 
....................  
....................       In2.B6 = 1; 
4380:  BSF    x1C.5
....................       if(Ack.B6 == 0) 
4382:  BTFSC  x18.5
4384:  BRA    43B0
....................       { 
....................          if(FlashingFlag == 0) 
4386:  BTFSC  17.1
4388:  BRA    438E
....................             { 
....................                Output.B6 = 0;           //Flash output1 
438A:  BCF    x0C.5
....................             } 
....................             else 
438C:  BRA    4390
....................             { 
....................                Output.B6 = 1; 
438E:  BSF    x0C.5
....................             } 
....................          if (~AutoTestFlag) 
4390:  BTFSC  17.4
4392:  BRA    43B0
....................          { 
....................              if(OutputBoth.B6 == 0)        //Both output 
4394:  BTFSC  x14.5
4396:  BRA    43A2
....................              { 
....................                output_bit(Pbuzzer,1);   //Buzzer 
4398:  BSF    F89.4
439A:  BCF    F92.4
....................                output_bit(Pbell,1);     //Bell 
439C:  BSF    F89.3
439E:  BCF    F92.3
....................              } 
....................              else 
43A0:  BRA    43B0
....................              { 
....................                if(OutputType.B6 == 1) output_bit(Pbuzzer,1);     //Buzzer 
43A2:  BTFSS  x12.5
43A4:  BRA    43AC
43A6:  BSF    F89.4
43A8:  BCF    F92.4
....................                else output_bit(Pbell,1);                          //Bell 
43AA:  BRA    43B0
43AC:  BSF    F89.3
43AE:  BCF    F92.3
....................              } 
....................          } 
....................        } 
....................       inputflag =1; 
43B0:  MOVLW  01
43B2:  MOVWF  xA8
....................    } 
....................    else if(FaultType.B6 == 0) 
43B4:  BRA    4434
43B6:  BTFSC  x10.5
43B8:  BRA    4434
....................    { 
....................       In2.B6 = 0x00; 
43BA:  BCF    x1C.5
....................       Ack.B6 = 0; 
43BC:  BCF    x18.5
....................       Output.B6 = 1;      //Off LED 
43BE:  BSF    x0C.5
....................  
....................       if((OutputType.B6 == 1 || OutputBoth.B6 == 0)&& inputflag ==0)       //If Buzzer or Both 
43C0:  BTFSC  x12.5
43C2:  BRA    43C8
43C4:  BTFSC  x14.5
43C6:  BRA    43E2
43C8:  MOVF   xA8,F
43CA:  BNZ   43E2
....................       { 
....................          if(CheckAutoReset(0x01) == 1);   //Check other Input "Ack" or not if not,do nothing 
43CC:  MOVLW  01
43CE:  MOVWF  xB3
43D0:  MOVLB  0
43D2:  CALL   3516
43D6:  DECFSZ 01,W
43D8:  BRA    43DC
....................          else 
43DA:  BRA    43E0
....................          { 
....................             output_bit(Pbuzzer,0);   //Clear Buzzer 
43DC:  BCF    F89.4
43DE:  BCF    F92.4
43E0:  MOVLB  1
....................          } 
....................       } 
....................  
....................  
....................       if((OutputType.B6 == 0 || OutputBoth.B6 == 0)&& inputflag ==0)   //If Bell or Both 
43E2:  BTFSS  x12.5
43E4:  BRA    43EA
43E6:  BTFSC  x14.5
43E8:  BRA    4404
43EA:  MOVF   xA8,F
43EC:  BNZ   4404
....................       { 
....................          if(CheckAutoReset(0x02) == 1); 
43EE:  MOVLW  02
43F0:  MOVWF  xB3
43F2:  MOVLB  0
43F4:  CALL   3516
43F8:  DECFSZ 01,W
43FA:  BRA    43FE
....................          else 
43FC:  BRA    4402
....................          { 
....................             output_bit(Pbell,0);      //Clear Bell 
43FE:  BCF    F89.3
4400:  BCF    F92.3
4402:  MOVLB  1
....................          } 
....................       } 
....................       // jj modify 
....................       if(In2.B1 ==0 && In2.B2 ==0 && In2.B3 ==0 && In2.B4 ==0 && In2.B5 ==0 && In2.B6 ==0 && In2.B7 ==0 && In2.B8 ==0 && In2.B9 ==0 && In2.B10 ==0) 
4404:  BTFSC  x1C.0
4406:  BRA    4434
4408:  BTFSC  x1C.1
440A:  BRA    4434
440C:  BTFSC  x1C.2
440E:  BRA    4434
4410:  BTFSC  x1C.3
4412:  BRA    4434
4414:  BTFSC  x1C.4
4416:  BRA    4434
4418:  BTFSC  x1C.5
441A:  BRA    4434
441C:  BTFSC  x1C.6
441E:  BRA    4434
4420:  BTFSC  x1C.7
4422:  BRA    4434
4424:  BTFSC  x1D.0
4426:  BRA    4434
4428:  BTFSC  x1D.1
442A:  BRA    4434
....................       { 
....................          output_bit(Pbell,0);      //Clear Bell 
442C:  BCF    F89.3
442E:  BCF    F92.3
....................          output_bit(Pbuzzer,0);   //Clear Buzzer 
4430:  BCF    F89.4
4432:  BCF    F92.4
....................       } 
....................    } 
....................    //////////////////////////////////////////////////////////////////////////////////////////////////// 
.................... //input7 
....................    if((((Inputt.B7 ^ InputType.B7) == 1) && (FaultType.B7 == 0))||Test_fault==1)    // alarm1 occure and " Non Lock type" 
4434:  MOVLW  00
4436:  BTFSC  x0A.6
4438:  MOVLW  01
443A:  MOVWF  xB3
443C:  MOVLW  00
443E:  BTFSC  x0E.6
4440:  MOVLW  01
4442:  XORWF  xB3,W
4444:  SUBLW  01
4446:  BNZ   444C
4448:  BTFSS  x10.6
444A:  BRA    4450
444C:  BTFSS  17.5
444E:  BRA    449C
....................    { 
....................       if(In2.B7 == 0 && AutoAck == 0x0F && Ack.B7 == 0)   //use auto acknowlegde 
4450:  BTFSC  x1C.6
4452:  BRA    4466
4454:  MOVF   5B,W
4456:  SUBLW  0F
4458:  BNZ   4466
445A:  BTFSC  x18.6
445C:  BRA    4466
....................       { 
....................             TimeBase1s = 100 ;            //reload again 
445E:  MOVLW  64
4460:  MOVWF  19
....................             AutoAckDelayTime = AutoAckTime ; 
4462:  MOVFF  5C,1A
....................       } 
....................  
....................       In2.B7 = 1; 
4466:  BSF    x1C.6
....................       if(Ack.B7 == 0) 
4468:  BTFSC  x18.6
446A:  BRA    4496
....................       { 
....................          if(FlashingFlag == 0) 
446C:  BTFSC  17.1
446E:  BRA    4474
....................             { 
....................                Output.B7 = 0;           //Flash output1 
4470:  BCF    x0C.6
....................             } 
....................             else 
4472:  BRA    4476
....................             { 
....................                Output.B7 = 1; 
4474:  BSF    x0C.6
....................             } 
....................          if (~AutoTestFlag) 
4476:  BTFSC  17.4
4478:  BRA    4496
....................          { 
....................              if(OutputBoth.B7 == 0)        //Both output 
447A:  BTFSC  x14.6
447C:  BRA    4488
....................              { 
....................                output_bit(Pbuzzer,1);   //Buzzer 
447E:  BSF    F89.4
4480:  BCF    F92.4
....................                output_bit(Pbell,1);     //Bell 
4482:  BSF    F89.3
4484:  BCF    F92.3
....................              } 
....................              else 
4486:  BRA    4496
....................              { 
....................                if(OutputType.B7 == 1) output_bit(Pbuzzer,1);     //Buzzer 
4488:  BTFSS  x12.6
448A:  BRA    4492
448C:  BSF    F89.4
448E:  BCF    F92.4
....................                else output_bit(Pbell,1);                          //Bell 
4490:  BRA    4496
4492:  BSF    F89.3
4494:  BCF    F92.3
....................              } 
....................          } 
....................        } 
....................       inputflag =1; 
4496:  MOVLW  01
4498:  MOVWF  xA8
....................    } 
....................    else if(FaultType.B7 == 0) 
449A:  BRA    451A
449C:  BTFSC  x10.6
449E:  BRA    451A
....................    { 
....................       In2.B7 = 0x00; 
44A0:  BCF    x1C.6
....................       Ack.B7 = 0; 
44A2:  BCF    x18.6
....................       Output.B7 = 1;      //Off LED 
44A4:  BSF    x0C.6
....................  
....................       if((OutputType.B7 == 1 || OutputBoth.B7 == 0)&& inputflag ==0)       //If Buzzer or Both 
44A6:  BTFSC  x12.6
44A8:  BRA    44AE
44AA:  BTFSC  x14.6
44AC:  BRA    44C8
44AE:  MOVF   xA8,F
44B0:  BNZ   44C8
....................       { 
....................          if(CheckAutoReset(0x01) == 1);   //Check other Input "Ack" or not if not,do nothing 
44B2:  MOVLW  01
44B4:  MOVWF  xB3
44B6:  MOVLB  0
44B8:  CALL   3516
44BC:  DECFSZ 01,W
44BE:  BRA    44C2
....................          else 
44C0:  BRA    44C6
....................          { 
....................             output_bit(Pbuzzer,0);   //Clear Buzzer 
44C2:  BCF    F89.4
44C4:  BCF    F92.4
44C6:  MOVLB  1
....................          } 
....................       } 
....................  
....................  
....................       if((OutputType.B7 == 0 || OutputBoth.B7 == 0)&& inputflag ==0)   //If Bell or Both 
44C8:  BTFSS  x12.6
44CA:  BRA    44D0
44CC:  BTFSC  x14.6
44CE:  BRA    44EA
44D0:  MOVF   xA8,F
44D2:  BNZ   44EA
....................       { 
....................          if(CheckAutoReset(0x02) == 1); 
44D4:  MOVLW  02
44D6:  MOVWF  xB3
44D8:  MOVLB  0
44DA:  CALL   3516
44DE:  DECFSZ 01,W
44E0:  BRA    44E4
....................          else 
44E2:  BRA    44E8
....................          { 
....................             output_bit(Pbell,0);      //Clear Bell 
44E4:  BCF    F89.3
44E6:  BCF    F92.3
44E8:  MOVLB  1
....................          } 
....................       } 
....................       // jj modify 
....................       if(In2.B1 ==0 && In2.B2 ==0 && In2.B3 ==0 && In2.B4 ==0 && In2.B5 ==0 && In2.B6 ==0 && In2.B7 ==0 && In2.B8 ==0 && In2.B9 ==0 && In2.B10 ==0) 
44EA:  BTFSC  x1C.0
44EC:  BRA    451A
44EE:  BTFSC  x1C.1
44F0:  BRA    451A
44F2:  BTFSC  x1C.2
44F4:  BRA    451A
44F6:  BTFSC  x1C.3
44F8:  BRA    451A
44FA:  BTFSC  x1C.4
44FC:  BRA    451A
44FE:  BTFSC  x1C.5
4500:  BRA    451A
4502:  BTFSC  x1C.6
4504:  BRA    451A
4506:  BTFSC  x1C.7
4508:  BRA    451A
450A:  BTFSC  x1D.0
450C:  BRA    451A
450E:  BTFSC  x1D.1
4510:  BRA    451A
....................       { 
....................          output_bit(Pbell,0);      //Clear Bell 
4512:  BCF    F89.3
4514:  BCF    F92.3
....................          output_bit(Pbuzzer,0);   //Clear Buzzer 
4516:  BCF    F89.4
4518:  BCF    F92.4
....................       } 
....................    } 
....................    //////////////////////////////////////////////////////////////////////////////////////////////////// 
.................... //input8 
....................    if((((Inputt.B8 ^ InputType.B8) == 1) && (FaultType.B8 == 0))||Test_fault==1)    // alarm1 occure and " Non Lock type" 
451A:  MOVLW  00
451C:  BTFSC  x0A.7
451E:  MOVLW  01
4520:  MOVWF  xB3
4522:  MOVLW  00
4524:  BTFSC  x0E.7
4526:  MOVLW  01
4528:  XORWF  xB3,W
452A:  SUBLW  01
452C:  BNZ   4532
452E:  BTFSS  x10.7
4530:  BRA    4536
4532:  BTFSS  17.5
4534:  BRA    4582
....................    { 
....................       if(In2.B8 == 0 && AutoAck == 0x0F && Ack.B8 == 0)   //use auto acknowlegde 
4536:  BTFSC  x1C.7
4538:  BRA    454C
453A:  MOVF   5B,W
453C:  SUBLW  0F
453E:  BNZ   454C
4540:  BTFSC  x18.7
4542:  BRA    454C
....................       { 
....................             TimeBase1s = 100 ;            //reload again 
4544:  MOVLW  64
4546:  MOVWF  19
....................             AutoAckDelayTime = AutoAckTime ; 
4548:  MOVFF  5C,1A
....................       } 
....................  
....................       In2.B8 = 1; 
454C:  BSF    x1C.7
....................       if(Ack.B8 == 0) 
454E:  BTFSC  x18.7
4550:  BRA    457C
....................       { 
....................          if(FlashingFlag == 0) 
4552:  BTFSC  17.1
4554:  BRA    455A
....................             { 
....................                Output.B8 = 0;           //Flash output1 
4556:  BCF    x0C.7
....................             } 
....................             else 
4558:  BRA    455C
....................             { 
....................                Output.B8 = 1; 
455A:  BSF    x0C.7
....................             } 
....................          if (~AutoTestFlag) 
455C:  BTFSC  17.4
455E:  BRA    457C
....................          { 
....................              if(OutputBoth.B8 == 0)        //Both output 
4560:  BTFSC  x14.7
4562:  BRA    456E
....................              { 
....................                output_bit(Pbuzzer,1);   //Buzzer 
4564:  BSF    F89.4
4566:  BCF    F92.4
....................                output_bit(Pbell,1);     //Bell 
4568:  BSF    F89.3
456A:  BCF    F92.3
....................              } 
....................              else 
456C:  BRA    457C
....................              { 
....................                if(OutputType.B8 == 1) output_bit(Pbuzzer,1);     //Buzzer 
456E:  BTFSS  x12.7
4570:  BRA    4578
4572:  BSF    F89.4
4574:  BCF    F92.4
....................                else output_bit(Pbell,1);                          //Bell 
4576:  BRA    457C
4578:  BSF    F89.3
457A:  BCF    F92.3
....................              } 
....................          } 
....................        } 
....................       inputflag =1; 
457C:  MOVLW  01
457E:  MOVWF  xA8
....................    } 
....................    else if(FaultType.B8 == 0) 
4580:  BRA    4600
4582:  BTFSC  x10.7
4584:  BRA    4600
....................    { 
....................       In2.B8 = 0x00; 
4586:  BCF    x1C.7
....................       Ack.B8 = 0; 
4588:  BCF    x18.7
....................       Output.B8 = 1;      //Off LED 
458A:  BSF    x0C.7
....................  
....................       if((OutputType.B8 == 1 || OutputBoth.B8 == 0)&& inputflag ==0)       //If Buzzer or Both 
458C:  BTFSC  x12.7
458E:  BRA    4594
4590:  BTFSC  x14.7
4592:  BRA    45AE
4594:  MOVF   xA8,F
4596:  BNZ   45AE
....................       { 
....................          if(CheckAutoReset(0x01) == 1);   //Check other Input "Ack" or not if not,do nothing 
4598:  MOVLW  01
459A:  MOVWF  xB3
459C:  MOVLB  0
459E:  CALL   3516
45A2:  DECFSZ 01,W
45A4:  BRA    45A8
....................          else 
45A6:  BRA    45AC
....................          { 
....................             output_bit(Pbuzzer,0);   //Clear Buzzer 
45A8:  BCF    F89.4
45AA:  BCF    F92.4
45AC:  MOVLB  1
....................          } 
....................       } 
....................  
....................  
....................       if((OutputType.B8 == 0 || OutputBoth.B8 == 0)&& inputflag ==0)   //If Bell or Both 
45AE:  BTFSS  x12.7
45B0:  BRA    45B6
45B2:  BTFSC  x14.7
45B4:  BRA    45D0
45B6:  MOVF   xA8,F
45B8:  BNZ   45D0
....................       { 
....................          if(CheckAutoReset(0x02) == 1); 
45BA:  MOVLW  02
45BC:  MOVWF  xB3
45BE:  MOVLB  0
45C0:  CALL   3516
45C4:  DECFSZ 01,W
45C6:  BRA    45CA
....................          else 
45C8:  BRA    45CE
....................          { 
....................             output_bit(Pbell,0);      //Clear Bell 
45CA:  BCF    F89.3
45CC:  BCF    F92.3
45CE:  MOVLB  1
....................          } 
....................       } 
....................       // jj modify 
....................       if(In2.B1 ==0 && In2.B2 ==0 && In2.B3 ==0 && In2.B4 ==0 && In2.B5 ==0 && In2.B6 ==0 && In2.B7 ==0 && In2.B8 ==0 && In2.B9 ==0 && In2.B10 ==0) 
45D0:  BTFSC  x1C.0
45D2:  BRA    4600
45D4:  BTFSC  x1C.1
45D6:  BRA    4600
45D8:  BTFSC  x1C.2
45DA:  BRA    4600
45DC:  BTFSC  x1C.3
45DE:  BRA    4600
45E0:  BTFSC  x1C.4
45E2:  BRA    4600
45E4:  BTFSC  x1C.5
45E6:  BRA    4600
45E8:  BTFSC  x1C.6
45EA:  BRA    4600
45EC:  BTFSC  x1C.7
45EE:  BRA    4600
45F0:  BTFSC  x1D.0
45F2:  BRA    4600
45F4:  BTFSC  x1D.1
45F6:  BRA    4600
....................       { 
....................          output_bit(Pbell,0);      //Clear Bell 
45F8:  BCF    F89.3
45FA:  BCF    F92.3
....................          output_bit(Pbuzzer,0);   //Clear Buzzer 
45FC:  BCF    F89.4
45FE:  BCF    F92.4
....................       } 
....................    } 
....................    //////////////////////////////////////////////////////////////////////////////////////////////////// 
.................... //input9 
....................    if((((Inputt.B9 ^ InputType.B9) == 1) && (FaultType.B9 == 0))||Test_fault==1)    // alarm1 occure and " Non Lock type" 
4600:  MOVLW  00
4602:  BTFSC  x0B.0
4604:  MOVLW  01
4606:  MOVWF  xB3
4608:  MOVLW  00
460A:  BTFSC  x0F.0
460C:  MOVLW  01
460E:  XORWF  xB3,W
4610:  SUBLW  01
4612:  BNZ   4618
4614:  BTFSS  x11.0
4616:  BRA    461C
4618:  BTFSS  17.5
461A:  BRA    4668
....................    { 
....................       if(In2.B9 == 0 && AutoAck == 0x0F && Ack.B9 == 0)   //use auto acknowlegde 
461C:  BTFSC  x1D.0
461E:  BRA    4632
4620:  MOVF   5B,W
4622:  SUBLW  0F
4624:  BNZ   4632
4626:  BTFSC  x19.0
4628:  BRA    4632
....................       { 
....................             TimeBase1s = 100 ;            //reload again 
462A:  MOVLW  64
462C:  MOVWF  19
....................             AutoAckDelayTime = AutoAckTime ; 
462E:  MOVFF  5C,1A
....................       } 
....................  
....................       In2.B9 = 1; 
4632:  BSF    x1D.0
....................       if(Ack.B9 == 0) 
4634:  BTFSC  x19.0
4636:  BRA    4662
....................       { 
....................          if(FlashingFlag == 0) 
4638:  BTFSC  17.1
463A:  BRA    4640
....................             { 
....................                Output.B9 = 0;           //Flash output1 
463C:  BCF    x0D.0
....................             } 
....................             else 
463E:  BRA    4642
....................             { 
....................                Output.B9 = 1; 
4640:  BSF    x0D.0
....................             } 
....................          if (~AutoTestFlag) 
4642:  BTFSC  17.4
4644:  BRA    4662
....................          { 
....................              if(OutputBoth.B9 == 0)        //Both output 
4646:  BTFSC  x15.0
4648:  BRA    4654
....................              { 
....................                output_bit(Pbuzzer,1);   //Buzzer 
464A:  BSF    F89.4
464C:  BCF    F92.4
....................                output_bit(Pbell,1);     //Bell 
464E:  BSF    F89.3
4650:  BCF    F92.3
....................              } 
....................              else 
4652:  BRA    4662
....................              { 
....................                if(OutputType.B9 == 1) output_bit(Pbuzzer,1);     //Buzzer 
4654:  BTFSS  x13.0
4656:  BRA    465E
4658:  BSF    F89.4
465A:  BCF    F92.4
....................                else output_bit(Pbell,1);                          //Bell 
465C:  BRA    4662
465E:  BSF    F89.3
4660:  BCF    F92.3
....................              } 
....................          } 
....................        } 
....................       inputflag =1; 
4662:  MOVLW  01
4664:  MOVWF  xA8
....................    } 
....................    else if(FaultType.B9 == 0) 
4666:  BRA    46E6
4668:  BTFSC  x11.0
466A:  BRA    46E6
....................    { 
....................       In2.B9 = 0x00; 
466C:  BCF    x1D.0
....................       Ack.B9 = 0; 
466E:  BCF    x19.0
....................       Output.B9 = 1;      //Off LED 
4670:  BSF    x0D.0
....................  
....................       if((OutputType.B9 == 1 || OutputBoth.B9 == 0)&& inputflag ==0)       //If Buzzer or Both 
4672:  BTFSC  x13.0
4674:  BRA    467A
4676:  BTFSC  x15.0
4678:  BRA    4694
467A:  MOVF   xA8,F
467C:  BNZ   4694
....................       { 
....................          if(CheckAutoReset(0x01) == 1);   //Check other Input "Ack" or not if not,do nothing 
467E:  MOVLW  01
4680:  MOVWF  xB3
4682:  MOVLB  0
4684:  CALL   3516
4688:  DECFSZ 01,W
468A:  BRA    468E
....................          else 
468C:  BRA    4692
....................          { 
....................             output_bit(Pbuzzer,0);   //Clear Buzzer 
468E:  BCF    F89.4
4690:  BCF    F92.4
4692:  MOVLB  1
....................          } 
....................       } 
....................  
....................  
....................       if((OutputType.B9 == 0 || OutputBoth.B9 == 0)&& inputflag ==0)   //If Bell or Both 
4694:  BTFSS  x13.0
4696:  BRA    469C
4698:  BTFSC  x15.0
469A:  BRA    46B6
469C:  MOVF   xA8,F
469E:  BNZ   46B6
....................       { 
....................          if(CheckAutoReset(0x02) == 1); 
46A0:  MOVLW  02
46A2:  MOVWF  xB3
46A4:  MOVLB  0
46A6:  CALL   3516
46AA:  DECFSZ 01,W
46AC:  BRA    46B0
....................          else 
46AE:  BRA    46B4
....................          { 
....................             output_bit(Pbell,0);      //Clear Bell 
46B0:  BCF    F89.3
46B2:  BCF    F92.3
46B4:  MOVLB  1
....................          } 
....................       } 
....................       // jj modify 
....................       if(In2.B1 ==0 && In2.B2 ==0 && In2.B3 ==0 && In2.B4 ==0 && In2.B5 ==0 && In2.B6 ==0 && In2.B7 ==0 && In2.B8 ==0 && In2.B9 ==0 && In2.B10 ==0) 
46B6:  BTFSC  x1C.0
46B8:  BRA    46E6
46BA:  BTFSC  x1C.1
46BC:  BRA    46E6
46BE:  BTFSC  x1C.2
46C0:  BRA    46E6
46C2:  BTFSC  x1C.3
46C4:  BRA    46E6
46C6:  BTFSC  x1C.4
46C8:  BRA    46E6
46CA:  BTFSC  x1C.5
46CC:  BRA    46E6
46CE:  BTFSC  x1C.6
46D0:  BRA    46E6
46D2:  BTFSC  x1C.7
46D4:  BRA    46E6
46D6:  BTFSC  x1D.0
46D8:  BRA    46E6
46DA:  BTFSC  x1D.1
46DC:  BRA    46E6
....................       { 
....................          output_bit(Pbell,0);      //Clear Bell 
46DE:  BCF    F89.3
46E0:  BCF    F92.3
....................          output_bit(Pbuzzer,0);   //Clear Buzzer 
46E2:  BCF    F89.4
46E4:  BCF    F92.4
....................       } 
....................    } 
....................    //////////////////////////////////////////////////////////////////////////////////////////////////// 
.................... //input10 
....................    if((((Inputt.B10 ^ InputType.B10) == 1) && (FaultType.B10 == 0))||Test_fault==1)    // alarm1 occure and " Non Lock type" 
46E6:  MOVLW  00
46E8:  BTFSC  x0B.1
46EA:  MOVLW  01
46EC:  MOVWF  xB3
46EE:  MOVLW  00
46F0:  BTFSC  x0F.1
46F2:  MOVLW  01
46F4:  XORWF  xB3,W
46F6:  SUBLW  01
46F8:  BNZ   46FE
46FA:  BTFSS  x11.1
46FC:  BRA    4702
46FE:  BTFSS  17.5
4700:  BRA    474E
....................    { 
....................       if(In2.B10 == 0 && AutoAck == 0x0F && Ack.B10 == 0)   //use auto acknowlegde 
4702:  BTFSC  x1D.1
4704:  BRA    4718
4706:  MOVF   5B,W
4708:  SUBLW  0F
470A:  BNZ   4718
470C:  BTFSC  x19.1
470E:  BRA    4718
....................       { 
....................             TimeBase1s = 100 ;            //reload again 
4710:  MOVLW  64
4712:  MOVWF  19
....................             AutoAckDelayTime = AutoAckTime ; 
4714:  MOVFF  5C,1A
....................       } 
....................  
....................       In2.B10 = 1; 
4718:  BSF    x1D.1
....................       if(Ack.B10 == 0) 
471A:  BTFSC  x19.1
471C:  BRA    4748
....................       { 
....................          if(FlashingFlag == 0) 
471E:  BTFSC  17.1
4720:  BRA    4726
....................             { 
....................                Output.B10 = 0;           //Flash output1 
4722:  BCF    x0D.1
....................             } 
....................             else 
4724:  BRA    4728
....................             { 
....................                Output.B10 = 1; 
4726:  BSF    x0D.1
....................             } 
....................          if (~AutoTestFlag) 
4728:  BTFSC  17.4
472A:  BRA    4748
....................          { 
....................              if(OutputBoth.B10 == 0)        //Both output 
472C:  BTFSC  x15.1
472E:  BRA    473A
....................              { 
....................                output_bit(Pbuzzer,1);   //Buzzer 
4730:  BSF    F89.4
4732:  BCF    F92.4
....................                output_bit(Pbell,1);     //Bell 
4734:  BSF    F89.3
4736:  BCF    F92.3
....................              } 
....................              else 
4738:  BRA    4748
....................              { 
....................                if(OutputType.B10 == 1) output_bit(Pbuzzer,1);     //Buzzer 
473A:  BTFSS  x13.1
473C:  BRA    4744
473E:  BSF    F89.4
4740:  BCF    F92.4
....................                else output_bit(Pbell,1);                          //Bell 
4742:  BRA    4748
4744:  BSF    F89.3
4746:  BCF    F92.3
....................              } 
....................          } 
....................        } 
....................       inputflag =1; 
4748:  MOVLW  01
474A:  MOVWF  xA8
....................    } 
....................    else if(FaultType.B10 == 0) 
474C:  BRA    47CC
474E:  BTFSC  x11.1
4750:  BRA    47CC
....................    { 
....................       In2.B10 = 0x00; 
4752:  BCF    x1D.1
....................       Ack.B10 = 0; 
4754:  BCF    x19.1
....................       Output.B10 = 1;      //Off LED 
4756:  BSF    x0D.1
....................  
....................       if((OutputType.B10 == 1 || OutputBoth.B10 == 0)&& inputflag ==0)       //If Buzzer or Both 
4758:  BTFSC  x13.1
475A:  BRA    4760
475C:  BTFSC  x15.1
475E:  BRA    477A
4760:  MOVF   xA8,F
4762:  BNZ   477A
....................       { 
....................          if(CheckAutoReset(0x01) == 1);   //Check other Input "Ack" or not if not,do nothing 
4764:  MOVLW  01
4766:  MOVWF  xB3
4768:  MOVLB  0
476A:  CALL   3516
476E:  DECFSZ 01,W
4770:  BRA    4774
....................          else 
4772:  BRA    4778
....................          { 
....................             output_bit(Pbuzzer,0);   //Clear Buzzer 
4774:  BCF    F89.4
4776:  BCF    F92.4
4778:  MOVLB  1
....................          } 
....................       } 
....................  
....................  
....................       if((OutputType.B10 == 0 || OutputBoth.B10 == 0)&& inputflag ==0)   //If Bell or Both 
477A:  BTFSS  x13.1
477C:  BRA    4782
477E:  BTFSC  x15.1
4780:  BRA    479C
4782:  MOVF   xA8,F
4784:  BNZ   479C
....................       { 
....................          if(CheckAutoReset(0x02) == 1); 
4786:  MOVLW  02
4788:  MOVWF  xB3
478A:  MOVLB  0
478C:  CALL   3516
4790:  DECFSZ 01,W
4792:  BRA    4796
....................          else 
4794:  BRA    479A
....................          { 
....................             output_bit(Pbell,0);      //Clear Bell 
4796:  BCF    F89.3
4798:  BCF    F92.3
479A:  MOVLB  1
....................          } 
....................       } 
....................       // jj modify 
....................       if(In2.B1 ==0 && In2.B2 ==0 && In2.B3 ==0 && In2.B4 ==0 && In2.B5 ==0 && In2.B6 ==0 && In2.B7 ==0 && In2.B8 ==0 && In2.B9 ==0 && In2.B10 ==0) 
479C:  BTFSC  x1C.0
479E:  BRA    47CC
47A0:  BTFSC  x1C.1
47A2:  BRA    47CC
47A4:  BTFSC  x1C.2
47A6:  BRA    47CC
47A8:  BTFSC  x1C.3
47AA:  BRA    47CC
47AC:  BTFSC  x1C.4
47AE:  BRA    47CC
47B0:  BTFSC  x1C.5
47B2:  BRA    47CC
47B4:  BTFSC  x1C.6
47B6:  BRA    47CC
47B8:  BTFSC  x1C.7
47BA:  BRA    47CC
47BC:  BTFSC  x1D.0
47BE:  BRA    47CC
47C0:  BTFSC  x1D.1
47C2:  BRA    47CC
....................       { 
....................          output_bit(Pbell,0);      //Clear Bell 
47C4:  BCF    F89.3
47C6:  BCF    F92.3
....................          output_bit(Pbuzzer,0);   //Clear Buzzer 
47C8:  BCF    F89.4
47CA:  BCF    F92.4
....................       } 
....................    } 
....................     
.................... //} 
.................... //////////////////////////////////////////////////////////////////////////////////// 
.................... ////////////////////////////////////////////////////////////////////////////////// 
.................... //if(NoOfPoint >= 20) 
.................... //{ 
....................    //////////////////////////////////////////////////////////////////////////////////////////////////// 
.................... //input11 
.................... /* 
....................    if(((Inputt.B11 ^ InputType.B11) == 1) && (FaultType.B11 == 0))    // alarm1 occure and " Non Lock type" 
....................    { 
....................       if(In2.B11 == 0 && AutoAck == 0x0F && Ack.B11 == 0)   //use auto acknowlegde 
....................       { 
....................             TimeBase1s = 100 ;            //reload again 
....................             AutoAckDelayTime = AutoAckTime ; 
....................       } 
....................  
....................       In2.B11 = 1; 
....................       if(Ack.B11 == 0) 
....................       { 
....................          if(FlashingFlag == 0) 
....................             { 
....................                Output.B11 = 0;           //Flash output1 
....................             } 
....................             else 
....................             { 
....................                Output.B11 = 1; 
....................             } 
....................          if (~AutoTestFlag) 
....................          { 
....................              if(OutputBoth.B11 == 0)        //Both output 
....................              { 
....................                output_bit(Pbuzzer,1);   //Buzzer 
....................                output_bit(Pbell,1);     //Bell 
....................              } 
....................              else 
....................              { 
....................                if(OutputType.B11 == 1) output_bit(Pbuzzer,1);     //Buzzer 
....................                else output_bit(Pbell,1);                          //Bell 
....................              } 
....................          } 
....................        } 
....................  
....................    } 
....................    else if(FaultType.B11 == 0) 
....................    { 
....................       In2.B11 = 0x00; 
....................       Ack.B11 = 0; 
....................       Output.B11 = 1;      //Off LED 
....................  
....................       if(OutputType.B11 == 1 || OutputBoth.B11 == 0)      //If Buzzer or Both 
....................       { 
....................          if(CheckAutoReset(0x01) == 1);   //Check other Input "Ack" or not if not,do nothing 
....................          else 
....................          { 
....................             output_bit(Pbuzzer,1);   //Clear Buzzer 
....................          } 
....................       } 
....................  
....................  
....................       if(OutputType.B11 == 0 || OutputBoth.B11 == 0)  //If Bell or Both 
....................       { 
....................          if(CheckAutoReset(0x02) == 1); 
....................          else 
....................          { 
....................             output_bit(Pbell,1);      //Clear Bell 
....................          } 
....................       } 
....................    } 
....................    //////////////////////////////////////////////////////////////////////////////////////////////////// 
.................... //input12 
....................    if(((Inputt.B12 ^ InputType.B12) == 1) && (FaultType.B12 == 0))    // alarm1 occure and " Non Lock type" 
....................    { 
....................       if(In2.B12 == 0 && AutoAck == 0x0F && Ack.B12 == 0)   //use auto acknowlegde 
....................       { 
....................             TimeBase1s = 100 ;            //reload again 
....................             AutoAckDelayTime = AutoAckTime ; 
....................       } 
....................  
....................       In2.B12 = 1; 
....................       if(Ack.B12 == 0) 
....................       { 
....................          if(FlashingFlag == 0) 
....................             { 
....................                Output.B12 = 0;           //Flash output1 
....................             } 
....................             else 
....................             { 
....................                Output.B12 = 1; 
....................             } 
....................          if (~AutoTestFlag) 
....................          { 
....................              if(OutputBoth.B12 == 0)        //Both output 
....................              { 
....................                output_bit(Pbuzzer,1);   //Buzzer 
....................                output_bit(Pbell,1);     //Bell 
....................              } 
....................              else 
....................              { 
....................                if(OutputType.B12 == 1) output_bit(Pbuzzer,1);     //Buzzer 
....................                else output_bit(Pbell,1);                          //Bell 
....................              } 
....................          } 
....................        } 
....................  
....................    } 
....................    else if(FaultType.B12 == 0) 
....................    { 
....................       In2.B12 = 0x00; 
....................       Ack.B12 = 0; 
....................       Output.B12 = 1;      //Off LED 
....................  
....................       if(OutputType.B12 == 1 || OutputBoth.B12 == 0)      //If Buzzer or Both 
....................       { 
....................          if(CheckAutoReset(0x01) == 1);   //Check other Input "Ack" or not if not,do nothing 
....................          else 
....................          { 
....................             output_bit(Pbuzzer,1);   //Clear Buzzer 
....................          } 
....................       } 
....................  
....................  
....................       if(OutputType.B12 == 0 || OutputBoth.B12 == 0)  //If Bell or Both 
....................       { 
....................          if(CheckAutoReset(0x02) == 1); 
....................          else 
....................          { 
....................             output_bit(Pbell,1);      //Clear Bell 
....................          } 
....................       } 
....................    } 
....................    //////////////////////////////////////////////////////////////////////////////////////////////////// 
.................... //input13 
....................    if(((Inputt.B13 ^ InputType.B13) == 1) && (FaultType.B13 == 0))    // alarm1 occure and " Non Lock type" 
....................    { 
....................       if(In2.B13 == 0 && AutoAck == 0x0F && Ack.B13 == 0)   //use auto acknowlegde 
....................       { 
....................             TimeBase1s = 100 ;            //reload again 
....................             AutoAckDelayTime = AutoAckTime ; 
....................       } 
....................  
....................       In2.B13 = 1; 
....................       if(Ack.B13 == 0) 
....................       { 
....................          if(FlashingFlag == 0) 
....................             { 
....................                Output.B13 = 0;           //Flash output1 
....................             } 
....................             else 
....................             { 
....................                Output.B13 = 1; 
....................             } 
....................          if (~AutoTestFlag) 
....................          { 
....................              if(OutputBoth.B13 == 0)        //Both output 
....................              { 
....................                output_bit(Pbuzzer,1);   //Buzzer 
....................                output_bit(Pbell,1);     //Bell 
....................              } 
....................              else 
....................              { 
....................                if(OutputType.B13 == 1) output_bit(Pbuzzer,1);     //Buzzer 
....................                else output_bit(Pbell,1);                          //Bell 
....................              } 
....................          } 
....................        } 
....................  
....................    } 
....................    else if(FaultType.B13 == 0) 
....................    { 
....................       In2.B13 = 0x00; 
....................       Ack.B13 = 0; 
....................       Output.B13 = 1;      //Off LED 
....................  
....................       if(OutputType.B13 == 1 || OutputBoth.B13 == 0)      //If Buzzer or Both 
....................       { 
....................          if(CheckAutoReset(0x01) == 1);   //Check other Input "Ack" or not if not,do nothing 
....................          else 
....................          { 
....................             output_bit(Pbuzzer,1);   //Clear Buzzer 
....................          } 
....................       } 
....................  
....................  
....................       if(OutputType.B13 == 0 || OutputBoth.B13 == 0)  //If Bell or Both 
....................       { 
....................          if(CheckAutoReset(0x02) == 1); 
....................          else 
....................          { 
....................             output_bit(Pbell,1);      //Clear Bell 
....................          } 
....................       } 
....................    } 
....................    //////////////////////////////////////////////////////////////////////////////////////////////////// 
.................... //input14 
....................    if(((Inputt.B14 ^ InputType.B14) == 1) && (FaultType.B14 == 0))    // alarm1 occure and " Non Lock type" 
....................    { 
....................       if(In2.B14 == 0 && AutoAck == 0x0F && Ack.B14 == 0)   //use auto acknowlegde 
....................       { 
....................             TimeBase1s = 100 ;            //reload again 
....................             AutoAckDelayTime = AutoAckTime ; 
....................       } 
....................  
....................       In2.B14 = 1; 
....................       if(Ack.B14 == 0) 
....................       { 
....................          if(FlashingFlag == 0) 
....................             { 
....................                Output.B14 = 0;           //Flash output1 
....................             } 
....................             else 
....................             { 
....................                Output.B14 = 1; 
....................             } 
....................          if (~AutoTestFlag) 
....................          { 
....................              if(OutputBoth.B14 == 0)        //Both output 
....................              { 
....................                output_bit(Pbuzzer,1);   //Buzzer 
....................                output_bit(Pbell,1);     //Bell 
....................              } 
....................              else 
....................              { 
....................                if(OutputType.B14 == 1) output_bit(Pbuzzer,1);     //Buzzer 
....................                else output_bit(Pbell,1);                          //Bell 
....................              } 
....................          } 
....................        } 
....................  
....................    } 
....................    else if(FaultType.B14 == 0) 
....................    { 
....................       In2.B14 = 0x00; 
....................       Ack.B14 = 0; 
....................       Output.B14 = 1;      //Off LED 
....................  
....................       if(OutputType.B14 == 1 || OutputBoth.B14 == 0)      //If Buzzer or Both 
....................       { 
....................          if(CheckAutoReset(0x01) == 1);   //Check other Input "Ack" or not if not,do nothing 
....................          else 
....................          { 
....................             output_bit(Pbuzzer,1);   //Clear Buzzer 
....................          } 
....................       } 
....................  
....................  
....................       if(OutputType.B14 == 0 || OutputBoth.B14 == 0)  //If Bell or Both 
....................       { 
....................          if(CheckAutoReset(0x02) == 1); 
....................          else 
....................          { 
....................             output_bit(Pbell,1);      //Clear Bell 
....................          } 
....................       } 
....................    } 
....................    //////////////////////////////////////////////////////////////////////////////////////////////////// 
.................... //input15 
....................    if(((Inputt.B15 ^ InputType.B15) == 1) && (FaultType.B15 == 0))    // alarm1 occure and " Non Lock type" 
....................    { 
....................       if(In2.B15 == 0 && AutoAck == 0x0F && Ack.B15 == 0)   //use auto acknowlegde 
....................       { 
....................             TimeBase1s = 100 ;            //reload again 
....................             AutoAckDelayTime = AutoAckTime ; 
....................       } 
....................  
....................       In2.B15 = 1; 
....................       if(Ack.B15 == 0) 
....................       { 
....................          if(FlashingFlag == 0) 
....................             { 
....................                Output.B15 = 0;           //Flash output1 
....................             } 
....................             else 
....................             { 
....................                Output.B15 = 1; 
....................             } 
....................          if (~AutoTestFlag) 
....................          { 
....................              if(OutputBoth.B15 == 0)        //Both output 
....................              { 
....................                output_bit(Pbuzzer,1);   //Buzzer 
....................                output_bit(Pbell,1);     //Bell 
....................              } 
....................              else 
....................              { 
....................                if(OutputType.B15 == 1) output_bit(Pbuzzer,1);     //Buzzer 
....................                else output_bit(Pbell,1);                          //Bell 
....................              } 
....................          } 
....................        } 
....................  
....................    } 
....................    else if(FaultType.B15 == 0) 
....................    { 
....................       In2.B15 = 0x00; 
....................       Ack.B15 = 0; 
....................       Output.B15 = 1;      //Off LED 
....................  
....................       if(OutputType.B15 == 1 || OutputBoth.B15 == 0)      //If Buzzer or Both 
....................       { 
....................          if(CheckAutoReset(0x01) == 1);   //Check other Input "Ack" or not if not,do nothing 
....................          else 
....................          { 
....................             output_bit(Pbuzzer,1);   //Clear Buzzer 
....................          } 
....................       } 
....................  
....................  
....................       if(OutputType.B15 == 0 || OutputBoth.B15 == 0)  //If Bell or Both 
....................       { 
....................          if(CheckAutoReset(0x02) == 1); 
....................          else 
....................          { 
....................             output_bit(Pbell,1);      //Clear Bell 
....................          } 
....................       } 
....................    } 
....................    //////////////////////////////////////////////////////////////////////////////////////////////////// 
.................... //input16 
....................    if(((Inputt.B16 ^ InputType.B16) == 1) && (FaultType.B16 == 0))    // alarm1 occure and " Non Lock type" 
....................    { 
....................       if(In2.B16 == 0 && AutoAck == 0x0F && Ack.B16 == 0)   //use auto acknowlegde 
....................       { 
....................             TimeBase1s = 100 ;            //reload again 
....................             AutoAckDelayTime = AutoAckTime ; 
....................       } 
....................  
....................       In2.B16 = 1; 
....................       if(Ack.B16 == 0) 
....................       { 
....................          if(FlashingFlag == 0) 
....................             { 
....................                Output.B16 = 0;         //Flash output1 
....................             } 
....................             else 
....................             { 
....................                Output.B16 = 1; 
....................             } 
....................          if (~AutoTestFlag) 
....................          { 
....................              if(OutputBoth.B16 == 0)        //Both output 
....................              { 
....................                output_bit(Pbuzzer,1);   //Buzzer 
....................                output_bit(Pbell,1);     //Bell 
....................              } 
....................              else 
....................              { 
....................                if(OutputType.B16 == 1) output_bit(Pbuzzer,1);     //Buzzer 
....................                else output_bit(Pbell,1);                          //Bell 
....................              } 
....................          } 
....................        } 
....................  
....................    } 
....................    else if(FaultType.B16 == 0) 
....................    { 
....................       In2.B16 = 0x00; 
....................       Ack.B16 = 0; 
....................       Output.B16 = 1;      //Off LED 
....................  
....................       if(OutputType.B16 == 1 || OutputBoth.B16 == 0)      //If Buzzer or Both 
....................       { 
....................          if(CheckAutoReset(0x01) == 1);   //Check other Input "Ack" or not if not,do nothing 
....................          else 
....................          { 
....................             output_bit(Pbuzzer,1);   //Clear Buzzer 
....................          } 
....................       } 
....................  
....................  
....................       if(OutputType.B16 == 0 || OutputBoth.B16 == 0)  //If Bell or Both 
....................       { 
....................          if(CheckAutoReset(0x02) == 1); 
....................          else 
....................          { 
....................             output_bit(Pbell,1);      //Clear Bell 
....................          } 
....................       } 
....................    } 
.................... //input17 
....................    if(((Inputt.B17 ^ InputType.B17) == 1) && (FaultType.B17 == 0))    // alarm1 occure and " Non Lock type" 
....................    { 
....................       if(In2.B17 == 0 && AutoAck == 0x0F && Ack.B17 == 0)   //use auto acknowlegde 
....................       { 
....................             TimeBase1s = 100 ;            //reload again 
....................             AutoAckDelayTime = AutoAckTime ; 
....................       } 
....................  
....................       In2.B17 = 1; 
....................       if(Ack.B17 == 0) 
....................       { 
....................          if(FlashingFlag == 0) 
....................             { 
....................                Output.B17 = 0;           //Flash output1 
....................             } 
....................             else 
....................             { 
....................                Output.B17 = 1; 
....................             } 
....................          if (~AutoTestFlag) 
....................          { 
....................              if(OutputBoth.B17 == 0)        //Both output 
....................              { 
....................                output_bit(Pbuzzer,1);   //Buzzer 
....................                output_bit(Pbell,1);     //Bell 
....................              } 
....................              else 
....................              { 
....................                if(OutputType.B17 == 1) output_bit(Pbuzzer,1);     //Buzzer 
....................                else output_bit(Pbell,1);                          //Bell 
....................              } 
....................          } 
....................        } 
....................  
....................    } 
....................    else if(FaultType.B17 == 0) 
....................    { 
....................       In2.B17 = 0x00; 
....................       Ack.B17 = 0; 
....................       Output.B17 = 1;      //Off LED 
....................  
....................       if(OutputType.B17 == 1 || OutputBoth.B17 == 0)      //If Buzzer or Both 
....................       { 
....................          if(CheckAutoReset(0x01) == 1);   //Check other Input "Ack" or not if not,do nothing 
....................          else 
....................          { 
....................             output_bit(Pbuzzer,1);   //Clear Buzzer 
....................          } 
....................       } 
....................  
....................  
....................       if(OutputType.B17 == 0 || OutputBoth.B17 == 0)  //If Bell or Both 
....................       { 
....................          if(CheckAutoReset(0x02) == 1); 
....................          else 
....................          { 
....................             output_bit(Pbell,1);      //Clear Bell 
....................          } 
....................       } 
....................    } 
.................... //input18 
....................    if(((Inputt.B18 ^ InputType.B18) == 1) && (FaultType.B18 == 0))    // alarm1 occure and " Non Lock type" 
....................    { 
....................       if(In2.B18 == 0 && AutoAck == 0x0F && Ack.B18 == 0)   //use auto acknowlegde 
....................       { 
....................             TimeBase1s = 100 ;            //reload again 
....................             AutoAckDelayTime = AutoAckTime ; 
....................       } 
....................  
....................       In2.B18 = 1; 
....................       if(Ack.B18 == 0) 
....................       { 
....................          if(FlashingFlag == 0) 
....................             { 
....................                Output.B18 = 0;           //Flash output1 
....................             } 
....................             else 
....................             { 
....................                Output.B18 = 1; 
....................             } 
....................          if (~AutoTestFlag) 
....................          { 
....................              if(OutputBoth.B18 == 0)        //Both output 
....................              { 
....................                output_bit(Pbuzzer,1);   //Buzzer 
....................                output_bit(Pbell,1);     //Bell 
....................              } 
....................              else 
....................              { 
....................                if(OutputType.B18 == 1) output_bit(Pbuzzer,1);     //Buzzer 
....................                else output_bit(Pbell,1);                          //Bell 
....................              } 
....................          } 
....................        } 
....................  
....................    } 
....................    else if(FaultType.B18 == 0) 
....................    { 
....................       In2.B18 = 0x00; 
....................       Ack.B18 = 0; 
....................       Output.B18 = 1;      //Off LED 
....................  
....................       if(OutputType.B18== 1 || OutputBoth.B18 == 0)      //If Buzzer or Both 
....................       { 
....................          if(CheckAutoReset(0x01) == 1);   //Check other Input "Ack" or not if not,do nothing 
....................          else 
....................          { 
....................             output_bit(Pbuzzer,1);   //Clear Buzzer 
....................          } 
....................       } 
....................  
....................  
....................       if(OutputType.B18 == 0 || OutputBoth.B18 == 0)  //If Bell or Both 
....................       { 
....................          if(CheckAutoReset(0x02) == 1); 
....................          else 
....................          { 
....................             output_bit(Pbell,1);      //Clear Bell 
....................          } 
....................       } 
....................    } 
.................... //input19 
....................    if(((Inputt.B19 ^ InputType.B19) == 1) && (FaultType.B19 == 0))    // alarm1 occure and " Non Lock type" 
....................    { 
....................       if(In2.B19 == 0 && AutoAck == 0x0F && Ack.B19 == 0)   //use auto acknowlegde 
....................       { 
....................             TimeBase1s = 100 ;            //reload again 
....................             AutoAckDelayTime = AutoAckTime ; 
....................       } 
....................  
....................       In2.B19 = 1; 
....................       if(Ack.B19 == 0) 
....................       { 
....................          if(FlashingFlag == 0) 
....................             { 
....................                Output.B19 = 0;           //Flash output1 
....................             } 
....................             else 
....................             { 
....................                Output.B19 = 1; 
....................             } 
....................          if (~AutoTestFlag) 
....................          { 
....................              if(OutputBoth.B19 == 0)        //Both output 
....................              { 
....................                output_bit(Pbuzzer,1);   //Buzzer 
....................                output_bit(Pbell,1);     //Bell 
....................              } 
....................              else 
....................              { 
....................                if(OutputType.B19 == 1) output_bit(Pbuzzer,1);     //Buzzer 
....................                else output_bit(Pbell,1);                          //Bell 
....................              } 
....................          } 
....................        } 
....................  
....................    } 
....................    else if(FaultType.B19 == 0) 
....................    { 
....................       In2.B19 = 0x00; 
....................       Ack.B19 = 0; 
....................       Output.B19 = 1;      //Off LED 
....................  
....................       if(OutputType.B19== 1 || OutputBoth.B19 == 0)      //If Buzzer or Both 
....................       { 
....................          if(CheckAutoReset(0x01) == 1);   //Check other Input "Ack" or not if not,do nothing 
....................          else 
....................          { 
....................             output_bit(Pbuzzer,1);   //Clear Buzzer 
....................          } 
....................       } 
....................  
....................  
....................       if(OutputType.B19 == 0 || OutputBoth.B19== 0)  //If Bell or Both 
....................       { 
....................          if(CheckAutoReset(0x02) == 1); 
....................          else 
....................          { 
....................             output_bit(Pbell,1);      //Clear Bell 
....................          } 
....................       } 
....................    } 
....................    //input20 
....................    if(((Inputt.B20 ^ InputType.B20) == 1) && (FaultType.B20 == 0))    // alarm1 occure and " Non Lock type" 
....................    { 
....................       if(In2.B20 == 0 && AutoAck == 0x0F && Ack.B20 == 0)   //use auto acknowlegde 
....................       { 
....................             TimeBase1s = 100 ;            //reload again 
....................             AutoAckDelayTime = AutoAckTime ; 
....................       } 
....................  
....................       In2.B20 = 1; 
....................       if(Ack.B20 == 0) 
....................       { 
....................          if(FlashingFlag == 0) 
....................             { 
....................                Output.B20 = 0;           //Flash output1 
....................             } 
....................             else 
....................             { 
....................                Output.B20 = 1; 
....................             } 
....................          if (~AutoTestFlag) 
....................          { 
....................              if(OutputBoth.B20 == 0)        //Both output 
....................              { 
....................                output_bit(Pbuzzer,1);   //Buzzer 
....................                output_bit(Pbell,1);     //Bell 
....................              } 
....................              else 
....................              { 
....................                if(OutputType.B20 == 1) output_bit(Pbuzzer,1);     //Buzzer 
....................                else output_bit(Pbell,1);                          //Bell 
....................              } 
....................          } 
....................        } 
....................  
....................    } 
....................    else if(FaultType.B20 == 0) 
....................    { 
....................       In2.B20 = 0x00; 
....................       Ack.B20 = 0; 
....................       Output.B20 = 1;      //Off LED 
....................  
....................       if(OutputType.B20== 1 || OutputBoth.B20 == 0)      //If Buzzer or Both 
....................       { 
....................          if(CheckAutoReset(0x01) == 1);   //Check other Input "Ack" or not if not,do nothing 
....................          else 
....................          { 
....................             output_bit(Pbuzzer,1);   //Clear Buzzer 
....................          } 
....................       } 
....................  
....................  
....................       if(OutputType.B20 == 0 || OutputBoth.B20 == 0)  //If Bell or Both 
....................       { 
....................          if(CheckAutoReset(0x02) == 1); 
....................          else 
....................          { 
....................             output_bit(Pbell,1);      //Clear Bell 
....................          } 
....................       } 
....................    } 
....................    */ 
....................  //} 
.................... } 
47CC:  MOVLB  0
47CE:  RETLW  00
....................  
.................... ////////////////////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... void Send_Ouput(void) 
.................... { 
....................  
....................    if(T_test == 0x00) 
*
1812:  MOVF   2C,F
1814:  BTFSS  FD8.2
1816:  BRA    1A44
....................    { 
....................       //if(NoOfPoint >= 10) 
....................       //{ 
....................        
....................       
....................            if(Output.B1)//++++++++++++B1+++++++++++++++++++++ 
1818:  MOVLB  1
181A:  BTFSS  x0C.0
181C:  BRA    1824
....................            { 
....................              bit_clear(Green1_8,0); bit_clear(Red1_8,0); 
181E:  BCF    4F.0
1820:  BCF    4B.0
....................            } 
....................            else 
1822:  BRA    184C
....................            { 
....................              //bit_set(OUTRed1_8,0); bit_clear(OUTGreen1_8,0); 
....................              if((RED_Colour.B1 )&&(GREEN_Colour.B1 ==0 ))//Red 
1824:  BTFSS  x22.0
1826:  BRA    1832
1828:  BTFSC  x24.0
182A:  BRA    1832
....................              { 
....................                bit_set(Red1_8,0); bit_clear(Green1_8,0); 
182C:  BSF    4B.0
182E:  BCF    4F.0
....................              } 
....................              else if((RED_Colour.B1==0 )&&(GREEN_Colour.B1))//Green 
1830:  BRA    184C
1832:  BTFSC  x22.0
1834:  BRA    1840
1836:  BTFSS  x24.0
1838:  BRA    1840
....................              { 
....................                bit_clear(Red1_8,0); bit_set(Green1_8,0);  
183A:  BCF    4B.0
183C:  BSF    4F.0
....................              } 
....................              else if((RED_Colour.B1)&&(GREEN_Colour.B1))//Ambian 
183E:  BRA    184C
1840:  BTFSS  x22.0
1842:  BRA    184C
1844:  BTFSS  x24.0
1846:  BRA    184C
....................              { 
....................                bit_set(Red1_8,0); bit_set(Green1_8,0) ;  
1848:  BSF    4B.0
184A:  BSF    4F.0
....................              }   
....................            } 
....................            //////////////////////////////////////////////////////// 
....................            if(Output.B2)//++++++++++++B2+++++++++++++++++++++ 
184C:  BTFSS  x0C.1
184E:  BRA    1856
....................            { 
....................              bit_clear(Green1_8,1); bit_clear(Red1_8,1); 
1850:  BCF    4F.1
1852:  BCF    4B.1
....................            } 
....................            else 
1854:  BRA    187E
....................            { 
....................              //bit_set(OUTRed1_8,0); bit_clear(OUTGreen1_8,0); 
....................              if((RED_Colour.B2 )&&(GREEN_Colour.B2 ==0 ))//Red 
1856:  BTFSS  x22.1
1858:  BRA    1864
185A:  BTFSC  x24.1
185C:  BRA    1864
....................              { 
....................                bit_set(Red1_8,1); bit_clear(Green1_8,1); 
185E:  BSF    4B.1
1860:  BCF    4F.1
....................              } 
....................              else if((RED_Colour.B2==0 )&&(GREEN_Colour.B2))//Green 
1862:  BRA    187E
1864:  BTFSC  x22.1
1866:  BRA    1872
1868:  BTFSS  x24.1
186A:  BRA    1872
....................              { 
....................                bit_clear(Red1_8,1); bit_set(Green1_8,1);  
186C:  BCF    4B.1
186E:  BSF    4F.1
....................              } 
....................              else if((RED_Colour.B2)&&(GREEN_Colour.B2))//Ambian 
1870:  BRA    187E
1872:  BTFSS  x22.1
1874:  BRA    187E
1876:  BTFSS  x24.1
1878:  BRA    187E
....................              { 
....................                bit_set(Red1_8,1); bit_set(Green1_8,1) ;  
187A:  BSF    4B.1
187C:  BSF    4F.1
....................              }   
....................            } 
....................            //////////////////////////////////////////////////////// 
....................            if(Output.B3)//++++++++++++B3+++++++++++++++++++++ 
187E:  BTFSS  x0C.2
1880:  BRA    1888
....................            { 
....................              bit_clear(Green1_8,2); bit_clear(Red1_8,2); 
1882:  BCF    4F.2
1884:  BCF    4B.2
....................            } 
....................            else 
1886:  BRA    18B0
....................            { 
....................              //bit_set(OUTRed1_8,0); bit_clear(OUTGreen1_8,0); 
....................              if((RED_Colour.B3 )&&(GREEN_Colour.B3 ==0 ))//Red 
1888:  BTFSS  x22.2
188A:  BRA    1896
188C:  BTFSC  x24.2
188E:  BRA    1896
....................              { 
....................                bit_set(Red1_8,2); bit_clear(Green1_8,2); 
1890:  BSF    4B.2
1892:  BCF    4F.2
....................              } 
....................              else if((RED_Colour.B3==0 )&&(GREEN_Colour.B3))//Green 
1894:  BRA    18B0
1896:  BTFSC  x22.2
1898:  BRA    18A4
189A:  BTFSS  x24.2
189C:  BRA    18A4
....................              { 
....................                bit_clear(Red1_8,2); bit_set(Green1_8,2);  
189E:  BCF    4B.2
18A0:  BSF    4F.2
....................              } 
....................              else if((RED_Colour.B3)&&(GREEN_Colour.B3))//Ambian 
18A2:  BRA    18B0
18A4:  BTFSS  x22.2
18A6:  BRA    18B0
18A8:  BTFSS  x24.2
18AA:  BRA    18B0
....................              { 
....................                bit_set(Red1_8,2); bit_set(Green1_8,2) ;  
18AC:  BSF    4B.2
18AE:  BSF    4F.2
....................              }   
....................            } 
....................            //////////////////////////////////////////////////////// 
....................            if(Output.B4)//++++++++++++B4+++++++++++++++++++++ 
18B0:  BTFSS  x0C.3
18B2:  BRA    18BA
....................            { 
....................              bit_clear(Green1_8,3); bit_clear(Red1_8,3); 
18B4:  BCF    4F.3
18B6:  BCF    4B.3
....................            } 
....................            else 
18B8:  BRA    18E2
....................            { 
....................              //bit_set(OUTRed1_8,0); bit_clear(OUTGreen1_8,0); 
....................              if((RED_Colour.B4 )&&(GREEN_Colour.B4 ==0 ))//Red 
18BA:  BTFSS  x22.3
18BC:  BRA    18C8
18BE:  BTFSC  x24.3
18C0:  BRA    18C8
....................              { 
....................                bit_set(Red1_8,3); bit_clear(Green1_8,3); 
18C2:  BSF    4B.3
18C4:  BCF    4F.3
....................              } 
....................              else if((RED_Colour.B4==0 )&&(GREEN_Colour.B4))//Green 
18C6:  BRA    18E2
18C8:  BTFSC  x22.3
18CA:  BRA    18D6
18CC:  BTFSS  x24.3
18CE:  BRA    18D6
....................              { 
....................                bit_clear(Red1_8,3); bit_set(Green1_8,3);  
18D0:  BCF    4B.3
18D2:  BSF    4F.3
....................              } 
....................              else if((RED_Colour.B4)&&(GREEN_Colour.B4))//Ambian 
18D4:  BRA    18E2
18D6:  BTFSS  x22.3
18D8:  BRA    18E2
18DA:  BTFSS  x24.3
18DC:  BRA    18E2
....................              { 
....................                bit_set(Red1_8,3); bit_set(Green1_8,3) ;  
18DE:  BSF    4B.3
18E0:  BSF    4F.3
....................              }   
....................            } 
....................            //////////////////////////////////////////////////////// 
....................            if(Output.B5)//++++++++++++B5+++++++++++++++++++++ 
18E2:  BTFSS  x0C.4
18E4:  BRA    18EC
....................            { 
....................              bit_clear(Green1_8,4); bit_clear(Red1_8,4); 
18E6:  BCF    4F.4
18E8:  BCF    4B.4
....................            } 
....................            else 
18EA:  BRA    1914
....................            { 
....................              //bit_set(OUTRed1_8,0); bit_clear(OUTGreen1_8,0); 
....................              if((RED_Colour.B5 )&&(GREEN_Colour.B5 ==0 ))//Red 
18EC:  BTFSS  x22.4
18EE:  BRA    18FA
18F0:  BTFSC  x24.4
18F2:  BRA    18FA
....................              { 
....................                bit_set(Red1_8,4); bit_clear(Green1_8,4); 
18F4:  BSF    4B.4
18F6:  BCF    4F.4
....................              } 
....................              else if((RED_Colour.B5==0 )&&(GREEN_Colour.B5))//Green 
18F8:  BRA    1914
18FA:  BTFSC  x22.4
18FC:  BRA    1908
18FE:  BTFSS  x24.4
1900:  BRA    1908
....................              { 
....................                bit_clear(Red1_8,4); bit_set(Green1_8,4);  
1902:  BCF    4B.4
1904:  BSF    4F.4
....................              } 
....................              else if((RED_Colour.B5)&&(GREEN_Colour.B5))//Ambian 
1906:  BRA    1914
1908:  BTFSS  x22.4
190A:  BRA    1914
190C:  BTFSS  x24.4
190E:  BRA    1914
....................              { 
....................                bit_set(Red1_8,4); bit_set(Green1_8,4) ;  
1910:  BSF    4B.4
1912:  BSF    4F.4
....................              }   
....................            } 
....................            //////////////////////////////////////////////////////// 
....................            if(Output.B6)//++++++++++++B6+++++++++++++++++++++ 
1914:  BTFSS  x0C.5
1916:  BRA    191E
....................            { 
....................              bit_clear(Green1_8,5); bit_clear(Red1_8,5); 
1918:  BCF    4F.5
191A:  BCF    4B.5
....................            } 
....................            else 
191C:  BRA    1946
....................            { 
....................              //bit_set(OUTRed1_8,0); bit_clear(OUTGreen1_8,0); 
....................              if((RED_Colour.B6 )&&(GREEN_Colour.B6 ==0 ))//Red 
191E:  BTFSS  x22.5
1920:  BRA    192C
1922:  BTFSC  x24.5
1924:  BRA    192C
....................              { 
....................                bit_set(Red1_8,5); bit_clear(Green1_8,5); 
1926:  BSF    4B.5
1928:  BCF    4F.5
....................              } 
....................              else if((RED_Colour.B6==0 )&&(GREEN_Colour.B6))//Green 
192A:  BRA    1946
192C:  BTFSC  x22.5
192E:  BRA    193A
1930:  BTFSS  x24.5
1932:  BRA    193A
....................              { 
....................                bit_clear(Red1_8,5); bit_set(Green1_8,5);  
1934:  BCF    4B.5
1936:  BSF    4F.5
....................              } 
....................              else if((RED_Colour.B6)&&(GREEN_Colour.B6))//Ambian 
1938:  BRA    1946
193A:  BTFSS  x22.5
193C:  BRA    1946
193E:  BTFSS  x24.5
1940:  BRA    1946
....................              { 
....................                bit_set(Red1_8,5); bit_set(Green1_8,5) ;  
1942:  BSF    4B.5
1944:  BSF    4F.5
....................              }   
....................            } 
....................            //////////////////////////////////////////////////////// 
....................            if(Output.B7)//++++++++++++B7+++++++++++++++++++++ 
1946:  BTFSS  x0C.6
1948:  BRA    1950
....................            { 
....................              bit_clear(Green1_8,6); bit_clear(Red1_8,6); 
194A:  BCF    4F.6
194C:  BCF    4B.6
....................            } 
....................            else 
194E:  BRA    1978
....................            { 
....................              //bit_set(OUTRed1_8,0); bit_clear(OUTGreen1_8,0); 
....................              if((RED_Colour.B7 )&&(GREEN_Colour.B7 ==0 ))//Red 
1950:  BTFSS  x22.6
1952:  BRA    195E
1954:  BTFSC  x24.6
1956:  BRA    195E
....................              { 
....................                bit_set(Red1_8,6); bit_clear(Green1_8,6); 
1958:  BSF    4B.6
195A:  BCF    4F.6
....................              } 
....................              else if((RED_Colour.B7==0 )&&(GREEN_Colour.B7))//Green 
195C:  BRA    1978
195E:  BTFSC  x22.6
1960:  BRA    196C
1962:  BTFSS  x24.6
1964:  BRA    196C
....................              { 
....................                bit_clear(Red1_8,6); bit_set(Green1_8,6);  
1966:  BCF    4B.6
1968:  BSF    4F.6
....................              } 
....................              else if((RED_Colour.B7)&&(GREEN_Colour.B7))//Ambian 
196A:  BRA    1978
196C:  BTFSS  x22.6
196E:  BRA    1978
1970:  BTFSS  x24.6
1972:  BRA    1978
....................              { 
....................                bit_set(Red1_8,6); bit_set(Green1_8,6) ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           
1974:  BSF    4B.6
1976:  BSF    4F.6
....................              }   
....................            } 
....................            //////////////////////////////////////////////////////// 
....................            if(Output.B8)//++++++++++++B8+++++++++++++++++++++ 
1978:  BTFSS  x0C.7
197A:  BRA    1982
....................            { 
....................              bit_clear(Green1_8,7); bit_clear(Red1_8,7); 
197C:  BCF    4F.7
197E:  BCF    4B.7
....................            } 
....................            else 
1980:  BRA    19AA
....................            { 
....................              //bit_set(OUTRed1_8,0); bit_clear(OUTGreen1_8,0); 
....................              if((RED_Colour.B8 )&&(GREEN_Colour.B8 ==0 ))//Red 
1982:  BTFSS  x22.7
1984:  BRA    1990
1986:  BTFSC  x24.7
1988:  BRA    1990
....................              { 
....................                bit_set(Red1_8,7); bit_clear(Green1_8,7); 
198A:  BSF    4B.7
198C:  BCF    4F.7
....................              } 
....................              else if((RED_Colour.B8==0 )&&(GREEN_Colour.B8))//Green 
198E:  BRA    19AA
1990:  BTFSC  x22.7
1992:  BRA    199E
1994:  BTFSS  x24.7
1996:  BRA    199E
....................              { 
....................                bit_clear(Red1_8,7); bit_set(Green1_8,7);  
1998:  BCF    4B.7
199A:  BSF    4F.7
....................              } 
....................              else if((RED_Colour.B8)&&(GREEN_Colour.B8))//Ambian 
199C:  BRA    19AA
199E:  BTFSS  x22.7
19A0:  BRA    19AA
19A2:  BTFSS  x24.7
19A4:  BRA    19AA
....................              { 
....................                bit_set(Red1_8,7); bit_set(Green1_8,7) ;  
19A6:  BSF    4B.7
19A8:  BSF    4F.7
....................              }   
....................            } 
....................            //////////////////////////////////////////////////////// 
....................            //////////////////////////////////////////////////////// 
....................            if(Output.B9)//++++++++++++B9+++++++++++++++++++++ 
19AA:  BTFSS  x0D.0
19AC:  BRA    19B4
....................            { 
....................              bit_clear(Green9_10,0); bit_clear(Red9_10,0); 
19AE:  BCF    50.0
19B0:  BCF    4C.0
....................            } 
....................            else 
19B2:  BRA    19DC
....................            { 
....................              //bit_set(OUTRed1_8,0); bit_clear(OUTGreen1_8,0); 
....................              if((RED_Colour.B9 )&&(GREEN_Colour.B9 ==0 ))//Red 
19B4:  BTFSS  x23.0
19B6:  BRA    19C2
19B8:  BTFSC  x25.0
19BA:  BRA    19C2
....................              { 
....................                bit_set(Red9_10,0); bit_clear(Green9_10,0); 
19BC:  BSF    4C.0
19BE:  BCF    50.0
....................              } 
....................              else if((RED_Colour.B9==0 )&&(GREEN_Colour.B9))//Green 
19C0:  BRA    19DC
19C2:  BTFSC  x23.0
19C4:  BRA    19D0
19C6:  BTFSS  x25.0
19C8:  BRA    19D0
....................              { 
....................                bit_clear(Red9_10,0); bit_set(Green9_10,0);  
19CA:  BCF    4C.0
19CC:  BSF    50.0
....................              } 
....................              else if((RED_Colour.B9)&&(GREEN_Colour.B9))//Ambian 
19CE:  BRA    19DC
19D0:  BTFSS  x23.0
19D2:  BRA    19DC
19D4:  BTFSS  x25.0
19D6:  BRA    19DC
....................              { 
....................                bit_set(Red9_10,0); bit_set(Green9_10,0) ;  
19D8:  BSF    4C.0
19DA:  BSF    50.0
....................              }   
....................            } 
....................            //////////////////////////////////////////////////////// 
....................             if(Output.B10)//++++++++++++B10+++++++++++++++++++++ 
19DC:  BTFSS  x0D.1
19DE:  BRA    19E6
....................            { 
....................              bit_clear(Green9_10,1); bit_clear(Red9_10,1); 
19E0:  BCF    50.1
19E2:  BCF    4C.1
....................            } 
....................            else 
19E4:  BRA    1A0E
....................            { 
....................              //bit_set(OUTRed1_8,0); bit_clear(OUTGreen1_8,0); 
....................              if((RED_Colour.B10 )&&(GREEN_Colour.B10 ==0 ))//Red 
19E6:  BTFSS  x23.1
19E8:  BRA    19F4
19EA:  BTFSC  x25.1
19EC:  BRA    19F4
....................              { 
....................                bit_set(Red9_10,1); bit_clear(Green9_10,1); 
19EE:  BSF    4C.1
19F0:  BCF    50.1
....................              } 
....................              else if((RED_Colour.B10==0 )&&(GREEN_Colour.B10))//Green 
19F2:  BRA    1A0E
19F4:  BTFSC  x23.1
19F6:  BRA    1A02
19F8:  BTFSS  x25.1
19FA:  BRA    1A02
....................              { 
....................                bit_clear(Red9_10,1); bit_set(Green9_10,1);  
19FC:  BCF    4C.1
19FE:  BSF    50.1
....................              } 
....................              else if((RED_Colour.B10)&&(GREEN_Colour.B10))//Ambian 
1A00:  BRA    1A0E
1A02:  BTFSS  x23.1
1A04:  BRA    1A0E
1A06:  BTFSS  x25.1
1A08:  BRA    1A0E
....................              { 
....................                bit_set(Red9_10,1); bit_set(Green9_10,1) ;  
1A0A:  BSF    4C.1
1A0C:  BSF    50.1
....................              }   
....................            } 
....................             
....................        // } 
....................         /* 
....................        // if(NoOfPoint >= 20) 
....................       //{    
....................            //////////////////////////////////////////////////////// 
....................             if(Output.B11)//++++++++++++B11+++++++++++++++++++++ 
....................            { 
....................              bit_clear(Green11_18,0); bit_clear(Red11_18,0); 
....................            } 
....................            else 
....................            { 
....................              //bit_set(OUTRed1_8,0); bit_clear(OUTGreen1_8,0); 
....................              if((RED_Colour.B11 )&&(GREEN_Colour.B11 ==0 ))//Red 
....................              { 
....................                bit_set(Red11_18,0); bit_clear(Green11_18,0); 
....................              } 
....................              else if((RED_Colour.B11==0 )&&(GREEN_Colour.B11))//Green 
....................              { 
....................                bit_clear(Red11_18,0); bit_set(Green11_18,0);  
....................              } 
....................              else if((RED_Colour.B11)&&(GREEN_Colour.B11))//Ambian 
....................              { 
....................                bit_set(Red11_18,0); bit_set(Green11_18,0) ;  
....................              }   
....................            } 
....................            //////////////////////////////////////////////////////// 
....................             if(Output.B11)//++++++++++++B11+++++++++++++++++++++ 
....................            { 
....................              bit_clear(Green11_18,0); bit_clear(Red11_18,0); 
....................            } 
....................            else 
....................            { 
....................              //bit_set(OUTRed1_8,0); bit_clear(OUTGreen1_8,0); 
....................              if((RED_Colour.B11 )&&(GREEN_Colour.B11 ==0 ))//Red 
....................              { 
....................                bit_set(Red11_18,0); bit_clear(Green11_18,0); 
....................              } 
....................              else if((RED_Colour.B11==0 )&&(GREEN_Colour.B11))//Green 
....................              { 
....................                bit_clear(Red11_18,0); bit_set(Green11_18,0);  
....................              } 
....................              else if((RED_Colour.B11)&&(GREEN_Colour.B11))//Ambian 
....................              { 
....................                bit_set(Red11_18,0); bit_set(Green11_18,0) ;  
....................              }   
....................            } 
....................            //////////////////////////////////////////////////////// 
....................            if(Output.B12)//++++++++++++B12+++++++++++++++++++++ 
....................            { 
....................              bit_clear(Green11_18,1); bit_clear(Red11_18,1); 
....................            } 
....................            else 
....................            { 
....................              //bit_set(OUTRed1_8,0); bit_clear(OUTGreen1_8,0); 
....................              if((RED_Colour.B12 )&&(GREEN_Colour.B12 ==0 ))//Red 
....................              { 
....................                bit_set(Red11_18,1); bit_clear(Green11_18,1); 
....................              } 
....................              else if((RED_Colour.B12==0 )&&(GREEN_Colour.B12))//Green 
....................              { 
....................                bit_clear(Red11_18,1); bit_set(Green11_18,1);  
....................              } 
....................              else if((RED_Colour.B12)&&(GREEN_Colour.B12))//Ambian 
....................              { 
....................                bit_set(Red11_18,1); bit_set(Green11_18,1) ;  
....................              }   
....................            } 
....................            //////////////////////////////////////////////////////// 
....................            if(Output.B13)//++++++++++++B13+++++++++++++++++++++ 
....................            { 
....................              bit_clear(Green11_18,2); bit_clear(Red11_18,2); 
....................            } 
....................            else 
....................            { 
....................              //bit_set(OUTRed1_8,0); bit_clear(OUTGreen1_8,0); 
....................              if((RED_Colour.B13 )&&(GREEN_Colour.B13 ==0 ))//Red 
....................              { 
....................                bit_set(Red11_18,2); bit_clear(Green11_18,2); 
....................              } 
....................              else if((RED_Colour.B13==0 )&&(GREEN_Colour.B13))//Green 
....................              { 
....................                bit_clear(Red11_18,2); bit_set(Green11_18,2);  
....................              } 
....................              else if((RED_Colour.B13)&&(GREEN_Colour.B13))//Ambian 
....................              { 
....................                bit_set(Red11_18,2); bit_set(Green11_18,2) ;  
....................              }   
....................            } 
....................            //////////////////////////////////////////////////////// 
....................            if(Output.B14)//++++++++++++B14+++++++++++++++++++++ 
....................            { 
....................              bit_clear(Green11_18,3); bit_clear(Red11_18,3); 
....................            } 
....................            else 
....................            { 
....................              //bit_set(OUTRed1_8,0); bit_clear(OUTGreen1_8,0); 
....................              if((RED_Colour.B14 )&&(GREEN_Colour.B14 ==0 ))//Red 
....................              { 
....................                bit_set(Red11_18,3); bit_clear(Green11_18,3); 
....................              } 
....................              else if((RED_Colour.B14==0 )&&(GREEN_Colour.B14))//Green 
....................              { 
....................                bit_clear(Red11_18,3); bit_set(Green11_18,3);  
....................              } 
....................              else if((RED_Colour.B14)&&(GREEN_Colour.B14))//Ambian 
....................              { 
....................                bit_set(Red11_18,3); bit_set(Green11_18,3) ;  
....................              }   
....................            } 
....................            //////////////////////////////////////////////////////// 
....................            if(Output.B15)//++++++++++++B15+++++++++++++++++++++ 
....................            { 
....................              bit_clear(Green11_18,4); bit_clear(Red11_18,4); 
....................            } 
....................            else 
....................            { 
....................              //bit_set(OUTRed1_8,0); bit_clear(OUTGreen1_8,0); 
....................              if((RED_Colour.B15 )&&(GREEN_Colour.B15 ==0 ))//Red 
....................              { 
....................                bit_set(Red11_18,4); bit_clear(Green11_18,4); 
....................              } 
....................              else if((RED_Colour.B15==0 )&&(GREEN_Colour.B15))//Green 
....................              { 
....................                bit_clear(Red11_18,4); bit_set(Green11_18,4);  
....................              } 
....................              else if((RED_Colour.B15)&&(GREEN_Colour.B15))//Ambian 
....................              { 
....................                bit_set(Red11_18,4); bit_set(Green11_18,4) ;  
....................              }   
....................            } 
....................            //////////////////////////////////////////////////////// 
....................            if(Output.B16)//++++++++++++B16+++++++++++++++++++++ 
....................            { 
....................              bit_clear(Green11_18,5); bit_clear(Red11_18,5); 
....................            } 
....................            else 
....................            { 
....................              //bit_set(OUTRed1_8,0); bit_clear(OUTGreen1_8,0); 
....................              if((RED_Colour.B16 )&&(GREEN_Colour.B16 ==0 ))//Red 
....................              { 
....................                bit_set(Red11_18,5); bit_clear(Green11_18,5); 
....................              } 
....................              else if((RED_Colour.B16==0 )&&(GREEN_Colour.B16))//Green 
....................              { 
....................                bit_clear(Red11_18,5); bit_set(Green11_18,5);  
....................              } 
....................              else if((RED_Colour.B16)&&(GREEN_Colour.B16))//Ambian 
....................              { 
....................                bit_set(Red11_18,5); bit_set(Green11_18,5) ;  
....................              }   
....................            } 
....................            //////////////////////////////////////////////////////// 
....................            if(Output.B17)//++++++++++++B17+++++++++++++++++++++ 
....................            { 
....................              bit_clear(Green11_18,6); bit_clear(Red11_18,6); 
....................            } 
....................            else 
....................            { 
....................              //bit_set(OUTRed1_8,0); bit_clear(OUTGreen1_8,0); 
....................              if((RED_Colour.B17 )&&(GREEN_Colour.B17 ==0 ))//Red 
....................              { 
....................                bit_set(Red11_18,6); bit_clear(Green11_18,6); 
....................              } 
....................              else if((RED_Colour.B17==0 )&&(GREEN_Colour.B17))//Green 
....................              { 
....................                bit_clear(Red11_18,6); bit_set(Green11_18,6);  
....................              } 
....................              else if((RED_Colour.B17)&&(GREEN_Colour.B17))//Ambian 
....................              { 
....................                bit_set(Red11_18,6); bit_set(Green11_18,6) ;  
....................              }   
....................            } 
....................            //////////////////////////////////////////////////////// 
....................            if(Output.B18)//++++++++++++B18+++++++++++++++++++++ 
....................            { 
....................              bit_clear(Green11_18,7); bit_clear(Red11_18,7); 
....................            } 
....................            else 
....................            { 
....................              //bit_set(OUTRed1_8,0); bit_clear(OUTGreen1_8,0); 
....................              if((RED_Colour.B18 )&&(GREEN_Colour.B18 ==0 ))//Red 
....................              { 
....................                bit_set(Red11_18,7); bit_clear(Green11_18,7); 
....................              } 
....................              else if((RED_Colour.B18==0 )&&(GREEN_Colour.B18))//Green 
....................              { 
....................                bit_clear(Red11_18,7); bit_set(Green11_18,7);  
....................              } 
....................              else if((RED_Colour.B18)&&(GREEN_Colour.B18))//Ambian 
....................              { 
....................                bit_set(Red11_18,7); bit_set(Green11_18,7) ;  
....................              }   
....................            } 
....................            //////////////////////////////////////////////////////// 
....................            if(Output.B19)//++++++++++++B19+++++++++++++++++++++ 
....................            { 
....................              bit_clear(Green19_20,0); bit_clear(Red19_20,0); 
....................            } 
....................            else 
....................            { 
....................              //bit_set(OUTRed1_8,0); bit_clear(OUTGreen1_8,0); 
....................              if((RED_Colour.B19 )&&(GREEN_Colour.B19 ==0 ))//Red 
....................              { 
....................                bit_set(Red19_20,0); bit_clear(Green19_20,0); 
....................              } 
....................              else if((RED_Colour.B19==0 )&&(GREEN_Colour.B19))//Green 
....................              { 
....................                bit_clear(Red19_20,0); bit_set(Green19_20,0);  
....................              } 
....................              else if((RED_Colour.B19)&&(GREEN_Colour.B19))//Ambian 
....................              { 
....................                bit_set(Red19_20,0); bit_set(Green19_20,0) ;  
....................              }   
....................            } 
....................            //////////////////////////////////////////////////////// 
....................            if(Output.B20)//++++++++++++B20+++++++++++++++++++++ 
....................            { 
....................              bit_clear(Green19_20,1); bit_clear(Red19_20,1); 
....................            } 
....................            else 
....................            { 
....................              //bit_set(OUTRed1_8,0); bit_clear(OUTGreen1_8,0); 
....................              if((RED_Colour.B20 )&&(GREEN_Colour.B20 ==0 ))//Red 
....................              { 
....................                bit_set(Red19_20,1); bit_clear(Green19_20,1); 
....................              } 
....................              else if((RED_Colour.B20==0 )&&(GREEN_Colour.B20))//Green 
....................              { 
....................                bit_clear(Red19_20,1); bit_set(Green19_20,1);  
....................              } 
....................              else if((RED_Colour.B20)&&(GREEN_Colour.B20))//Ambian 
....................              { 
....................                bit_set(Red19_20,1); bit_set(Green19_20,1) ;  
....................              }   
....................            } 
....................            */ 
....................            //////////////////////////////////////////////////////// 
....................           
....................       //}  
....................            
....................          
....................            IO_OUTPUT_A(IO_DEVICE_2, Red1_8); 
1A0E:  MOVLW  04
1A10:  MOVWF  xB3
1A12:  MOVFF  4B,1B4
1A16:  MOVLB  0
1A18:  RCALL  17E6
....................            IO_OUTPUT_B(IO_DEVICE_2, Red9_10); 
1A1A:  MOVLW  04
1A1C:  MOVLB  1
1A1E:  MOVWF  xB3
1A20:  MOVFF  4C,1B4
1A24:  MOVLB  0
1A26:  RCALL  17FC
....................             
....................             
....................            IO_OUTPUT_A(IO_DEVICE_3, Green1_8); 
1A28:  MOVLW  06
1A2A:  MOVLB  1
1A2C:  MOVWF  xB3
1A2E:  MOVFF  4F,1B4
1A32:  MOVLB  0
1A34:  RCALL  17E6
....................            IO_OUTPUT_B(IO_DEVICE_3, Green9_10); 
1A36:  MOVLW  06
1A38:  MOVLB  1
1A3A:  MOVWF  xB3
1A3C:  MOVFF  50,1B4
1A40:  MOVLB  0
1A42:  RCALL  17FC
....................            /* 
....................            IO_OUTPUT_A(IO_DEVICE_4, Red11_18); 
....................            IO_OUTPUT_B(IO_DEVICE_4, Red19_20); 
....................                       
....................            IO_OUTPUT_A(IO_DEVICE_5, Green11_18); 
....................            IO_OUTPUT_B(IO_DEVICE_5, Green19_20); 
....................            */ 
....................                                  
....................            //IO_OUTPUT_A(IO_DEVICE_4, Red1_8); //jj test 
....................            //IO_OUTPUT_B(IO_DEVICE_4, Red9_10); //jj test 
....................             
....................            //IO_OUTPUT_A(IO_DEVICE_5, Green1_8);  //jj test 
....................            //IO_OUTPUT_B(IO_DEVICE_5, Green9_10); //jj test 
....................                                             
....................             
....................    } 
....................  
.................... } 
1A44:  RETLW  00
.................... ////////////////////////////////////////////////////////////////// 
.................... void ForceAllAlarm(void) 
.................... { 
....................    if(NoOfPoint == 10) 
*
34B6:  MOVF   5E,W
34B8:  SUBLW  0A
34BA:  BNZ   34FA
....................    { 
....................       Inputt.B1 = ~InputType.B1; 
34BC:  MOVLB  1
34BE:  BCF    x0A.0
34C0:  BTFSS  x0E.0
34C2:  BSF    x0A.0
....................       Inputt.B2 = ~InputType.B2; 
34C4:  BCF    x0A.1
34C6:  BTFSS  x0E.1
34C8:  BSF    x0A.1
....................       Inputt.B3 = ~InputType.B3; 
34CA:  BCF    x0A.2
34CC:  BTFSS  x0E.2
34CE:  BSF    x0A.2
....................       Inputt.B4 = ~InputType.B4; 
34D0:  BCF    x0A.3
34D2:  BTFSS  x0E.3
34D4:  BSF    x0A.3
....................       Inputt.B5 = ~InputType.B5; 
34D6:  BCF    x0A.4
34D8:  BTFSS  x0E.4
34DA:  BSF    x0A.4
....................       Inputt.B6 = ~InputType.B6; 
34DC:  BCF    x0A.5
34DE:  BTFSS  x0E.5
34E0:  BSF    x0A.5
....................       Inputt.B7 = ~InputType.B7; 
34E2:  BCF    x0A.6
34E4:  BTFSS  x0E.6
34E6:  BSF    x0A.6
....................       Inputt.B8 = ~InputType.B8; 
34E8:  BCF    x0A.7
34EA:  BTFSS  x0E.7
34EC:  BSF    x0A.7
....................       Inputt.B9 = ~InputType.B9; 
34EE:  BCF    x0B.0
34F0:  BTFSS  x0F.0
34F2:  BSF    x0B.0
....................       Inputt.B10 = ~InputType.B10; 
34F4:  BCF    x0B.1
34F6:  BTFSS  x0F.1
34F8:  BSF    x0B.1
....................    } 
....................    /* 
....................    if(NoOfPoint == 20) 
....................    { 
....................       Inputt.B11 = ~InputType.B11; 
....................       Inputt.B12 = ~InputType.B12; 
....................       Inputt.B13 = ~InputType.B13; 
....................       Inputt.B14 = ~InputType.B14; 
....................       Inputt.B15 = ~InputType.B15; 
....................       Inputt.B16 = ~InputType.B16; 
....................       Inputt.B17 = ~InputType.B11; 
....................       Inputt.B18 = ~InputType.B12; 
....................       Inputt.B19 = ~InputType.B13; 
....................       Inputt.B20 = ~InputType.B14; 
....................    } 
....................     */   
....................  
....................    Ack.B1 = 0; 
34FA:  MOVLB  1
34FC:  BCF    x18.0
....................    Ack.B2 = 0; 
34FE:  BCF    x18.1
....................    Ack.B3 = 0; 
3500:  BCF    x18.2
....................    Ack.B4 = 0; 
3502:  BCF    x18.3
....................    Ack.B5 = 0; 
3504:  BCF    x18.4
....................    Ack.B6 = 0; 
3506:  BCF    x18.5
....................    Ack.B7 = 0; 
3508:  BCF    x18.6
....................    Ack.B8 = 0; 
350A:  BCF    x18.7
....................    Ack.B9 = 0; 
350C:  BCF    x19.0
....................    Ack.B10 = 0; 
350E:  BCF    x19.1
....................    /* 
....................    Ack.B11 = 0; 
....................    Ack.B12 = 0; 
....................    Ack.B13 = 0; 
....................    Ack.B14 = 0; 
....................    Ack.B15 = 0; 
....................    Ack.B16 = 0; 
....................    Ack.B17 = 0; 
....................    Ack.B18 = 0; 
....................    Ack.B19 = 0; 
....................    Ack.B20 = 0;   
....................    */ 
.................... } 
3510:  MOVLB  0
3512:  GOTO   4874 (RETURN)
....................  
....................  
....................  //////////////////////////////////////////////////////////////////////////////////////////////////// 
....................  //////////////////////////////////////////////////////////////////////////////////////////////////// 
.................... ///////////// Check Test //////////////// 
.................... void check_test(void) 
.................... { 
....................    int8 output_temp[8]; 
....................     
....................    output_temp[0] = Output1_8; 
*
47D0:  MOVFF  30,1AB
....................    output_temp[1] = output9_16; 
47D4:  MOVFF  31,1AC
....................  
....................  
....................        if((input(Ptest) == 0 && Test == 0)|| AutoTestFlag == 1) delay_ms(50); 
47D8:  BSF    F94.2
47DA:  BTFSC  F82.2
47DC:  BRA    47E2
47DE:  BTFSS  17.6
47E0:  BRA    47E6
47E2:  BTFSS  17.4
47E4:  BRA    47F2
47E6:  MOVLW  32
47E8:  MOVLB  1
47EA:  MOVWF  xB3
47EC:  MOVLB  0
47EE:  CALL   05C4
....................        if((input(Ptest) == 0 && Test == 0)|| AutoTestFlag == 1) 
47F2:  BSF    F94.2
47F4:  BTFSC  F82.2
47F6:  BRA    47FC
47F8:  BTFSS  17.6
47FA:  BRA    4800
47FC:  BTFSS  17.4
47FE:  BRA    485C
....................        { 
....................            if((input(Ptest) == 0 && Test == 0)|| AutoTestFlag ==1) 
4800:  BSF    F94.2
4802:  BTFSC  F82.2
4804:  BRA    480A
4806:  BTFSS  17.6
4808:  BRA    480E
480A:  BTFSS  17.4
480C:  BRA    485A
....................            { 
....................              restart_wdt(); 
480E:  CLRWDT
....................              if(T_test == 0) T_test = 0x06;    //3 second for time base 500 ms 
4810:  MOVF   2C,F
4812:  BNZ   4818
4814:  MOVLW  06
4816:  MOVWF  2C
....................               Test = 1; 
4818:  BSF    17.6
....................               //if(NoOfPoint >= 16) 
....................              // { 
....................               
....................                  IO_OUTPUT_A(IO_DEVICE_2, 0xFF); 
481A:  MOVLW  04
481C:  MOVLB  1
481E:  MOVWF  xB3
4820:  MOVLW  FF
4822:  MOVWF  xB4
4824:  MOVLB  0
4826:  CALL   17E6
....................                  IO_OUTPUT_B(IO_DEVICE_2, 0xFF); 
482A:  MOVLW  04
482C:  MOVLB  1
482E:  MOVWF  xB3
4830:  MOVLW  FF
4832:  MOVWF  xB4
4834:  MOVLB  0
4836:  CALL   17FC
....................                              
....................                  IO_OUTPUT_A(IO_DEVICE_3, 0xFF); 
483A:  MOVLW  06
483C:  MOVLB  1
483E:  MOVWF  xB3
4840:  MOVLW  FF
4842:  MOVWF  xB4
4844:  MOVLB  0
4846:  CALL   17E6
....................                  IO_OUTPUT_B(IO_DEVICE_3, 0xFF); 
484A:  MOVLW  06
484C:  MOVLB  1
484E:  MOVWF  xB3
4850:  MOVLW  FF
4852:  MOVWF  xB4
4854:  MOVLB  0
4856:  CALL   17FC
....................                   
....................                  //IO_OUTPUT_A(IO_DEVICE_4, 0xFF); 
....................                  //IO_OUTPUT_B(IO_DEVICE_4, 0xFF); 
....................                             
....................                  //IO_OUTPUT_A(IO_DEVICE_5, 0xFF); 
....................                  //IO_OUTPUT_B(IO_DEVICE_5, 0xFF); 
....................                   
....................                   
....................                  //PCF8575_write(0xFF,0x00,Input1_8_Wr_addr); 
....................                  //PCF8575_write(0xFF,0x00,Input9_16_Wr_addr); 
....................                  //IO_OUTPUT_B(IO_DEVICE_0, 0x00); 
....................                  //IO_OUTPUT_B(IO_DEVICE_1, 0x00); 
....................              // } 
....................               
....................            } 
....................        } 
....................        else if(input(Ptest) == 1 && Test == 1) 
485A:  BRA    486C
485C:  BSF    F94.2
485E:  BTFSS  F82.2
4860:  BRA    486C
4862:  BTFSS  17.6
4864:  BRA    486C
....................        { 
....................            T_test = 0x00; 
4866:  CLRF   2C
....................            Test = 0; 
4868:  BCF    17.6
....................            Test_fault = 0; 
486A:  BCF    17.5
....................        } 
....................  
....................  
....................        if(Test_fault == 1) 
486C:  BTFSS  17.5
486E:  BRA    4882
....................        { 
....................           ForceAllAlarm(); 
4870:  GOTO   34B6
....................           Anal_Function(); 
4874:  CALL   39A6
....................           //Test_fault = 0; 
....................           if(Input(Ptest) == 1) 
4878:  BSF    F94.2
487A:  BTFSS  F82.2
487C:  BRA    4880
....................           { 
....................             Test_fault = 0; 
487E:  BCF    17.5
....................           } 
....................        } 
....................        else if(input(Ptest) == 1 && Test == 1) 
4880:  BRA    4898
4882:  BSF    F94.2
4884:  BTFSS  F82.2
4886:  BRA    4898
4888:  BTFSS  17.6
488A:  BRA    4898
....................        { 
....................           if(NoOfPoint >= 16) 
488C:  MOVF   5E,W
488E:  SUBLW  0F
4890:  BC    4892
....................           { 
....................              //PCF8575_write(0xFF,output_temp[0],Input1_8_Wr_addr); 
....................              //PCF8575_write(0xFF,output_temp[1],Input9_16_Wr_addr); 
....................              //IO_OUTPUT_B(IO_DEVICE_0, output_temp[0]); 
....................              //IO_OUTPUT_B(IO_DEVICE_1, output_temp[1]);  
....................           } 
....................            
....................  
....................           T_test = 0x00; 
4892:  CLRF   2C
....................           Test = 0; 
4894:  BCF    17.6
....................           Test_fault = 0; 
4896:  BCF    17.5
....................        } 
.................... } 
4898:  GOTO   4F7E (RETURN)
....................  
....................  
.................... /////////////// Check acknowledge //////////////////////////// 
....................  
.................... void check_ack(void) 
.................... { 
....................  
....................    if((input(Pack) == 0 && Ack_F == 0) || AutoAckFlag == 1) delay_ms(50); //Acknowledge function 
*
1C7A:  BSF    F94.0
1C7C:  BTFSC  F82.0
1C7E:  BRA    1C84
1C80:  BTFSS  17.7
1C82:  BRA    1C88
1C84:  BTFSS  17.2
1C86:  BRA    1C94
1C88:  MOVLW  32
1C8A:  MOVLB  1
1C8C:  MOVWF  xB3
1C8E:  MOVLB  0
1C90:  CALL   05C4
....................    if((input(Pack) == 0 && Ack_F == 0) || AutoAckFlag == 1) 
1C94:  BSF    F94.0
1C96:  BTFSC  F82.0
1C98:  BRA    1C9E
1C9A:  BTFSS  17.7
1C9C:  BRA    1CA2
1C9E:  BTFSS  17.2
1CA0:  BRA    1D56
....................    { 
....................             AutoAckFlag = 0; 
1CA2:  BCF    17.2
....................             AutoAckDelayTime = 0x00; 
1CA4:  CLRF   1A
....................        
....................                   //if(In.B1 == 1 || ((Inputt.B1 ^ InputType.B1) == 1)) 
....................            if((In.B1 == 1 )||(In2.B1 == 1 )) 
1CA6:  MOVLB  1
1CA8:  BTFSC  x1A.0
1CAA:  BRA    1CB0
1CAC:  BTFSS  x1C.0
1CAE:  BRA    1CB8
....................            { 
....................              Ack.B1 = 1; 
1CB0:  BSF    x18.0
....................              In.B1 = 0; 
1CB2:  BCF    x1A.0
....................              In2.B1 = 0;      //for auto reset 
1CB4:  BCF    x1C.0
....................              Output.B1 = 0; 
1CB6:  BCF    x0C.0
....................            } 
....................            //if(In.B2 == 1 || ((Inputt.B2 ^ InputType.B2) == 1)) 
....................            if((In.B2 == 1)||(In2.B2 == 1)) 
1CB8:  BTFSC  x1A.1
1CBA:  BRA    1CC0
1CBC:  BTFSS  x1C.1
1CBE:  BRA    1CC8
....................            { 
....................              Ack.B2 = 1; 
1CC0:  BSF    x18.1
....................              In.B2 = 0; 
1CC2:  BCF    x1A.1
....................              In2.B2 = 0;      //for auto reset 
1CC4:  BCF    x1C.1
....................              Output.B2 = 0; 
1CC6:  BCF    x0C.1
....................            } 
....................            //if(In.B3 == 1 || ((Inputt.B3 ^ InputType.B3) == 1)) 
....................            if((In.B3 == 1)||(In2.B3 == 1)) 
1CC8:  BTFSC  x1A.2
1CCA:  BRA    1CD0
1CCC:  BTFSS  x1C.2
1CCE:  BRA    1CD8
....................            { 
....................              Ack.B3 = 1; 
1CD0:  BSF    x18.2
....................              In.B3 = 0; 
1CD2:  BCF    x1A.2
....................              In2.B3 = 0;      //for auto reset 
1CD4:  BCF    x1C.2
....................              Output.B3 = 0; 
1CD6:  BCF    x0C.2
....................            } 
....................            //if(In.B4 == 1 || ((Inputt.B4 ^ InputType.B4) == 1)) 
....................            if((In.B4 == 1)||(In2.B4 == 1)) 
1CD8:  BTFSC  x1A.3
1CDA:  BRA    1CE0
1CDC:  BTFSS  x1C.3
1CDE:  BRA    1CE8
....................            { 
....................              Ack.B4 = 1; 
1CE0:  BSF    x18.3
....................              In.B4 = 0; 
1CE2:  BCF    x1A.3
....................              In2.B4 = 0;      //for auto reset 
1CE4:  BCF    x1C.3
....................              Output.B4 = 0; 
1CE6:  BCF    x0C.3
....................            } 
....................            //if(In.B5 == 1 || ((Inputt.B5 ^ InputType.B5) == 1)) 
....................            if((In.B5 == 1)||(In2.B5 == 1)) 
1CE8:  BTFSC  x1A.4
1CEA:  BRA    1CF0
1CEC:  BTFSS  x1C.4
1CEE:  BRA    1CF8
....................            { 
....................              Ack.B5 = 1; 
1CF0:  BSF    x18.4
....................              In.B5 = 0; 
1CF2:  BCF    x1A.4
....................              In2.B5 = 0;      //for auto reset 
1CF4:  BCF    x1C.4
....................              Output.B5 = 0; 
1CF6:  BCF    x0C.4
....................            } 
....................            //if(In.B6 == 1 || ((Inputt.B6 ^ InputType.B6) == 1)) 
....................            if((In.B6 == 1 )||(In2.B6 == 1 )) 
1CF8:  BTFSC  x1A.5
1CFA:  BRA    1D00
1CFC:  BTFSS  x1C.5
1CFE:  BRA    1D08
....................            { 
....................              Ack.B6 = 1; 
1D00:  BSF    x18.5
....................              In.B6 = 0; 
1D02:  BCF    x1A.5
....................              In2.B6 = 0;      //for auto reset 
1D04:  BCF    x1C.5
....................              Output.B6 = 0; 
1D06:  BCF    x0C.5
....................            } 
....................            //if(In.B7 == 1 || ((Inputt.B7 ^ InputType.B7) == 1)) 
....................            if((In.B7 == 1 )||(In2.B7 == 1 )) 
1D08:  BTFSC  x1A.6
1D0A:  BRA    1D10
1D0C:  BTFSS  x1C.6
1D0E:  BRA    1D18
....................            { 
....................              Ack.B7 = 1; 
1D10:  BSF    x18.6
....................              In.B7 = 0; 
1D12:  BCF    x1A.6
....................              In2.B7 = 0;      //for auto reset 
1D14:  BCF    x1C.6
....................              Output.B7 = 0; 
1D16:  BCF    x0C.6
....................            } 
....................            //if(In.B8 == 1 || ((Inputt.B8 ^ InputType.B8) == 1)) 
....................            if((In.B8 == 1 )||(In2.B8 == 1 )) 
1D18:  BTFSC  x1A.7
1D1A:  BRA    1D20
1D1C:  BTFSS  x1C.7
1D1E:  BRA    1D28
....................            { 
....................              Ack.B8 = 1; 
1D20:  BSF    x18.7
....................              In.B8 = 0; 
1D22:  BCF    x1A.7
....................              In2.B8 = 0;      //for auto reset 
1D24:  BCF    x1C.7
....................              Output.B8 = 0; 
1D26:  BCF    x0C.7
....................            } 
....................           // if(In.B9 == 1 || ((Inputt.B9 ^ InputType.B9) == 1)) 
....................            if((In.B9 == 1 )||(In2.B9 == 1 )) 
1D28:  BTFSC  x1B.0
1D2A:  BRA    1D30
1D2C:  BTFSS  x1D.0
1D2E:  BRA    1D38
....................            { 
....................              Ack.B9 = 1; 
1D30:  BSF    x19.0
....................              In.B9 = 0; 
1D32:  BCF    x1B.0
....................              In2.B9 = 0;      //for auto reset 
1D34:  BCF    x1D.0
....................              Output.B9 = 0; 
1D36:  BCF    x0D.0
....................            } 
....................            //if(In.B10 == 1 || ((Inputt.B10 ^ InputType.B10) == 1)) 
....................            if((In.B10 == 1)||(In2.B10 == 1)) 
1D38:  BTFSC  x1B.1
1D3A:  BRA    1D40
1D3C:  BTFSS  x1D.1
1D3E:  BRA    1D48
....................            { 
....................              Ack.B10 = 1; 
1D40:  BSF    x19.1
....................              In.B10 = 0; 
1D42:  BCF    x1B.1
....................              In2.B10 = 0;      //for auto reset 
1D44:  BCF    x1D.1
....................              Output.B10 = 0; 
1D46:  BCF    x0D.1
....................            } 
....................        
....................        
....................             Ack_F = 1; 
1D48:  BSF    17.7
....................             output_bit(Pbuzzer,0);   //Buzzer 
1D4A:  BCF    F89.4
1D4C:  BCF    F92.4
....................             output_bit(Pbell,0);     //Bell 
1D4E:  BCF    F89.3
1D50:  BCF    F92.3
....................    } 
....................    else if(input(Pack) == 1 && Ack_F == 1) 
1D52:  BRA    1D64
1D54:  MOVLB  0
1D56:  BSF    F94.0
1D58:  BTFSS  F82.0
1D5A:  BRA    1D62
1D5C:  BTFSS  17.7
1D5E:  BRA    1D62
....................    { 
....................       Ack_F = 0; 
1D60:  BCF    17.7
1D62:  MOVLB  1
....................    } 
....................  
.................... } 
1D64:  MOVLB  0
1D66:  RETLW  00
....................  
.................... ///////////////////// Check Reset /////////////////////////////////// 
.................... void check_reset(void) 
.................... { 
....................     if((input(Preset) == 0 && Reset_F == 0)|| AutoResetFlag ==1) delay_ms(50); 
1D68:  BSF    F94.1
1D6A:  BTFSC  F82.1
1D6C:  BRA    1D72
1D6E:  BTFSS  2D.0
1D70:  BRA    1D76
1D72:  BTFSS  17.3
1D74:  BRA    1D82
1D76:  MOVLW  32
1D78:  MOVLB  1
1D7A:  MOVWF  xB3
1D7C:  MOVLB  0
1D7E:  CALL   05C4
....................     if((input(Preset) == 0 && Reset_F == 0)|| AutoResetFlag ==1) 
1D82:  BSF    F94.1
1D84:  BTFSC  F82.1
1D86:  BRA    1D8C
1D88:  BTFSS  2D.0
1D8A:  BRA    1D90
1D8C:  BTFSS  17.3
1D8E:  BRA    1E76
....................     { 
....................        AutoResetFlag = 0; 
1D90:  BCF    17.3
....................         
....................        if((Inputt.B1 ^ InputType.B1) == 0 && In.B1 == 0) Output.B1 = 1; 
1D92:  MOVLW  00
1D94:  MOVLB  1
1D96:  BTFSC  x0A.0
1D98:  MOVLW  01
1D9A:  MOVWF  xAB
1D9C:  MOVLW  00
1D9E:  BTFSC  x0E.0
1DA0:  MOVLW  01
1DA2:  XORWF  xAB,W
1DA4:  BNZ   1DAA
1DA6:  BTFSS  x1A.0
1DA8:  BSF    x0C.0
....................        if((Inputt.B2 ^ InputType.B2) == 0 && In.B2 == 0) Output.B2 = 1; 
1DAA:  MOVLW  00
1DAC:  BTFSC  x0A.1
1DAE:  MOVLW  01
1DB0:  MOVWF  xAB
1DB2:  MOVLW  00
1DB4:  BTFSC  x0E.1
1DB6:  MOVLW  01
1DB8:  XORWF  xAB,W
1DBA:  BNZ   1DC0
1DBC:  BTFSS  x1A.1
1DBE:  BSF    x0C.1
....................        if((Inputt.B3 ^ InputType.B3) == 0 && In.B3 == 0) Output.B3 = 1; 
1DC0:  MOVLW  00
1DC2:  BTFSC  x0A.2
1DC4:  MOVLW  01
1DC6:  MOVWF  xAB
1DC8:  MOVLW  00
1DCA:  BTFSC  x0E.2
1DCC:  MOVLW  01
1DCE:  XORWF  xAB,W
1DD0:  BNZ   1DD6
1DD2:  BTFSS  x1A.2
1DD4:  BSF    x0C.2
....................        if((Inputt.B4 ^ InputType.B4) == 0 && In.B4 == 0) Output.B4 = 1; 
1DD6:  MOVLW  00
1DD8:  BTFSC  x0A.3
1DDA:  MOVLW  01
1DDC:  MOVWF  xAB
1DDE:  MOVLW  00
1DE0:  BTFSC  x0E.3
1DE2:  MOVLW  01
1DE4:  XORWF  xAB,W
1DE6:  BNZ   1DEC
1DE8:  BTFSS  x1A.3
1DEA:  BSF    x0C.3
....................        if((Inputt.B5 ^ InputType.B5) == 0 && In.B5 == 0) Output.B5 = 1; 
1DEC:  MOVLW  00
1DEE:  BTFSC  x0A.4
1DF0:  MOVLW  01
1DF2:  MOVWF  xAB
1DF4:  MOVLW  00
1DF6:  BTFSC  x0E.4
1DF8:  MOVLW  01
1DFA:  XORWF  xAB,W
1DFC:  BNZ   1E02
1DFE:  BTFSS  x1A.4
1E00:  BSF    x0C.4
....................        if((Inputt.B6 ^ InputType.B6) == 0 && In.B6 == 0) Output.B6 = 1; 
1E02:  MOVLW  00
1E04:  BTFSC  x0A.5
1E06:  MOVLW  01
1E08:  MOVWF  xAB
1E0A:  MOVLW  00
1E0C:  BTFSC  x0E.5
1E0E:  MOVLW  01
1E10:  XORWF  xAB,W
1E12:  BNZ   1E18
1E14:  BTFSS  x1A.5
1E16:  BSF    x0C.5
....................        if((Inputt.B7 ^ InputType.B7) == 0 && In.B7 == 0) Output.B7 = 1; 
1E18:  MOVLW  00
1E1A:  BTFSC  x0A.6
1E1C:  MOVLW  01
1E1E:  MOVWF  xAB
1E20:  MOVLW  00
1E22:  BTFSC  x0E.6
1E24:  MOVLW  01
1E26:  XORWF  xAB,W
1E28:  BNZ   1E2E
1E2A:  BTFSS  x1A.6
1E2C:  BSF    x0C.6
....................        if((Inputt.B8 ^ InputType.B8) == 0 && In.B8 == 0) Output.B8 = 1; 
1E2E:  MOVLW  00
1E30:  BTFSC  x0A.7
1E32:  MOVLW  01
1E34:  MOVWF  xAB
1E36:  MOVLW  00
1E38:  BTFSC  x0E.7
1E3A:  MOVLW  01
1E3C:  XORWF  xAB,W
1E3E:  BNZ   1E44
1E40:  BTFSS  x1A.7
1E42:  BSF    x0C.7
....................        if((Inputt.B9 ^ InputType.B9) == 0 && In.B9 == 0) Output.B9 = 1; 
1E44:  MOVLW  00
1E46:  BTFSC  x0B.0
1E48:  MOVLW  01
1E4A:  MOVWF  xAB
1E4C:  MOVLW  00
1E4E:  BTFSC  x0F.0
1E50:  MOVLW  01
1E52:  XORWF  xAB,W
1E54:  BNZ   1E5A
1E56:  BTFSS  x1B.0
1E58:  BSF    x0D.0
....................        if((Inputt.B10 ^ InputType.B10) == 0 && In.B10 == 0) Output.B10 = 1; 
1E5A:  MOVLW  00
1E5C:  BTFSC  x0B.1
1E5E:  MOVLW  01
1E60:  MOVWF  xAB
1E62:  MOVLW  00
1E64:  BTFSC  x0F.1
1E66:  MOVLW  01
1E68:  XORWF  xAB,W
1E6A:  BNZ   1E70
1E6C:  BTFSS  x1B.1
1E6E:  BSF    x0D.1
....................        /* 
....................        if((Inputt.B11 ^ InputType.B11) == 0 && In.B11 == 0) Output.B11 = 1; 
....................        if((Inputt.B12 ^ InputType.B12) == 0 && In.B12 == 0) Output.B12 = 1; 
....................        if((Inputt.B13 ^ InputType.B13) == 0 && In.B13 == 0) Output.B13 = 1; 
....................        if((Inputt.B14 ^ InputType.B14) == 0 && In.B14 == 0) Output.B14 = 1; 
....................        if((Inputt.B15 ^ InputType.B15) == 0 && In.B15 == 0) Output.B15 = 1; 
....................        if((Inputt.B16 ^ InputType.B16) == 0 && In.B16 == 0) Output.B16 = 1; 
....................        if((Inputt.B17 ^ InputType.B17) == 0 && In.B17 == 0) Output.B17 = 1; 
....................        if((Inputt.B18 ^ InputType.B18) == 0 && In.B18 == 0) Output.B18 = 1; 
....................        if((Inputt.B19 ^ InputType.B19) == 0 && In.B19 == 0) Output.B19 = 1; 
....................        if((Inputt.B20 ^ InputType.B20) == 0 && In.B20 == 0) Output.B20 = 1; 
....................        */ 
....................  
....................        Reset_F = 1; 
1E70:  BSF    2D.0
....................     } 
....................     else if(input(Preset) == 1 && Reset_F == 1) 
1E72:  BRA    1E84
1E74:  MOVLB  0
1E76:  BSF    F94.1
1E78:  BTFSS  F82.1
1E7A:  BRA    1E82
1E7C:  BTFSS  2D.0
1E7E:  BRA    1E82
....................     { 
....................        Reset_F = 0; 
1E80:  BCF    2D.0
1E82:  MOVLB  1
....................     } 
.................... } 
1E84:  MOVLB  0
1E86:  RETLW  00
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... ///////////////////////Check Auto Reset function /////////////////////////////////// 
.................... //////////////////////////////////////////////////////////////////////////////////// 
.................... int1 CheckAutoReset(unsigned char DatType) 
.................... { 
....................    int1 check;     /// "1" = true  //Other Alarm active or not "ACK" 
....................  
....................    if(DatType == 0x01) // Buzzer 
*
3516:  MOVLB  1
3518:  DECFSZ xB3,W
351A:  BRA    3758
....................    { 
....................       check = (In.B1 | In2.B1) & ~Ack.B1 & (OutputType.B1 | OutputBoth.B1); 
351C:  MOVLW  00
351E:  BTFSC  x1A.0
3520:  MOVLW  01
3522:  MOVWF  xB5
3524:  MOVLW  00
3526:  BTFSC  x1C.0
3528:  MOVLW  01
352A:  IORWF  xB5,F
352C:  MOVLW  00
352E:  BTFSS  x18.0
3530:  MOVLW  01
3532:  ANDWF  xB5,F
3534:  MOVLW  00
3536:  BTFSC  x12.0
3538:  MOVLW  01
353A:  MOVWF  xB6
353C:  MOVLW  00
353E:  BTFSC  x14.0
3540:  MOVLW  01
3542:  IORWF  xB6,W
3544:  ANDWF  xB5,W
3546:  BCF    xB4.0
3548:  BTFSC  FE8.0
354A:  BSF    xB4.0
....................       check = check | ((In.B2 | In2.B2) & ~Ack.B2 & (OutputType.B2 | OutputBoth.B2)); 
354C:  MOVLW  00
354E:  BTFSC  xB4.0
3550:  MOVLW  01
3552:  MOVWF  xB5
3554:  MOVLW  00
3556:  BTFSC  x1A.1
3558:  MOVLW  01
355A:  MOVWF  xB6
355C:  MOVLW  00
355E:  BTFSC  x1C.1
3560:  MOVLW  01
3562:  IORWF  xB6,F
3564:  MOVLW  00
3566:  BTFSS  x18.1
3568:  MOVLW  01
356A:  ANDWF  xB6,F
356C:  MOVLW  00
356E:  BTFSC  x12.1
3570:  MOVLW  01
3572:  MOVWF  xB7
3574:  MOVLW  00
3576:  BTFSC  x14.1
3578:  MOVLW  01
357A:  IORWF  xB7,W
357C:  ANDWF  xB6,W
357E:  IORWF  xB5,W
3580:  BCF    xB4.0
3582:  BTFSC  FE8.0
3584:  BSF    xB4.0
....................       check = check | ((In.B3 | In2.B3) & ~Ack.B3 & (OutputType.B3 | OutputBoth.B3)); 
3586:  MOVLW  00
3588:  BTFSC  xB4.0
358A:  MOVLW  01
358C:  MOVWF  xB5
358E:  MOVLW  00
3590:  BTFSC  x1A.2
3592:  MOVLW  01
3594:  MOVWF  xB6
3596:  MOVLW  00
3598:  BTFSC  x1C.2
359A:  MOVLW  01
359C:  IORWF  xB6,F
359E:  MOVLW  00
35A0:  BTFSS  x18.2
35A2:  MOVLW  01
35A4:  ANDWF  xB6,F
35A6:  MOVLW  00
35A8:  BTFSC  x12.2
35AA:  MOVLW  01
35AC:  MOVWF  xB7
35AE:  MOVLW  00
35B0:  BTFSC  x14.2
35B2:  MOVLW  01
35B4:  IORWF  xB7,W
35B6:  ANDWF  xB6,W
35B8:  IORWF  xB5,W
35BA:  BCF    xB4.0
35BC:  BTFSC  FE8.0
35BE:  BSF    xB4.0
....................       check = check | ((In.B4 | In2.B4) & ~Ack.B4 & (OutputType.B4 | OutputBoth.B4)); 
35C0:  MOVLW  00
35C2:  BTFSC  xB4.0
35C4:  MOVLW  01
35C6:  MOVWF  xB5
35C8:  MOVLW  00
35CA:  BTFSC  x1A.3
35CC:  MOVLW  01
35CE:  MOVWF  xB6
35D0:  MOVLW  00
35D2:  BTFSC  x1C.3
35D4:  MOVLW  01
35D6:  IORWF  xB6,F
35D8:  MOVLW  00
35DA:  BTFSS  x18.3
35DC:  MOVLW  01
35DE:  ANDWF  xB6,F
35E0:  MOVLW  00
35E2:  BTFSC  x12.3
35E4:  MOVLW  01
35E6:  MOVWF  xB7
35E8:  MOVLW  00
35EA:  BTFSC  x14.3
35EC:  MOVLW  01
35EE:  IORWF  xB7,W
35F0:  ANDWF  xB6,W
35F2:  IORWF  xB5,W
35F4:  BCF    xB4.0
35F6:  BTFSC  FE8.0
35F8:  BSF    xB4.0
....................       check = check | ((In.B5 | In2.B5) & ~Ack.B5 & (OutputType.B5 | OutputBoth.B5)); 
35FA:  MOVLW  00
35FC:  BTFSC  xB4.0
35FE:  MOVLW  01
3600:  MOVWF  xB5
3602:  MOVLW  00
3604:  BTFSC  x1A.4
3606:  MOVLW  01
3608:  MOVWF  xB6
360A:  MOVLW  00
360C:  BTFSC  x1C.4
360E:  MOVLW  01
3610:  IORWF  xB6,F
3612:  MOVLW  00
3614:  BTFSS  x18.4
3616:  MOVLW  01
3618:  ANDWF  xB6,F
361A:  MOVLW  00
361C:  BTFSC  x12.4
361E:  MOVLW  01
3620:  MOVWF  xB7
3622:  MOVLW  00
3624:  BTFSC  x14.4
3626:  MOVLW  01
3628:  IORWF  xB7,W
362A:  ANDWF  xB6,W
362C:  IORWF  xB5,W
362E:  BCF    xB4.0
3630:  BTFSC  FE8.0
3632:  BSF    xB4.0
....................       check = check | ((In.B6 | In2.B6) & ~Ack.B6 & (OutputType.B6 | OutputBoth.B6)); 
3634:  MOVLW  00
3636:  BTFSC  xB4.0
3638:  MOVLW  01
363A:  MOVWF  xB5
363C:  MOVLW  00
363E:  BTFSC  x1A.5
3640:  MOVLW  01
3642:  MOVWF  xB6
3644:  MOVLW  00
3646:  BTFSC  x1C.5
3648:  MOVLW  01
364A:  IORWF  xB6,F
364C:  MOVLW  00
364E:  BTFSS  x18.5
3650:  MOVLW  01
3652:  ANDWF  xB6,F
3654:  MOVLW  00
3656:  BTFSC  x12.5
3658:  MOVLW  01
365A:  MOVWF  xB7
365C:  MOVLW  00
365E:  BTFSC  x14.5
3660:  MOVLW  01
3662:  IORWF  xB7,W
3664:  ANDWF  xB6,W
3666:  IORWF  xB5,W
3668:  BCF    xB4.0
366A:  BTFSC  FE8.0
366C:  BSF    xB4.0
....................       check = check | ((In.B7 | In2.B7) & ~Ack.B7 & (OutputType.B7 | OutputBoth.B7)); 
366E:  MOVLW  00
3670:  BTFSC  xB4.0
3672:  MOVLW  01
3674:  MOVWF  xB5
3676:  MOVLW  00
3678:  BTFSC  x1A.6
367A:  MOVLW  01
367C:  MOVWF  xB6
367E:  MOVLW  00
3680:  BTFSC  x1C.6
3682:  MOVLW  01
3684:  IORWF  xB6,F
3686:  MOVLW  00
3688:  BTFSS  x18.6
368A:  MOVLW  01
368C:  ANDWF  xB6,F
368E:  MOVLW  00
3690:  BTFSC  x12.6
3692:  MOVLW  01
3694:  MOVWF  xB7
3696:  MOVLW  00
3698:  BTFSC  x14.6
369A:  MOVLW  01
369C:  IORWF  xB7,W
369E:  ANDWF  xB6,W
36A0:  IORWF  xB5,W
36A2:  BCF    xB4.0
36A4:  BTFSC  FE8.0
36A6:  BSF    xB4.0
....................       check = check | ((In.B8 | In2.B8) & ~Ack.B8 & (OutputType.B8 | OutputBoth.B8)); 
36A8:  MOVLW  00
36AA:  BTFSC  xB4.0
36AC:  MOVLW  01
36AE:  MOVWF  xB5
36B0:  MOVLW  00
36B2:  BTFSC  x1A.7
36B4:  MOVLW  01
36B6:  MOVWF  xB6
36B8:  MOVLW  00
36BA:  BTFSC  x1C.7
36BC:  MOVLW  01
36BE:  IORWF  xB6,F
36C0:  MOVLW  00
36C2:  BTFSS  x18.7
36C4:  MOVLW  01
36C6:  ANDWF  xB6,F
36C8:  MOVLW  00
36CA:  BTFSC  x12.7
36CC:  MOVLW  01
36CE:  MOVWF  xB7
36D0:  MOVLW  00
36D2:  BTFSC  x14.7
36D4:  MOVLW  01
36D6:  IORWF  xB7,W
36D8:  ANDWF  xB6,W
36DA:  IORWF  xB5,W
36DC:  BCF    xB4.0
36DE:  BTFSC  FE8.0
36E0:  BSF    xB4.0
....................       check = check | ((In.B9 | In2.B9) & ~Ack.B9 & (OutputType.B9 | OutputBoth.B9)); 
36E2:  MOVLW  00
36E4:  BTFSC  xB4.0
36E6:  MOVLW  01
36E8:  MOVWF  xB5
36EA:  MOVLW  00
36EC:  BTFSC  x1B.0
36EE:  MOVLW  01
36F0:  MOVWF  xB6
36F2:  MOVLW  00
36F4:  BTFSC  x1D.0
36F6:  MOVLW  01
36F8:  IORWF  xB6,F
36FA:  MOVLW  00
36FC:  BTFSS  x19.0
36FE:  MOVLW  01
3700:  ANDWF  xB6,F
3702:  MOVLW  00
3704:  BTFSC  x13.0
3706:  MOVLW  01
3708:  MOVWF  xB7
370A:  MOVLW  00
370C:  BTFSC  x15.0
370E:  MOVLW  01
3710:  IORWF  xB7,W
3712:  ANDWF  xB6,W
3714:  IORWF  xB5,W
3716:  BCF    xB4.0
3718:  BTFSC  FE8.0
371A:  BSF    xB4.0
....................       check = check | ((In.B10 | In2.B10) & ~Ack.B10 & (OutputType.B10 | OutputBoth.B10)); 
371C:  MOVLW  00
371E:  BTFSC  xB4.0
3720:  MOVLW  01
3722:  MOVWF  xB5
3724:  MOVLW  00
3726:  BTFSC  x1B.1
3728:  MOVLW  01
372A:  MOVWF  xB6
372C:  MOVLW  00
372E:  BTFSC  x1D.1
3730:  MOVLW  01
3732:  IORWF  xB6,F
3734:  MOVLW  00
3736:  BTFSS  x19.1
3738:  MOVLW  01
373A:  ANDWF  xB6,F
373C:  MOVLW  00
373E:  BTFSC  x13.1
3740:  MOVLW  01
3742:  MOVWF  xB7
3744:  MOVLW  00
3746:  BTFSC  x15.1
3748:  MOVLW  01
374A:  IORWF  xB7,W
374C:  ANDWF  xB6,W
374E:  IORWF  xB5,W
3750:  BCF    xB4.0
3752:  BTFSC  FE8.0
3754:  BSF    xB4.0
....................       /* 
....................       check = check | ((In.B11 | In2.B11) & ~Ack.B11 & (OutputType.B11 | OutputBoth.B11)); 
....................       check = check | ((In.B12 | In2.B12) & ~Ack.B12 & (OutputType.B12 | OutputBoth.B12)); 
....................       check = check | ((In.B13 | In2.B13) & ~Ack.B13 & (OutputType.B13 | OutputBoth.B13)); 
....................       check = check | ((In.B14 | In2.B14) & ~Ack.B14 & (OutputType.B14 | OutputBoth.B14)); 
....................       check = check | ((In.B15 | In2.B15) & ~Ack.B15 & (OutputType.B15 | OutputBoth.B15)); 
....................       check = check | ((In.B16 | In2.B16) & ~Ack.B16 & (OutputType.B16 | OutputBoth.B16)); 
....................       check = check | ((In.B17 | In2.B17) & ~Ack.B17 & (OutputType.B17 | OutputBoth.B17)); 
....................       check = check | ((In.B18 | In2.B18) & ~Ack.B18 & (OutputType.B18 | OutputBoth.B18)); 
....................       check = check | ((In.B19 | In2.B19) & ~Ack.B19 & (OutputType.B19 | OutputBoth.B19)); 
....................       check = check | ((In.B20 | In2.B20) & ~Ack.B20 & (OutputType.B20 | OutputBoth.B20)); 
....................      */ 
....................    } 
....................    else if(DatType == 0x02)             //Bell 
3756:  BRA    399A
3758:  MOVF   xB3,W
375A:  SUBLW  02
375C:  BTFSS  FD8.2
375E:  BRA    399A
....................    { 
....................       check = (In.B1 | In2.B1) & ~Ack.B1 & (~OutputType.B1 | OutputBoth.B1); 
3760:  MOVLW  00
3762:  BTFSC  x1A.0
3764:  MOVLW  01
3766:  MOVWF  xB5
3768:  MOVLW  00
376A:  BTFSC  x1C.0
376C:  MOVLW  01
376E:  IORWF  xB5,F
3770:  MOVLW  00
3772:  BTFSS  x18.0
3774:  MOVLW  01
3776:  ANDWF  xB5,F
3778:  MOVLW  00
377A:  BTFSS  x12.0
377C:  MOVLW  01
377E:  MOVWF  xB6
3780:  MOVLW  00
3782:  BTFSC  x14.0
3784:  MOVLW  01
3786:  IORWF  xB6,W
3788:  ANDWF  xB5,W
378A:  BCF    xB4.0
378C:  BTFSC  FE8.0
378E:  BSF    xB4.0
....................       check = check | ((In.B2 | In2.B2) & ~Ack.B2 & (~OutputType.B2 | OutputBoth.B2)); 
3790:  MOVLW  00
3792:  BTFSC  xB4.0
3794:  MOVLW  01
3796:  MOVWF  xB5
3798:  MOVLW  00
379A:  BTFSC  x1A.1
379C:  MOVLW  01
379E:  MOVWF  xB6
37A0:  MOVLW  00
37A2:  BTFSC  x1C.1
37A4:  MOVLW  01
37A6:  IORWF  xB6,F
37A8:  MOVLW  00
37AA:  BTFSS  x18.1
37AC:  MOVLW  01
37AE:  ANDWF  xB6,F
37B0:  MOVLW  00
37B2:  BTFSS  x12.1
37B4:  MOVLW  01
37B6:  MOVWF  xB7
37B8:  MOVLW  00
37BA:  BTFSC  x14.1
37BC:  MOVLW  01
37BE:  IORWF  xB7,W
37C0:  ANDWF  xB6,W
37C2:  IORWF  xB5,W
37C4:  BCF    xB4.0
37C6:  BTFSC  FE8.0
37C8:  BSF    xB4.0
....................       check = check | ((In.B3 | In2.B3) & ~Ack.B3 & (~OutputType.B3 | OutputBoth.B3)); 
37CA:  MOVLW  00
37CC:  BTFSC  xB4.0
37CE:  MOVLW  01
37D0:  MOVWF  xB5
37D2:  MOVLW  00
37D4:  BTFSC  x1A.2
37D6:  MOVLW  01
37D8:  MOVWF  xB6
37DA:  MOVLW  00
37DC:  BTFSC  x1C.2
37DE:  MOVLW  01
37E0:  IORWF  xB6,F
37E2:  MOVLW  00
37E4:  BTFSS  x18.2
37E6:  MOVLW  01
37E8:  ANDWF  xB6,F
37EA:  MOVLW  00
37EC:  BTFSS  x12.2
37EE:  MOVLW  01
37F0:  MOVWF  xB7
37F2:  MOVLW  00
37F4:  BTFSC  x14.2
37F6:  MOVLW  01
37F8:  IORWF  xB7,W
37FA:  ANDWF  xB6,W
37FC:  IORWF  xB5,W
37FE:  BCF    xB4.0
3800:  BTFSC  FE8.0
3802:  BSF    xB4.0
....................       check = check | ((In.B4 | In2.B4) & ~Ack.B4 & (~OutputType.B4 | OutputBoth.B4)); 
3804:  MOVLW  00
3806:  BTFSC  xB4.0
3808:  MOVLW  01
380A:  MOVWF  xB5
380C:  MOVLW  00
380E:  BTFSC  x1A.3
3810:  MOVLW  01
3812:  MOVWF  xB6
3814:  MOVLW  00
3816:  BTFSC  x1C.3
3818:  MOVLW  01
381A:  IORWF  xB6,F
381C:  MOVLW  00
381E:  BTFSS  x18.3
3820:  MOVLW  01
3822:  ANDWF  xB6,F
3824:  MOVLW  00
3826:  BTFSS  x12.3
3828:  MOVLW  01
382A:  MOVWF  xB7
382C:  MOVLW  00
382E:  BTFSC  x14.3
3830:  MOVLW  01
3832:  IORWF  xB7,W
3834:  ANDWF  xB6,W
3836:  IORWF  xB5,W
3838:  BCF    xB4.0
383A:  BTFSC  FE8.0
383C:  BSF    xB4.0
....................       check = check | ((In.B5 | In2.B5) & ~Ack.B5 & (~OutputType.B5 | OutputBoth.B5)); 
383E:  MOVLW  00
3840:  BTFSC  xB4.0
3842:  MOVLW  01
3844:  MOVWF  xB5
3846:  MOVLW  00
3848:  BTFSC  x1A.4
384A:  MOVLW  01
384C:  MOVWF  xB6
384E:  MOVLW  00
3850:  BTFSC  x1C.4
3852:  MOVLW  01
3854:  IORWF  xB6,F
3856:  MOVLW  00
3858:  BTFSS  x18.4
385A:  MOVLW  01
385C:  ANDWF  xB6,F
385E:  MOVLW  00
3860:  BTFSS  x12.4
3862:  MOVLW  01
3864:  MOVWF  xB7
3866:  MOVLW  00
3868:  BTFSC  x14.4
386A:  MOVLW  01
386C:  IORWF  xB7,W
386E:  ANDWF  xB6,W
3870:  IORWF  xB5,W
3872:  BCF    xB4.0
3874:  BTFSC  FE8.0
3876:  BSF    xB4.0
....................       check = check | ((In.B6 | In2.B6) & ~Ack.B6 & (~OutputType.B6 | OutputBoth.B6)); 
3878:  MOVLW  00
387A:  BTFSC  xB4.0
387C:  MOVLW  01
387E:  MOVWF  xB5
3880:  MOVLW  00
3882:  BTFSC  x1A.5
3884:  MOVLW  01
3886:  MOVWF  xB6
3888:  MOVLW  00
388A:  BTFSC  x1C.5
388C:  MOVLW  01
388E:  IORWF  xB6,F
3890:  MOVLW  00
3892:  BTFSS  x18.5
3894:  MOVLW  01
3896:  ANDWF  xB6,F
3898:  MOVLW  00
389A:  BTFSS  x12.5
389C:  MOVLW  01
389E:  MOVWF  xB7
38A0:  MOVLW  00
38A2:  BTFSC  x14.5
38A4:  MOVLW  01
38A6:  IORWF  xB7,W
38A8:  ANDWF  xB6,W
38AA:  IORWF  xB5,W
38AC:  BCF    xB4.0
38AE:  BTFSC  FE8.0
38B0:  BSF    xB4.0
....................       check = check | ((In.B7 | In2.B7) & ~Ack.B7 & (~OutputType.B7 | OutputBoth.B7)); 
38B2:  MOVLW  00
38B4:  BTFSC  xB4.0
38B6:  MOVLW  01
38B8:  MOVWF  xB5
38BA:  MOVLW  00
38BC:  BTFSC  x1A.6
38BE:  MOVLW  01
38C0:  MOVWF  xB6
38C2:  MOVLW  00
38C4:  BTFSC  x1C.6
38C6:  MOVLW  01
38C8:  IORWF  xB6,F
38CA:  MOVLW  00
38CC:  BTFSS  x18.6
38CE:  MOVLW  01
38D0:  ANDWF  xB6,F
38D2:  MOVLW  00
38D4:  BTFSS  x12.6
38D6:  MOVLW  01
38D8:  MOVWF  xB7
38DA:  MOVLW  00
38DC:  BTFSC  x14.6
38DE:  MOVLW  01
38E0:  IORWF  xB7,W
38E2:  ANDWF  xB6,W
38E4:  IORWF  xB5,W
38E6:  BCF    xB4.0
38E8:  BTFSC  FE8.0
38EA:  BSF    xB4.0
....................       check = check | ((In.B8 | In2.B8) & ~Ack.B8 & (~OutputType.B8 | OutputBoth.B8)); 
38EC:  MOVLW  00
38EE:  BTFSC  xB4.0
38F0:  MOVLW  01
38F2:  MOVWF  xB5
38F4:  MOVLW  00
38F6:  BTFSC  x1A.7
38F8:  MOVLW  01
38FA:  MOVWF  xB6
38FC:  MOVLW  00
38FE:  BTFSC  x1C.7
3900:  MOVLW  01
3902:  IORWF  xB6,F
3904:  MOVLW  00
3906:  BTFSS  x18.7
3908:  MOVLW  01
390A:  ANDWF  xB6,F
390C:  MOVLW  00
390E:  BTFSS  x12.7
3910:  MOVLW  01
3912:  MOVWF  xB7
3914:  MOVLW  00
3916:  BTFSC  x14.7
3918:  MOVLW  01
391A:  IORWF  xB7,W
391C:  ANDWF  xB6,W
391E:  IORWF  xB5,W
3920:  BCF    xB4.0
3922:  BTFSC  FE8.0
3924:  BSF    xB4.0
....................       check = check | ((In.B9 | In2.B9) & ~Ack.B9 & (~OutputType.B9 | OutputBoth.B9)); 
3926:  MOVLW  00
3928:  BTFSC  xB4.0
392A:  MOVLW  01
392C:  MOVWF  xB5
392E:  MOVLW  00
3930:  BTFSC  x1B.0
3932:  MOVLW  01
3934:  MOVWF  xB6
3936:  MOVLW  00
3938:  BTFSC  x1D.0
393A:  MOVLW  01
393C:  IORWF  xB6,F
393E:  MOVLW  00
3940:  BTFSS  x19.0
3942:  MOVLW  01
3944:  ANDWF  xB6,F
3946:  MOVLW  00
3948:  BTFSS  x13.0
394A:  MOVLW  01
394C:  MOVWF  xB7
394E:  MOVLW  00
3950:  BTFSC  x15.0
3952:  MOVLW  01
3954:  IORWF  xB7,W
3956:  ANDWF  xB6,W
3958:  IORWF  xB5,W
395A:  BCF    xB4.0
395C:  BTFSC  FE8.0
395E:  BSF    xB4.0
....................       check = check | ((In.B10 | In2.B10) & ~Ack.B10 & (~OutputType.B10 | OutputBoth.B10)); 
3960:  MOVLW  00
3962:  BTFSC  xB4.0
3964:  MOVLW  01
3966:  MOVWF  xB5
3968:  MOVLW  00
396A:  BTFSC  x1B.1
396C:  MOVLW  01
396E:  MOVWF  xB6
3970:  MOVLW  00
3972:  BTFSC  x1D.1
3974:  MOVLW  01
3976:  IORWF  xB6,F
3978:  MOVLW  00
397A:  BTFSS  x19.1
397C:  MOVLW  01
397E:  ANDWF  xB6,F
3980:  MOVLW  00
3982:  BTFSS  x13.1
3984:  MOVLW  01
3986:  MOVWF  xB7
3988:  MOVLW  00
398A:  BTFSC  x15.1
398C:  MOVLW  01
398E:  IORWF  xB7,W
3990:  ANDWF  xB6,W
3992:  IORWF  xB5,W
3994:  BCF    xB4.0
3996:  BTFSC  FE8.0
3998:  BSF    xB4.0
....................       /* 
....................       check = check | ((In.B11 | In2.B11) & ~Ack.B11 & (~OutputType.B11 | OutputBoth.B11)); 
....................       check = check | ((In.B12 | In2.B12) & ~Ack.B12 & (~OutputType.B12 | OutputBoth.B12)); 
....................       check = check | ((In.B13 | In2.B13) & ~Ack.B13 & (~OutputType.B13 | OutputBoth.B13)); 
....................       check = check | ((In.B14 | In2.B14) & ~Ack.B14 & (~OutputType.B14 | OutputBoth.B14)); 
....................       check = check | ((In.B15 | In2.B15) & ~Ack.B15 & (~OutputType.B15 | OutputBoth.B15)); 
....................       check = check | ((In.B16 | In2.B16) & ~Ack.B16 & (~OutputType.B16 | OutputBoth.B16)); 
....................       check = check | ((In.B17 | In2.B17) & ~Ack.B17 & (~OutputType.B17 | OutputBoth.B17)); 
....................       check = check | ((In.B18 | In2.B18) & ~Ack.B18 & (~OutputType.B18 | OutputBoth.B18)); 
....................       check = check | ((In.B19 | In2.B19) & ~Ack.B19 & (~OutputType.B19 | OutputBoth.B19)); 
....................       check = check | ((In.B20 | In2.B20) & ~Ack.B20 & (~OutputType.B20 | OutputBoth.B20)); 
....................       */ 
....................    } 
....................    return(check); 
399A:  MOVLW  00
399C:  BTFSC  xB4.0
399E:  MOVLW  01
39A0:  MOVWF  01
.................... } 
39A2:  MOVLB  0
39A4:  RETLW  00
....................  
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... void main() 
.................... { 
*
49AE:  CLRF   FF8
49B0:  BCF    FD0.7
49B2:  BSF    07.7
49B4:  CLRF   FEA
49B6:  CLRF   FE9
49B8:  MOVLW  81
49BA:  MOVWF  FAF
49BC:  MOVLW  A6
49BE:  MOVWF  FAC
49C0:  MOVLW  90
49C2:  MOVWF  FAB
49C4:  CLRF   16
49C6:  BCF    17.0
49C8:  MOVLW  19
49CA:  MOVWF  18
49CC:  BCF    17.1
49CE:  MOVLW  64
49D0:  MOVWF  19
49D2:  CLRF   1A
49D4:  BCF    17.2
49D6:  BCF    17.3
49D8:  BCF    17.4
49DA:  CLRF   2B
49DC:  BCF    17.5
49DE:  CLRF   2C
49E0:  BCF    17.6
49E2:  BCF    17.7
49E4:  BCF    2D.0
49E6:  BCF    2D.1
49E8:  BCF    2D.2
49EA:  CLRF   2E
49EC:  BCF    2D.3
49EE:  MOVLW  11
49F0:  MOVWF  60
49F2:  MOVLW  12
49F4:  MOVWF  61
49F6:  MOVLW  13
49F8:  MOVWF  62
49FA:  MOVLW  14
49FC:  MOVWF  63
49FE:  MOVLW  16
4A00:  MOVWF  64
4A02:  MOVLW  17
4A04:  MOVWF  65
4A06:  MOVLW  19
4A08:  MOVWF  66
4A0A:  MOVLW  20
4A0C:  MOVWF  67
4A0E:  BCF    2D.4
4A10:  CLRF   6A
4A12:  MOVLW  01
4A14:  MOVWF  xE6
4A16:  MOVLW  F4
4A18:  MOVWF  xE5
4A1A:  CLRF   xE8
4A1C:  CLRF   xE7
4A1E:  CLRF   xEA
4A20:  CLRF   xE9
4A22:  CLRF   xEB
4A24:  MOVLB  1
4A26:  CLRF   x08
4A28:  CLRF   x09
4A2A:  CLRF   xA8
4A2C:  BSF    FC1.0
4A2E:  BSF    FC1.1
4A30:  BSF    FC1.2
4A32:  BCF    FC1.3
....................     
....................     
....................    delay_ms(50); 
4A34:  MOVLW  32
4A36:  MOVWF  xB3
4A38:  MOVLB  0
4A3A:  CALL   05C4
....................    output_bit(Pled,0);   //power on watchdog signal 
4A3E:  BCF    F8A.5
4A40:  BCF    F93.5
....................  
....................    //jj 
....................    //setup_adc_ports(NO_ANALOGS|VSS_VDD); 
....................    //setup_adc(ADC_OFF|ADC_TAD_MUL_0); 
....................     
....................    //setup_spi(FALSE); 
....................     
....................    setup_timer_0(RTCC_INTERNAL); 
4A42:  MOVLW  80
4A44:  MOVWF  FD5
....................    //setup_timer_1(T1_DISABLED); 
....................    setup_timer_2(T2_DIV_BY_16,196,16);         //10ms 
4A46:  MOVLW  78
4A48:  IORLW  06
4A4A:  MOVWF  FCA
4A4C:  MOVLW  C4
4A4E:  MOVWF  FCB
....................    setup_timer_1(T1_INTERNAL|T1_DIV_BY_8);    //104ms 
4A50:  MOVLW  B5
4A52:  MOVWF  FCD
....................    //setup_timer_3(T3_DISABLED|T3_DIV_BY_1); 
....................    //setup_comparator(NC_NC_NC_NC); 
....................    //setup_vref(FALSE); 
....................   // enable_interrupts(INT_TIMER1); 
....................    enable_interrupts(INT_TIMER2); 
4A54:  BSF    F9D.1
....................    enable_interrupts(INT_RDA); 
4A56:  BSF    F9D.5
....................     
....................    //setup_oscillator(False); 
....................     
....................  
....................    //  set_tris_c (0b01010111); 
....................    //setup_spi(SPI_MASTER | SPI_XMIT_L_TO_H |SPI_SS_DISABLED|SPI_H_TO_L  | SPI_CLK_DIV_4  ); 
....................    //setup_spi(SPI_MASTER | SPI_H_TO_L  | SPI_CLK_DIV_4 |SPI_SS_DISABLED); // Initial SPI 
....................    //setup_spi(SPI_MASTER|SPI_H_TO_L|SPI_SS_DISABLED|SPI_CLK_DIV_16); 
....................    //setup_spi2( FALSE ); 
....................    //setup_spi( FALSE ); 
....................     
....................   // setup_spi(SPI_MASTER |SPI_SS_DISABLED | SPI_L_TO_H | SPI_XMIT_L_TO_H| SPI_CLK_DIV_4 ); //masterOK 
....................     
....................    setup_spi(SPI_MASTER  | SPI_L_TO_H | SPI_XMIT_L_TO_H| SPI_CLK_DIV_4 ); //master1 
4A58:  BCF    FC6.5
4A5A:  BCF    F94.5
4A5C:  BSF    F94.4
4A5E:  BCF    F94.3
4A60:  MOVLW  20
4A62:  MOVWF  FC6
4A64:  MOVLW  40
4A66:  MOVWF  FC7
....................  
....................     //setup_spi(SPI_MASTER | SPI_L_TO_H | SPI_XMIT_L_TO_H | SPI_CLK_DIV_4 ); //master2 
....................     //setup_spi(SPI_MASTER |SPI_SS_DISABLED |SPI_SAMPLE_AT_END | SPI_H_TO_L | SPI_XMIT_L_TO_H| SPI_CLK_DIV_4 ); //master1.1 
....................    //spi_init(SPI1_MODE0, TRUE); 
....................    //spi_init(250000); 
....................    //setup_spi(SPI_MASTER | SPI_XMIT_L_TO_H | SPI_CLK_DIV_4 ); 
....................    //setup_spi(SPI_SS_DISABLED  | SPI_XMIT_L_TO_H | SPI_CLK_DIV_4 ); 
....................    //setup_spi(SPI_MASTER | SPI_H_TO_L | SPI_CLK_T2 | SPI_XMIT_L_TO_H); 
....................    //setup_spi(SPI_MASTER | SPI_H_TO_L| SPI_SAMPLE_AT_END | SPI_CLK_DIV_64);//master3 
....................    //setup_spi(SPI_MASTER |SPI_SS_DISABLED| SPI_L_TO_H | SPI_SAMPLE_AT_END | SPI_CLK_DIV_4 ); 
....................    //setup_spi(SPI_MASTER | SPI_L_TO_H | SPI_XMIT_L_TO_H | SPI_CLK_DIV_4); 
....................    //setup_spi(SPI_MASTER |SPI_SS_DISABLED | SPI_XMIT_L_TO_H| SPI_CLK_DIV_4 ); 
....................    //setup_spi(SPI_MASTER | SPI_L_TO_H | SPI_CLK_DIV_4); 
....................    //setup_spi(SPI_MASTER | SPI_H_TO_L | SPI_CLK_DIV_16); 
....................    //setup_spi(SPI_MASTER |SPI_SS_DISABLED| spi_L_to_H| SPI_XMIT_L_TO_H|SPI_CLK_DIV_4 ); 
....................    
....................    IO_INIT();   //initializes the MCP23S17 chip.//----------jj 
4A68:  GOTO   0626
....................    
....................    IO_SET_TRIS_A(IO_DEVICE_0, 0xFF); //addr.0 Set PortA As Input 
4A6C:  MOVLB  1
4A6E:  CLRF   xAB
4A70:  MOVLW  FF
4A72:  MOVWF  xAC
4A74:  MOVLB  0
4A76:  CALL   06BC
....................    IO_SET_TRIS_B(IO_DEVICE_0, 0xFF); //addr.0 Set PortB As Input 
4A7A:  MOVLB  1
4A7C:  CLRF   xAB
4A7E:  MOVLW  FF
4A80:  MOVWF  xAC
4A82:  MOVLB  0
4A84:  CALL   06CE
....................    IO_SET_TRIS_A(IO_DEVICE_1, 0xFF); //addr.1 Set PortA As Input  
4A88:  MOVLW  02
4A8A:  MOVLB  1
4A8C:  MOVWF  xAB
4A8E:  MOVLW  FF
4A90:  MOVWF  xAC
4A92:  MOVLB  0
4A94:  CALL   06BC
....................    IO_SET_TRIS_B(IO_DEVICE_1, 0xFF); //addr.1 Set PortB As Input 
4A98:  MOVLW  02
4A9A:  MOVLB  1
4A9C:  MOVWF  xAB
4A9E:  MOVLW  FF
4AA0:  MOVWF  xAC
4AA2:  MOVLB  0
4AA4:  CALL   06CE
....................    //  jj 
....................    IO_WRITE_REGISTER(IO_DEVICE_0, GPPUA, 0xFF); // Input Pullup 
4AA8:  MOVLB  1
4AAA:  CLRF   xB5
4AAC:  MOVLW  06
4AAE:  MOVWF  xB6
4AB0:  MOVLW  FF
4AB2:  MOVWF  xB7
4AB4:  MOVLB  0
4AB6:  CALL   05F4
....................    IO_WRITE_REGISTER(IO_DEVICE_0, GPPUB, 0xFF); // Input Pullup 
4ABA:  MOVLB  1
4ABC:  CLRF   xB5
4ABE:  MOVLW  16
4AC0:  MOVWF  xB6
4AC2:  MOVLW  FF
4AC4:  MOVWF  xB7
4AC6:  MOVLB  0
4AC8:  CALL   05F4
....................    IO_WRITE_REGISTER(IO_DEVICE_1, GPPUA, 0xFF); // Input Pullup 
4ACC:  MOVLW  02
4ACE:  MOVLB  1
4AD0:  MOVWF  xB5
4AD2:  MOVLW  06
4AD4:  MOVWF  xB6
4AD6:  MOVLW  FF
4AD8:  MOVWF  xB7
4ADA:  MOVLB  0
4ADC:  CALL   05F4
....................    IO_WRITE_REGISTER(IO_DEVICE_1, GPPUB, 0xFF); // Input Pullup 
4AE0:  MOVLW  02
4AE2:  MOVLB  1
4AE4:  MOVWF  xB5
4AE6:  MOVLW  16
4AE8:  MOVWF  xB6
4AEA:  MOVLW  FF
4AEC:  MOVWF  xB7
4AEE:  MOVLB  0
4AF0:  CALL   05F4
....................    //  jj 
....................    IO_SET_TRIS_A(IO_DEVICE_2, 0x00); //addr.2 Set PortA As Output  
4AF4:  MOVLW  04
4AF6:  MOVLB  1
4AF8:  MOVWF  xAB
4AFA:  CLRF   xAC
4AFC:  MOVLB  0
4AFE:  CALL   06BC
....................    IO_SET_TRIS_B(IO_DEVICE_2, 0x00); //addr.2 Set PortB As Output 
4B02:  MOVLW  04
4B04:  MOVLB  1
4B06:  MOVWF  xAB
4B08:  CLRF   xAC
4B0A:  MOVLB  0
4B0C:  CALL   06CE
....................    IO_SET_TRIS_A(IO_DEVICE_3, 0x00); //addr.3 Set PortA As Output  
4B10:  MOVLW  06
4B12:  MOVLB  1
4B14:  MOVWF  xAB
4B16:  CLRF   xAC
4B18:  MOVLB  0
4B1A:  CALL   06BC
....................    IO_SET_TRIS_B(IO_DEVICE_3, 0x00); //addr.3 Set PortB As Output 
4B1E:  MOVLW  06
4B20:  MOVLB  1
4B22:  MOVWF  xAB
4B24:  CLRF   xAC
4B26:  MOVLB  0
4B28:  CALL   06CE
....................    IO_SET_TRIS_A(IO_DEVICE_4, 0x00); //addr.4 Set PortA As Output  
4B2C:  MOVLW  08
4B2E:  MOVLB  1
4B30:  MOVWF  xAB
4B32:  CLRF   xAC
4B34:  MOVLB  0
4B36:  CALL   06BC
....................    IO_SET_TRIS_B(IO_DEVICE_4, 0x00); //addr.4 Set PortB As Output  
4B3A:  MOVLW  08
4B3C:  MOVLB  1
4B3E:  MOVWF  xAB
4B40:  CLRF   xAC
4B42:  MOVLB  0
4B44:  CALL   06CE
....................    IO_SET_TRIS_A(IO_DEVICE_5, 0x00); //addr.5 Set PortA As Output  
4B48:  MOVLW  0A
4B4A:  MOVLB  1
4B4C:  MOVWF  xAB
4B4E:  CLRF   xAC
4B50:  MOVLB  0
4B52:  CALL   06BC
....................    IO_SET_TRIS_B(IO_DEVICE_5, 0x00); //addr.5 Set PortB As Output 
4B56:  MOVLW  0A
4B58:  MOVLB  1
4B5A:  MOVWF  xAB
4B5C:  CLRF   xAC
4B5E:  MOVLB  0
4B60:  CALL   06CE
....................     
....................    FlashingFlag = 1; 
4B64:  BSF    17.1
....................    //output_bit(P485ctrl,0); 
....................    sequence = end_sq; 
4B66:  MOVFF  60,68
....................    Address = 1; 
4B6A:  MOVLW  01
4B6C:  MOVWF  69
....................  
....................    Output.B1 = 1; 
4B6E:  MOVLB  1
4B70:  BSF    x0C.0
....................    Output.B2 = 1; 
4B72:  BSF    x0C.1
....................    Output.B3 = 1; 
4B74:  BSF    x0C.2
....................    Output.B4 = 1; 
4B76:  BSF    x0C.3
....................    Output.B5 = 1; 
4B78:  BSF    x0C.4
....................    Output.B6 = 1; 
4B7A:  BSF    x0C.5
....................    Output.B7 = 1; 
4B7C:  BSF    x0C.6
....................    Output.B8 = 1; 
4B7E:  BSF    x0C.7
....................    Output.B9 = 1; 
4B80:  BSF    x0D.0
....................    Output.B10 = 1; 
4B82:  BSF    x0D.1
....................    /* 
....................    Output.B11 = 1; 
....................    Output.B12 = 1; 
....................    Output.B13 = 1; 
....................    Output.B14 = 1; 
....................    Output.B15 = 1; 
....................    Output.B16 = 1; 
....................    Output.B17 = 1; 
....................    Output.B18 = 1; 
....................    Output.B19 = 1; 
....................    Output.B20 = 1; 
....................    */ 
....................    //////////////////// 
....................    In.B1 = 0; 
4B84:  BCF    x1A.0
....................    In.B2 = 0; 
4B86:  BCF    x1A.1
....................    In.B3 = 0; 
4B88:  BCF    x1A.2
....................    In.B4 = 0; 
4B8A:  BCF    x1A.3
....................    In.B5 = 0; 
4B8C:  BCF    x1A.4
....................    In.B6 = 0; 
4B8E:  BCF    x1A.5
....................    In.B7 = 0; 
4B90:  BCF    x1A.6
....................    In.B8 = 0; 
4B92:  BCF    x1A.7
....................    In.B9 = 0; 
4B94:  BCF    x1B.0
....................    In.B10 = 0; 
4B96:  BCF    x1B.1
....................    /* 
....................    In.B11 = 0; 
....................    In.B12 = 0; 
....................    In.B13 = 0; 
....................    In.B14 = 0; 
....................    In.B15 = 0; 
....................    In.B16 = 0; 
....................    In.B17 = 0; 
....................    In.B18 = 0; 
....................    In.B19 = 0; 
....................    In.B20 = 0; 
....................    */ 
....................    //////////////////////// 
....................    Ack.B1 = 0; 
4B98:  BCF    x18.0
....................    Ack.B2 = 0; 
4B9A:  BCF    x18.1
....................    Ack.B3 = 0; 
4B9C:  BCF    x18.2
....................    Ack.B4 = 0; 
4B9E:  BCF    x18.3
....................    Ack.B5 = 0; 
4BA0:  BCF    x18.4
....................    Ack.B6 = 0; 
4BA2:  BCF    x18.5
....................    Ack.B7 = 0; 
4BA4:  BCF    x18.6
....................    Ack.B8 = 0; 
4BA6:  BCF    x18.7
....................    Ack.B9 = 0; 
4BA8:  BCF    x19.0
....................    Ack.B10 = 0; 
4BAA:  BCF    x19.1
....................    /* 
....................    Ack.B11 = 0; 
....................    Ack.B12 = 0; 
....................    Ack.B13 = 0; 
....................    Ack.B14 = 0; 
....................    Ack.B15 = 0; 
....................    Ack.B16 = 0; 
....................    Ack.B17 = 0; 
....................    Ack.B18 = 0; 
....................    Ack.B19 = 0; 
....................    Ack.B20 = 0; 
....................  */ 
....................  
....................     /////// read setting ////////// 
....................  
....................    if(read_eeprom(0x00) == 0x0F) 
4BAC:  MOVFF  FF2,1AB
4BB0:  BCF    FF2.7
4BB2:  CLRF   FA9
4BB4:  BCF    FA6.6
4BB6:  BCF    FA6.7
4BB8:  BSF    FA6.0
4BBA:  MOVF   FA8,W
4BBC:  BTFSC  xAB.7
4BBE:  BSF    FF2.7
4BC0:  SUBLW  0F
4BC2:  BNZ   4BCE
....................    { 
....................       Read_Config(); 
4BC4:  MOVLB  0
4BC6:  CALL   06E2
....................    } 
....................    else 
4BCA:  BRA    4DDE
4BCC:  MOVLB  1
....................    { 
....................       FlashingRateTime = 25; 
4BCE:  MOVLW  19
4BD0:  MOVWF  18
....................       AutoAck = 0xF0; //not use auto ack 
4BD2:  MOVLW  F0
4BD4:  MOVWF  5B
....................       Address = 0x01; 
4BD6:  MOVLW  01
4BD8:  MOVWF  69
....................  
....................       AutoAckTime = 5; 
4BDA:  MOVLW  05
4BDC:  MOVWF  5C
....................       FlashingRate = 25; 
4BDE:  MOVLW  19
4BE0:  MOVWF  5D
....................       NoOfPoint = 10; 
4BE2:  MOVLW  0A
4BE4:  MOVWF  5E
....................       char i; 
....................       for(i =0; i<=NoOfPoint; i++) 
4BE6:  CLRF   xA9
4BE8:  MOVF   xA9,W
4BEA:  SUBWF  5E,W
4BEC:  BNC   4C08
....................       { 
....................          FaultDelayTime[i] = 0; 
4BEE:  BCF    FD8.0
4BF0:  RLCF   xA9,W
4BF2:  CLRF   03
4BF4:  ADDLW  6A
4BF6:  MOVWF  FE9
4BF8:  MOVLW  01
4BFA:  ADDWFC 03,W
4BFC:  MOVWF  FEA
4BFE:  CLRF   FEC
4C00:  MOVF   FED,F
4C02:  CLRF   FEF
....................       } 
4C04:  INCF   xA9,F
4C06:  BRA    4BE8
....................  
....................  
....................       InputType.B1 = 1; 
4C08:  BSF    x0E.0
....................       InputType.B2 = 1; 
4C0A:  BSF    x0E.1
....................       InputType.B3 = 1; 
4C0C:  BSF    x0E.2
....................       InputType.B4 = 1; 
4C0E:  BSF    x0E.3
....................       InputType.B5 = 1; 
4C10:  BSF    x0E.4
....................       InputType.B6 = 1; 
4C12:  BSF    x0E.5
....................       InputType.B7 = 1; 
4C14:  BSF    x0E.6
....................       InputType.B8 = 1; 
4C16:  BSF    x0E.7
....................       InputType.B9 = 1; 
4C18:  BSF    x0F.0
....................       InputType.B10 = 1; 
4C1A:  BSF    x0F.1
....................       /* 
....................       InputType.B11 = 1; 
....................       InputType.B12 = 1; 
....................       InputType.B13 = 1; 
....................       InputType.B14 = 1; 
....................       InputType.B15 = 1; 
....................       InputType.B16 = 1; 
....................       InputType.B17 = 1; 
....................       InputType.B18 = 1; 
....................       InputType.B19 = 1; 
....................       InputType.B20 = 1; 
....................       */ 
....................       FaultNCNO[1] = 1; 
4C1C:  BSF    xA6.1
....................       FaultNCNO[2] = 1; 
4C1E:  BSF    xA6.2
....................       FaultNCNO[3] = 1; 
4C20:  BSF    xA6.3
....................       FaultNCNO[4] = 1; 
4C22:  BSF    xA6.4
....................       FaultNCNO[5] = 1; 
4C24:  BSF    xA6.5
....................       FaultNCNO[6] = 1; 
4C26:  BSF    xA6.6
....................       FaultNCNO[7] = 1; 
4C28:  BSF    xA6.7
....................       FaultNCNO[8] = 1; 
4C2A:  BSF    xA7.0
....................       FaultNCNO[9] = 1; 
4C2C:  BSF    xA7.1
....................       FaultNCNO[10] = 1; 
4C2E:  BSF    xA7.2
....................        
....................       ///////////////////////////// 
....................       FaultType.B1 = 1; 
4C30:  BSF    x10.0
....................       FaultType.B2= 1; 
4C32:  BSF    x10.1
....................       FaultType.B3 = 1; 
4C34:  BSF    x10.2
....................       FaultType.B4 = 1; 
4C36:  BSF    x10.3
....................       FaultType.B5 = 1; 
4C38:  BSF    x10.4
....................       FaultType.B6 = 1; 
4C3A:  BSF    x10.5
....................       FaultType.B7 = 1; 
4C3C:  BSF    x10.6
....................       FaultType.B8 = 1; 
4C3E:  BSF    x10.7
....................       FaultType.B9 = 1; 
4C40:  BSF    x11.0
....................       FaultType.B10 = 1; 
4C42:  BSF    x11.1
....................       /* 
....................       FaultType.B11 = 1; 
....................       FaultType.B12 = 1; 
....................       FaultType.B13 = 1; 
....................       FaultType.B14 = 1; 
....................       FaultType.B15 = 1; 
....................       FaultType.B16 = 1; 
....................       FaultType.B17 = 1; 
....................       FaultType.B18 = 1; 
....................       FaultType.B19 = 1; 
....................       FaultType.B20 = 1; 
....................       */ 
....................       //////////////////////////// 
....................       OutputType.B1 = 1; 
4C44:  BSF    x12.0
....................       OutputType.B2 = 1; 
4C46:  BSF    x12.1
....................       OutputType.B3 = 1; 
4C48:  BSF    x12.2
....................       OutputType.B4 = 1; 
4C4A:  BSF    x12.3
....................       OutputType.B5 = 1; 
4C4C:  BSF    x12.4
....................       OutputType.B6 = 1; 
4C4E:  BSF    x12.5
....................       OutputType.B7 = 1; 
4C50:  BSF    x12.6
....................       OutputType.B8 = 1; 
4C52:  BSF    x12.7
....................       OutputType.B9 = 1; 
4C54:  BSF    x13.0
....................       OutputType.B10 = 1; 
4C56:  BSF    x13.1
....................       /* 
....................       OutputType.B11 = 1; 
....................       OutputType.B12 = 1; 
....................       OutputType.B13 = 1; 
....................       OutputType.B14 = 1; 
....................       OutputType.B15 = 1; 
....................       OutputType.B16 = 1; 
....................       OutputType.B17 = 1; 
....................       OutputType.B18 = 1; 
....................       OutputType.B19 = 1; 
....................       OutputType.B20 = 1; 
....................       */ 
....................       ///////////////////////////// 
....................       OutputBoth.B1 = 1; 
4C58:  BSF    x14.0
....................       OutputBoth.B2 = 1; 
4C5A:  BSF    x14.1
....................       OutputBoth.B3 = 1; 
4C5C:  BSF    x14.2
....................       OutputBoth.B4 = 1; 
4C5E:  BSF    x14.3
....................       OutputBoth.B5 = 1; 
4C60:  BSF    x14.4
....................       OutputBoth.B6 = 1; 
4C62:  BSF    x14.5
....................       OutputBoth.B7 = 1; 
4C64:  BSF    x14.6
....................       OutputBoth.B8 = 1; 
4C66:  BSF    x14.7
....................       OutputBoth.B9 = 1; 
4C68:  BSF    x15.0
....................       OutputBoth.B10 = 1; 
4C6A:  BSF    x15.1
....................       /* 
....................       OutputBoth.B11 = 1; 
....................       OutputBoth.B12 = 1; 
....................       OutputBoth.B13 = 1; 
....................       OutputBoth.B14 = 1; 
....................       OutputBoth.B15 = 1; 
....................       OutputBoth.B16 = 1; 
....................       OutputBoth.B17 = 1; 
....................       OutputBoth.B18 = 1; 
....................       OutputBoth.B19 = 1; 
....................       OutputBoth.B20 = 1; 
....................       */ 
....................       ////////////////////////////////////////////// 
....................       AlarmIndicator.B1 = 1; 
4C6C:  BSF    x16.0
....................       AlarmIndicator.B2 = 1; 
4C6E:  BSF    x16.1
....................       AlarmIndicator.B3 = 1; 
4C70:  BSF    x16.2
....................       AlarmIndicator.B4 = 1; 
4C72:  BSF    x16.3
....................       AlarmIndicator.B5 = 1; 
4C74:  BSF    x16.4
....................       AlarmIndicator.B6 = 1; 
4C76:  BSF    x16.5
....................       AlarmIndicator.B7 = 1; 
4C78:  BSF    x16.6
....................       AlarmIndicator.B8 = 1; 
4C7A:  BSF    x16.7
....................       AlarmIndicator.B9 = 1; 
4C7C:  BSF    x17.0
....................       AlarmIndicator.B10 = 1; 
4C7E:  BSF    x17.1
....................       /* 
....................       AlarmIndicator.B11 = 1; 
....................       AlarmIndicator.B12 = 1; 
....................       AlarmIndicator.B13 = 1; 
....................       AlarmIndicator.B14 = 1; 
....................       AlarmIndicator.B15 = 1; 
....................       AlarmIndicator.B16 = 1; 
....................       AlarmIndicator.B17 = 1; 
....................       AlarmIndicator.B18 = 1; 
....................       AlarmIndicator.B19 = 1; 
....................       AlarmIndicator.B20 = 1; 
....................       */ 
....................       ///////////// JACK/////////////////// 
....................    EEpDat = read_eeprom(0x10); 
4C80:  MOVFF  FF2,1AB
4C84:  BCF    FF2.7
4C86:  MOVLW  10
4C88:  MOVWF  FA9
4C8A:  BCF    FA6.6
4C8C:  BCF    FA6.7
4C8E:  BSF    FA6.0
4C90:  MOVF   FA8,W
4C92:  BTFSC  xAB.7
4C94:  BSF    FF2.7
4C96:  MOVWF  37
....................    //Red1_8 = EEpDat; 
....................    RED_Colour.B1 = EEpDat; 
4C98:  BCF    x22.0
4C9A:  BTFSC  37.0
4C9C:  BSF    x22.0
....................    RED_Colour.B2 = EEpDat >> 1; 
4C9E:  BCF    FD8.0
4CA0:  RRCF   37,W
4CA2:  BCF    x22.1
4CA4:  BTFSC  FE8.0
4CA6:  BSF    x22.1
....................    RED_Colour.B3 = EEpDat >> 2; 
4CA8:  RRCF   37,W
4CAA:  MOVWF  00
4CAC:  RRCF   00,F
4CAE:  MOVLW  3F
4CB0:  ANDWF  00,F
4CB2:  BCF    x22.2
4CB4:  BTFSC  00.0
4CB6:  BSF    x22.2
....................    RED_Colour.B4 = EEpDat >> 3; 
4CB8:  RRCF   37,W
4CBA:  MOVWF  00
4CBC:  RRCF   00,F
4CBE:  RRCF   00,F
4CC0:  MOVLW  1F
4CC2:  ANDWF  00,F
4CC4:  BCF    x22.3
4CC6:  BTFSC  00.0
4CC8:  BSF    x22.3
....................    RED_Colour.B5 = EEpDat >> 4; 
4CCA:  SWAPF  37,W
4CCC:  MOVWF  00
4CCE:  MOVLW  0F
4CD0:  ANDWF  00,F
4CD2:  BCF    x22.4
4CD4:  BTFSC  00.0
4CD6:  BSF    x22.4
....................    RED_Colour.B6 = EEpDat >> 5; 
4CD8:  SWAPF  37,W
4CDA:  MOVWF  00
4CDC:  RRCF   00,F
4CDE:  MOVLW  07
4CE0:  ANDWF  00,F
4CE2:  BCF    x22.5
4CE4:  BTFSC  00.0
4CE6:  BSF    x22.5
....................    RED_Colour.B7 = EEpDat >> 6; 
4CE8:  SWAPF  37,W
4CEA:  MOVWF  00
4CEC:  RRCF   00,F
4CEE:  RRCF   00,F
4CF0:  MOVLW  03
4CF2:  ANDWF  00,F
4CF4:  BCF    x22.6
4CF6:  BTFSC  00.0
4CF8:  BSF    x22.6
....................    RED_Colour.B8 = EEpDat >> 7; 
4CFA:  CLRF   00
4CFC:  BTFSC  37.7
4CFE:  BSF    00.0
4D00:  BCF    x22.7
4D02:  BTFSC  00.0
4D04:  BSF    x22.7
....................     
....................    EEpDat = read_eeprom(0x11); 
4D06:  MOVFF  FF2,1AB
4D0A:  BCF    FF2.7
4D0C:  MOVLW  11
4D0E:  MOVWF  FA9
4D10:  BCF    FA6.6
4D12:  BCF    FA6.7
4D14:  BSF    FA6.0
4D16:  MOVF   FA8,W
4D18:  BTFSC  xAB.7
4D1A:  BSF    FF2.7
4D1C:  MOVWF  37
....................    //Green9_10 = EEpDat; 
....................    RED_Colour.B9 = EEpDat; 
4D1E:  BCF    x23.0
4D20:  BTFSC  37.0
4D22:  BSF    x23.0
....................    RED_Colour.B10 = EEpDat >> 1; 
4D24:  BCF    FD8.0
4D26:  RRCF   37,W
4D28:  BCF    x23.1
4D2A:  BTFSC  FE8.0
4D2C:  BSF    x23.1
....................     
....................    /* 
....................    EEpDat = read_eeprom(0x12); 
....................    //Red11_18 = EEpDat; 
....................    RED_Colour.B11 = EEpDat; 
....................    RED_Colour.B12 = EEpDat >> 1; 
....................    RED_Colour.B13 = EEpDat >> 2; 
....................    RED_Colour.B14 = EEpDat >> 3; 
....................    RED_Colour.B15 = EEpDat >> 4; 
....................    RED_Colour.B16 = EEpDat >> 5; 
....................    RED_Colour.B17 = EEpDat >> 6; 
....................    RED_Colour.B18 = EEpDat >> 7; 
....................     
....................    EEpDat = read_eeprom(0x13); 
....................    //Red19_20 = EEpDat; 
....................    RED_Colour.B19 = EEpDat; 
....................    RED_Colour.B20 = EEpDat >> 1; 
....................    */ 
....................     
....................    EEpDat = read_eeprom(0x14); 
4D2E:  MOVFF  FF2,1AB
4D32:  BCF    FF2.7
4D34:  MOVLW  14
4D36:  MOVWF  FA9
4D38:  BCF    FA6.6
4D3A:  BCF    FA6.7
4D3C:  BSF    FA6.0
4D3E:  MOVF   FA8,W
4D40:  BTFSC  xAB.7
4D42:  BSF    FF2.7
4D44:  MOVWF  37
....................    //Green1_8 = EEpDat; 
....................    GREEN_Colour.B1 = EEpDat; 
4D46:  BCF    x24.0
4D48:  BTFSC  37.0
4D4A:  BSF    x24.0
....................    GREEN_Colour.B2 = EEpDat >> 1; 
4D4C:  BCF    FD8.0
4D4E:  RRCF   37,W
4D50:  BCF    x24.1
4D52:  BTFSC  FE8.0
4D54:  BSF    x24.1
....................    GREEN_Colour.B3 = EEpDat >> 2; 
4D56:  RRCF   37,W
4D58:  MOVWF  00
4D5A:  RRCF   00,F
4D5C:  MOVLW  3F
4D5E:  ANDWF  00,F
4D60:  BCF    x24.2
4D62:  BTFSC  00.0
4D64:  BSF    x24.2
....................    GREEN_Colour.B4 = EEpDat >> 3; 
4D66:  RRCF   37,W
4D68:  MOVWF  00
4D6A:  RRCF   00,F
4D6C:  RRCF   00,F
4D6E:  MOVLW  1F
4D70:  ANDWF  00,F
4D72:  BCF    x24.3
4D74:  BTFSC  00.0
4D76:  BSF    x24.3
....................    GREEN_Colour.B5 = EEpDat >> 4; 
4D78:  SWAPF  37,W
4D7A:  MOVWF  00
4D7C:  MOVLW  0F
4D7E:  ANDWF  00,F
4D80:  BCF    x24.4
4D82:  BTFSC  00.0
4D84:  BSF    x24.4
....................    GREEN_Colour.B6 = EEpDat >> 5; 
4D86:  SWAPF  37,W
4D88:  MOVWF  00
4D8A:  RRCF   00,F
4D8C:  MOVLW  07
4D8E:  ANDWF  00,F
4D90:  BCF    x24.5
4D92:  BTFSC  00.0
4D94:  BSF    x24.5
....................    GREEN_Colour.B7 = EEpDat >> 6; 
4D96:  SWAPF  37,W
4D98:  MOVWF  00
4D9A:  RRCF   00,F
4D9C:  RRCF   00,F
4D9E:  MOVLW  03
4DA0:  ANDWF  00,F
4DA2:  BCF    x24.6
4DA4:  BTFSC  00.0
4DA6:  BSF    x24.6
....................    GREEN_Colour.B8 = EEpDat >> 7; 
4DA8:  CLRF   00
4DAA:  BTFSC  37.7
4DAC:  BSF    00.0
4DAE:  BCF    x24.7
4DB0:  BTFSC  00.0
4DB2:  BSF    x24.7
....................     
....................    EEpDat = read_eeprom(0x15); 
4DB4:  MOVFF  FF2,1AB
4DB8:  BCF    FF2.7
4DBA:  MOVLW  15
4DBC:  MOVWF  FA9
4DBE:  BCF    FA6.6
4DC0:  BCF    FA6.7
4DC2:  BSF    FA6.0
4DC4:  MOVF   FA8,W
4DC6:  BTFSC  xAB.7
4DC8:  BSF    FF2.7
4DCA:  MOVWF  37
....................    //Green9_10 = EEpDat; 
....................    GREEN_Colour.B9 = EEpDat; 
4DCC:  BCF    x25.0
4DCE:  BTFSC  37.0
4DD0:  BSF    x25.0
....................    GREEN_Colour.B10 = EEpDat >> 1; 
4DD2:  BCF    FD8.0
4DD4:  RRCF   37,W
4DD6:  BCF    x25.1
4DD8:  BTFSC  FE8.0
4DDA:  BSF    x25.1
4DDC:  MOVLB  0
....................     
....................    /* 
....................    EEpDat = read_eeprom(0x16); 
....................    //Green11_18 = EEpDat; 
....................    GREEN_Colour.B11 = EEpDat; 
....................    GREEN_Colour.B12 = EEpDat >> 1; 
....................    GREEN_Colour.B13 = EEpDat >> 2; 
....................    GREEN_Colour.B14 = EEpDat >> 3; 
....................    GREEN_Colour.B15 = EEpDat >> 4; 
....................    GREEN_Colour.B16 = EEpDat >> 5; 
....................    GREEN_Colour.B17 = EEpDat >> 6; 
....................    GREEN_Colour.B18 = EEpDat >> 7; 
....................     
....................    EEpDat = read_eeprom(0x17); 
....................    //Green19_20 = EEpDat; 
....................    GREEN_Colour.B19 = EEpDat; 
....................    GREEN_Colour.B20 = EEpDat >> 1; 
....................    */ 
....................    ///////////// JACK///////////////////////////////////// 
....................        
....................    } 
....................     
....................    
....................    set_tris_a (0b00000000); //PORTA SET TO OUTPUT 
4DDE:  MOVLW  00
4DE0:  MOVWF  F92
....................    set_tris_b (0b00000000); //PORTA SET TO OUTPUT 
4DE2:  MOVWF  F93
....................    enable_interrupts(GLOBAL); 
4DE4:  MOVLW  C0
4DE6:  IORWF  FF2,F
....................    setup_wdt(WDT_ON); 
4DE8:  BSF    FD1.0
....................    Read_input(); restart_wdt(); 
4DEA:  CALL   0FF2
4DEE:  CLRWDT
....................    output_bit(Pbuzzer,0);   //Clear Buzzer 
4DF0:  BCF    F89.4
4DF2:  BCF    F92.4
....................    output_bit(Pbell,0);     //Clear Bell 
4DF4:  BCF    F89.3
4DF6:  BCF    F92.3
....................    output_bit(P485ctrl,0); 
4DF8:  BCF    F8A.3
4DFA:  BCF    F93.3
....................    output_bit(PIN_B4,1); //jj 
4DFC:  BSF    F8A.4
4DFE:  BCF    F93.4
....................    Send_Ouput(); 
4E00:  CALL   1812
....................     
....................    delay_ms(500); 
4E04:  MOVLW  02
4E06:  MOVLB  1
4E08:  MOVWF  xAB
4E0A:  MOVLW  FA
4E0C:  MOVWF  xB3
4E0E:  MOVLB  0
4E10:  CALL   05C4
4E14:  MOVLB  1
4E16:  DECFSZ xAB,F
4E18:  BRA    4E0A
....................     
....................    // jj 
....................    char i; 
....................    for(i=1;i<=10;i++) 
4E1A:  MOVLW  01
4E1C:  MOVWF  xAA
4E1E:  MOVF   xAA,W
4E20:  SUBLW  0A
4E22:  BTFSS  FD8.0
4E24:  BRA    4F2E
....................    { 
....................       FaultAgo[i] = 0; 
4E26:  MOVFF  1AA,1AD
4E2A:  CLRF   xAE
4E2C:  MOVLW  01
4E2E:  MOVWF  xB0
4E30:  MOVLW  26
4E32:  MOVWF  xAF
4E34:  MOVLB  0
4E36:  CALL   0F6C
....................       FaultNow[i] = 0; 
4E3A:  MOVFF  1AA,1AD
4E3E:  MOVLB  1
4E40:  CLRF   xAE
4E42:  MOVLW  01
4E44:  MOVWF  xB0
4E46:  MOVLW  2A
4E48:  MOVWF  xAF
4E4A:  MOVLB  0
4E4C:  CALL   0F6C
....................       ReleaseTime[i] = 0; 
4E50:  BCF    FD8.0
4E52:  MOVLB  1
4E54:  RLCF   xAA,W
4E56:  CLRF   03
4E58:  ADDLW  2E
4E5A:  MOVWF  FE9
4E5C:  MOVLW  01
4E5E:  ADDWFC 03,W
4E60:  MOVWF  FEA
4E62:  CLRF   FEC
4E64:  MOVF   FED,F
4E66:  CLRF   FEF
....................       if(FaultNCNO[i] ==NO) 
4E68:  MOVFF  1AA,1AD
4E6C:  MOVLW  01
4E6E:  MOVWF  xAF
4E70:  MOVLW  A6
4E72:  MOVWF  xAE
4E74:  MOVLB  0
4E76:  CALL   0F18
4E7A:  MOVLW  00
4E7C:  BTFSC  01.0
4E7E:  MOVLW  01
4E80:  ANDLW  01
4E82:  SUBLW  01
4E84:  BNZ   4EDA
....................       { 
....................          switch(i) 
....................          { 
4E86:  MOVLW  01
4E88:  MOVLB  1
4E8A:  SUBWF  xAA,W
4E8C:  ADDLW  F6
4E8E:  BC    4ED6
4E90:  ADDLW  0A
4E92:  MOVLB  0
4E94:  GOTO   50A2
....................             case 1: 
....................                Inputt.B1 = 1;  
4E98:  MOVLB  1
4E9A:  BSF    x0A.0
....................             break; 
4E9C:  BRA    4ED6
....................             case 2: 
....................                Inputt.B2 = 1;  
4E9E:  MOVLB  1
4EA0:  BSF    x0A.1
....................             break; 
4EA2:  BRA    4ED6
....................             case 3: 
....................                Inputt.B3 = 1;  
4EA4:  MOVLB  1
4EA6:  BSF    x0A.2
....................             break; 
4EA8:  BRA    4ED6
....................             case 4: 
....................                Inputt.B4 = 1;  
4EAA:  MOVLB  1
4EAC:  BSF    x0A.3
....................             break; 
4EAE:  BRA    4ED6
....................             case 5: 
....................                Inputt.B5 = 1;  
4EB0:  MOVLB  1
4EB2:  BSF    x0A.4
....................             break; 
4EB4:  BRA    4ED6
....................             case 6: 
....................                Inputt.B6 = 1;  
4EB6:  MOVLB  1
4EB8:  BSF    x0A.5
....................             break; 
4EBA:  BRA    4ED6
....................             case 7: 
....................                Inputt.B7 = 1;  
4EBC:  MOVLB  1
4EBE:  BSF    x0A.6
....................              break; 
4EC0:  BRA    4ED6
....................              case 8: 
....................                Inputt.B8 = 1;  
4EC2:  MOVLB  1
4EC4:  BSF    x0A.7
....................             break; 
4EC6:  BRA    4ED6
....................             case 9: 
....................                Inputt.B9 = 1;  
4EC8:  MOVLB  1
4ECA:  BSF    x0B.0
....................             break; 
4ECC:  BRA    4ED6
....................             case 10: 
....................                Inputt.B10 = 1;  
4ECE:  MOVLB  1
4ED0:  BSF    x0B.1
....................             break; 
4ED2:  BRA    4ED6
4ED4:  MOVLB  1
....................             /* 
....................             case 11: 
....................                Inputt.B11 = 1;  
....................             break; 
....................             case 12: 
....................                Inputt.B12 = 1;  
....................             break; 
....................             case 13: 
....................                Inputt.B13 = 1;  
....................             break; 
....................             case 14: 
....................                Inputt.B14 = 1;  
....................             break; 
....................             case 15: 
....................                Inputt.B15 = 1;  
....................             break; 
....................             case 16: 
....................                 Inputt.B16 = 1; 
....................              break; 
....................              */           
....................          }                  
....................       } 
....................       else 
4ED6:  BRA    4F2A
4ED8:  MOVLB  0
....................       { 
....................          switch(i) 
....................          { 
4EDA:  MOVLW  01
4EDC:  MOVLB  1
4EDE:  SUBWF  xAA,W
4EE0:  ADDLW  F6
4EE2:  BC    4F2A
4EE4:  ADDLW  0A
4EE6:  MOVLB  0
4EE8:  GOTO   50DA
....................             case 1: 
....................                Inputt.B1 = 0;  
4EEC:  MOVLB  1
4EEE:  BCF    x0A.0
....................             break; 
4EF0:  BRA    4F2A
....................             case 2: 
....................                Inputt.B2 = 0;  
4EF2:  MOVLB  1
4EF4:  BCF    x0A.1
....................             break; 
4EF6:  BRA    4F2A
....................             case 3: 
....................                Inputt.B3 = 0;  
4EF8:  MOVLB  1
4EFA:  BCF    x0A.2
....................             break; 
4EFC:  BRA    4F2A
....................             case 4: 
....................                Inputt.B4 = 0;  
4EFE:  MOVLB  1
4F00:  BCF    x0A.3
....................             break; 
4F02:  BRA    4F2A
....................             case 5: 
....................                Inputt.B5 = 0;  
4F04:  MOVLB  1
4F06:  BCF    x0A.4
....................             break; 
4F08:  BRA    4F2A
....................             case 6: 
....................                Inputt.B6 = 0;  
4F0A:  MOVLB  1
4F0C:  BCF    x0A.5
....................             break; 
4F0E:  BRA    4F2A
....................             case 7: 
....................                Inputt.B7 = 0;  
4F10:  MOVLB  1
4F12:  BCF    x0A.6
....................              break; 
4F14:  BRA    4F2A
....................              case 8: 
....................                Inputt.B8 = 0;  
4F16:  MOVLB  1
4F18:  BCF    x0A.7
....................             break; 
4F1A:  BRA    4F2A
....................             case 9: 
....................                Inputt.B9 = 0;  
4F1C:  MOVLB  1
4F1E:  BCF    x0B.0
....................             break; 
4F20:  BRA    4F2A
....................             case 10: 
....................                Inputt.B10 = 0;  
4F22:  MOVLB  1
4F24:  BCF    x0B.1
....................             break; 
4F26:  BRA    4F2A
4F28:  MOVLB  1
....................             /* 
....................             case 11: 
....................                Inputt.B11 = 0;  
....................             break; 
....................             case 12: 
....................                Inputt.B12 = 0;  
....................             break; 
....................             case 13: 
....................                Inputt.B13 = 0;  
....................             break; 
....................             case 14: 
....................                Inputt.B14 = 0;  
....................             break; 
....................             case 15: 
....................                Inputt.B15 = 0;  
....................             break; 
....................             case 16: 
....................                 Inputt.B16 = 0; 
....................              break; 
....................              */           
....................          }                  
....................       }  
....................    } 
4F2A:  INCF   xAA,F
4F2C:  BRA    4E1E
....................     
....................    while(TRUE) 
....................    { 
....................  
....................       IO_OUTPUT_A(IO_DEVICE_0, 0xFF); //jj  
4F2E:  CLRF   xB3
4F30:  MOVLW  FF
4F32:  MOVWF  xB4
4F34:  MOVLB  0
4F36:  CALL   17E6
....................       IO_OUTPUT_B(IO_DEVICE_0, 0xFF); //jj  
4F3A:  MOVLB  1
4F3C:  CLRF   xB3
4F3E:  MOVLW  FF
4F40:  MOVWF  xB4
4F42:  MOVLB  0
4F44:  CALL   17FC
....................       IO_OUTPUT_A(IO_DEVICE_1, 0xFF); //jj  
4F48:  MOVLW  02
4F4A:  MOVLB  1
4F4C:  MOVWF  xB3
4F4E:  MOVLW  FF
4F50:  MOVWF  xB4
4F52:  MOVLB  0
4F54:  CALL   17E6
....................       IO_OUTPUT_B(IO_DEVICE_1, 0xFF); //jj  
4F58:  MOVLW  02
4F5A:  MOVLB  1
4F5C:  MOVWF  xB3
4F5E:  MOVLW  FF
4F60:  MOVWF  xB4
4F62:  MOVLB  0
4F64:  CALL   17FC
....................       restart_wdt(); 
4F68:  CLRWDT
....................  
....................       if(recieve_completed == 1) 
4F6A:  BTFSS  2D.4
4F6C:  BRA    4F74
....................       { 
....................          Modbus_Function(); 
4F6E:  GOTO   1E88
....................          recieve_completed = 0 ; 
4F72:  BCF    2D.4
....................       } 
....................        
....................  
....................    /* 
....................       if(input(PSyncR) != SyncFlag)      //Check Sync 
....................       { 
....................          FlashingFlag = input(PSyncR); 
....................          SyncFlag = input(PSyncR); 
....................          output_bit(PSyncS,SyncFlag); 
....................          SyncStatus = 1; 
....................          Synctimer = 200; 
....................       } 
....................    */ 
....................     
....................  
....................       check_ack(); 
4F74:  CALL   1C7A
....................       check_reset(); 
4F78:  CALL   1D68
....................       check_test(); 
4F7C:  BRA    47D0
....................        
....................       restart_wdt(); 
4F7E:  CLRWDT
....................        
....................        
....................       Read_input(); restart_wdt();//Must be first 
4F80:  CALL   0FF2
4F84:  CLRWDT
....................       Anal_Function(); restart_wdt(); 
4F86:  CALL   39A6
4F8A:  CLRWDT
....................       Send_Ouput(); restart_wdt(); 
4F8C:  CALL   1812
4F90:  CLRWDT
....................       Driver595(); restart_wdt(); 
4F92:  BRA    489C
4F94:  CLRWDT
....................        
....................        
....................       output_toggle(PIN_A0); 
4F96:  BCF    F92.0
4F98:  BTG    F89.0
....................        
....................       if(RefreshConfigData) 
4F9A:  BTFSS  2D.3
4F9C:  BRA    509C
....................       { 
....................          RefreshConfigData =0; 
4F9E:  BCF    2D.3
....................          Read_Config(); 
4FA0:  CALL   06E2
....................          //IO_INIT();   //initializes the MCP23S17 chip.//----------jj 
....................    
....................          IO_SET_TRIS_A(IO_DEVICE_0, 0xFF); //addr.0 Set PortA As Input 
4FA4:  MOVLB  1
4FA6:  CLRF   xAB
4FA8:  MOVLW  FF
4FAA:  MOVWF  xAC
4FAC:  MOVLB  0
4FAE:  CALL   06BC
....................          IO_SET_TRIS_B(IO_DEVICE_0, 0xFF); //addr.0 Set PortB As Input 
4FB2:  MOVLB  1
4FB4:  CLRF   xAB
4FB6:  MOVLW  FF
4FB8:  MOVWF  xAC
4FBA:  MOVLB  0
4FBC:  CALL   06CE
....................          IO_SET_TRIS_A(IO_DEVICE_1, 0xFF); //addr.1 Set PortA As Input  
4FC0:  MOVLW  02
4FC2:  MOVLB  1
4FC4:  MOVWF  xAB
4FC6:  MOVLW  FF
4FC8:  MOVWF  xAC
4FCA:  MOVLB  0
4FCC:  CALL   06BC
....................          IO_SET_TRIS_B(IO_DEVICE_1, 0xFF); //addr.1 Set PortB As Input 
4FD0:  MOVLW  02
4FD2:  MOVLB  1
4FD4:  MOVWF  xAB
4FD6:  MOVLW  FF
4FD8:  MOVWF  xAC
4FDA:  MOVLB  0
4FDC:  CALL   06CE
....................          //  jj 
....................          IO_WRITE_REGISTER(IO_DEVICE_0, GPPUA, 0xFF); // Input Pullup 
4FE0:  MOVLB  1
4FE2:  CLRF   xB5
4FE4:  MOVLW  06
4FE6:  MOVWF  xB6
4FE8:  MOVLW  FF
4FEA:  MOVWF  xB7
4FEC:  MOVLB  0
4FEE:  CALL   05F4
....................          IO_WRITE_REGISTER(IO_DEVICE_0, GPPUB, 0xFF); // Input Pullup 
4FF2:  MOVLB  1
4FF4:  CLRF   xB5
4FF6:  MOVLW  16
4FF8:  MOVWF  xB6
4FFA:  MOVLW  FF
4FFC:  MOVWF  xB7
4FFE:  MOVLB  0
5000:  CALL   05F4
....................          IO_WRITE_REGISTER(IO_DEVICE_1, GPPUA, 0xFF); // Input Pullup 
5004:  MOVLW  02
5006:  MOVLB  1
5008:  MOVWF  xB5
500A:  MOVLW  06
500C:  MOVWF  xB6
500E:  MOVLW  FF
5010:  MOVWF  xB7
5012:  MOVLB  0
5014:  CALL   05F4
....................          IO_WRITE_REGISTER(IO_DEVICE_1, GPPUB, 0xFF); // Input Pullup 
5018:  MOVLW  02
501A:  MOVLB  1
501C:  MOVWF  xB5
501E:  MOVLW  16
5020:  MOVWF  xB6
5022:  MOVLW  FF
5024:  MOVWF  xB7
5026:  MOVLB  0
5028:  CALL   05F4
....................          //  jj 
....................          IO_SET_TRIS_A(IO_DEVICE_2, 0x00); //addr.2 Set PortA As Output  
502C:  MOVLW  04
502E:  MOVLB  1
5030:  MOVWF  xAB
5032:  CLRF   xAC
5034:  MOVLB  0
5036:  CALL   06BC
....................          IO_SET_TRIS_B(IO_DEVICE_2, 0x00); //addr.2 Set PortB As Output 
503A:  MOVLW  04
503C:  MOVLB  1
503E:  MOVWF  xAB
5040:  CLRF   xAC
5042:  MOVLB  0
5044:  CALL   06CE
....................          IO_SET_TRIS_A(IO_DEVICE_3, 0x00); //addr.3 Set PortA As Output  
5048:  MOVLW  06
504A:  MOVLB  1
504C:  MOVWF  xAB
504E:  CLRF   xAC
5050:  MOVLB  0
5052:  CALL   06BC
....................          IO_SET_TRIS_B(IO_DEVICE_3, 0x00); //addr.3 Set PortB As Output 
5056:  MOVLW  06
5058:  MOVLB  1
505A:  MOVWF  xAB
505C:  CLRF   xAC
505E:  MOVLB  0
5060:  CALL   06CE
....................          IO_SET_TRIS_A(IO_DEVICE_4, 0x00); //addr.4 Set PortA As Output  
5064:  MOVLW  08
5066:  MOVLB  1
5068:  MOVWF  xAB
506A:  CLRF   xAC
506C:  MOVLB  0
506E:  CALL   06BC
....................          IO_SET_TRIS_B(IO_DEVICE_4, 0x00); //addr.4 Set PortB As Output  
5072:  MOVLW  08
5074:  MOVLB  1
5076:  MOVWF  xAB
5078:  CLRF   xAC
507A:  MOVLB  0
507C:  CALL   06CE
....................          IO_SET_TRIS_A(IO_DEVICE_5, 0x00); //addr.5 Set PortA As Output  
5080:  MOVLW  0A
5082:  MOVLB  1
5084:  MOVWF  xAB
5086:  CLRF   xAC
5088:  MOVLB  0
508A:  CALL   06BC
....................          IO_SET_TRIS_B(IO_DEVICE_5, 0x00); //addr.5 Set PortB As Output 
508E:  MOVLW  0A
5090:  MOVLB  1
5092:  MOVWF  xAB
5094:  CLRF   xAC
5096:  MOVLB  0
5098:  CALL   06CE
....................       } 
....................        
....................       /*         
....................       if(outmcp23) 
....................       { 
....................          outmcp23 = 0; 
....................          FlashingRateTime = 1; //100 time per sec. 
....................           
....................          MCP23s17_Ip_dat = IO_INPUT_A(IO_DEVICE_0); 
....................          restart_wdt(); 
....................                    
....................          MCP23s17_Ip_dat = IO_INPUT_B(IO_DEVICE_0); 
....................          restart_wdt(); 
....................                  
....................          IO_OUTPUT_A(IO_DEVICE_1, MCP23s17_Ip_dat); 
....................          restart_wdt(); 
....................           
....................          IO_OUTPUT_B(IO_DEVICE_1, MCP23s17_Ip_dat); 
....................          restart_wdt();    
....................          
....................       } 
....................       */ 
....................    } 
509C:  MOVLB  1
509E:  BRA    4F2E
....................     
.................... } 
50A0:  SLEEP 

Configuration Fuses:
   Word  1: 2200   HS NOOSCSEN
   Word  2: 0D0F   BROWNOUT WDT64 WDT BORV20 NOPUT
   Word  3: 0100   CCP2C1
   Word  4: 0081   STVREN NODEBUG NOLVP
   Word  5: C000   PROTECT NOCPD NOCPB
   Word  6: E00F   NOWRT NOWRTD NOWRTB NOWRTC
   Word  7: 400F   NOEBTR NOEBTRB
