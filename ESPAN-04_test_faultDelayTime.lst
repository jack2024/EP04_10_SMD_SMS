CCS PCH C Compiler, Version 5.091, 5967               28-¡.Â.-21 16:52

               Filename:   D:\jobESP\ESPAN-04\Firmware\SPAN-04\ESPAN04_10 - Delay - SP - SMD -SMS\ESPAN-04_test_faultDelayTime.lst

               ROM used:   27248 bytes (42%)
                           Largest free fragment is 38284
               RAM used:   2003 (51%) at main() level
                           2018 (52%) worst case
               Stack used: 4 locations (3 in main + 1 for interrupts)
               Stack size: 31

00000:  GOTO   6236
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  FF5,15
0003C:  MOVFF  FF6,16
00040:  MOVFF  FF7,17
00044:  MOVFF  00,0E
00048:  MOVFF  01,0F
0004C:  MOVFF  02,10
00050:  MOVFF  03,11
00054:  BTFSS  F9D.0
00056:  GOTO   0060
0005A:  BTFSC  F9E.0
0005C:  GOTO   05C6
00060:  BTFSS  F9D.1
00062:  GOTO   006C
00066:  BTFSC  F9E.1
00068:  GOTO   05CC
0006C:  BTFSS  F9D.5
0006E:  GOTO   0078
00072:  BTFSC  F9E.5
00074:  GOTO   05B6
00078:  MOVFF  0E,00
0007C:  MOVFF  0F,01
00080:  MOVFF  10,02
00084:  MOVFF  11,03
00088:  MOVFF  0C,FE9
0008C:  MOVFF  07,FEA
00090:  BSF    07.7
00092:  MOVFF  08,FE1
00096:  MOVFF  09,FE2
0009A:  MOVFF  0A,FD9
0009E:  MOVFF  0B,FDA
000A2:  MOVFF  12,FF3
000A6:  MOVFF  13,FF4
000AA:  MOVFF  14,FFA
000AE:  MOVFF  15,FF5
000B2:  MOVFF  16,FF6
000B6:  MOVFF  17,FF7
000BA:  MOVF   04,W
000BC:  MOVFF  06,FE0
000C0:  MOVFF  05,FD8
000C4:  RETFIE 0
.................... 
.................... #include "D:\jobESP\ESPAN-04\Firmware\SPAN-04\ESPAN04_20 - Delay - SP - SMD - SMS\string.h"
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... #device PIC18F26K22 
000C6:  CLRF   FF7
000C8:  ADDLW  D6
000CA:  MOVWF  FF6
000CC:  MOVLW  00
000CE:  ADDWFC FF7,F
000D0:  TBLRD*+
000D2:  MOVF   FF5,W
000D4:  RETURN 0
000D6:  DATA 00,C1
000D8:  DATA 81,40
000DA:  DATA 01,C0
000DC:  DATA 80,41
000DE:  DATA 01,C0
000E0:  DATA 80,41
000E2:  DATA 00,C1
000E4:  DATA 81,40
000E6:  DATA 01,C0
000E8:  DATA 80,41
000EA:  DATA 00,C1
000EC:  DATA 81,40
000EE:  DATA 00,C1
000F0:  DATA 81,40
000F2:  DATA 01,C0
000F4:  DATA 80,41
000F6:  DATA 01,C0
000F8:  DATA 80,41
000FA:  DATA 00,C1
000FC:  DATA 81,40
000FE:  DATA 00,C1
00100:  DATA 81,40
00102:  DATA 01,C0
00104:  DATA 80,41
00106:  DATA 00,C1
00108:  DATA 81,40
0010A:  DATA 01,C0
0010C:  DATA 80,41
0010E:  DATA 01,C0
00110:  DATA 80,41
00112:  DATA 00,C1
00114:  DATA 81,40
00116:  DATA 01,C0
00118:  DATA 80,41
0011A:  DATA 00,C1
0011C:  DATA 81,40
0011E:  DATA 00,C1
00120:  DATA 81,40
00122:  DATA 01,C0
00124:  DATA 80,41
00126:  DATA 00,C1
00128:  DATA 81,40
0012A:  DATA 01,C0
0012C:  DATA 80,41
0012E:  DATA 01,C0
00130:  DATA 80,41
00132:  DATA 00,C1
00134:  DATA 81,40
00136:  DATA 00,C1
00138:  DATA 81,40
0013A:  DATA 01,C0
0013C:  DATA 80,41
0013E:  DATA 01,C0
00140:  DATA 80,41
00142:  DATA 00,C1
00144:  DATA 81,40
00146:  DATA 01,C0
00148:  DATA 80,41
0014A:  DATA 00,C1
0014C:  DATA 81,40
0014E:  DATA 00,C1
00150:  DATA 81,40
00152:  DATA 01,C0
00154:  DATA 80,41
00156:  DATA 01,C0
00158:  DATA 80,41
0015A:  DATA 00,C1
0015C:  DATA 81,40
0015E:  DATA 00,C1
00160:  DATA 81,40
00162:  DATA 01,C0
00164:  DATA 80,41
00166:  DATA 00,C1
00168:  DATA 81,40
0016A:  DATA 01,C0
0016C:  DATA 80,41
0016E:  DATA 01,C0
00170:  DATA 80,41
00172:  DATA 00,C1
00174:  DATA 81,40
00176:  DATA 00,C1
00178:  DATA 81,40
0017A:  DATA 01,C0
0017C:  DATA 80,41
0017E:  DATA 01,C0
00180:  DATA 80,41
00182:  DATA 00,C1
00184:  DATA 81,40
00186:  DATA 01,C0
00188:  DATA 80,41
0018A:  DATA 00,C1
0018C:  DATA 81,40
0018E:  DATA 00,C1
00190:  DATA 81,40
00192:  DATA 01,C0
00194:  DATA 80,41
00196:  DATA 00,C1
00198:  DATA 81,40
0019A:  DATA 01,C0
0019C:  DATA 80,41
0019E:  DATA 01,C0
001A0:  DATA 80,41
001A2:  DATA 00,C1
001A4:  DATA 81,40
001A6:  DATA 01,C0
001A8:  DATA 80,41
001AA:  DATA 00,C1
001AC:  DATA 81,40
001AE:  DATA 00,C1
001B0:  DATA 81,40
001B2:  DATA 01,C0
001B4:  DATA 80,41
001B6:  DATA 01,C0
001B8:  DATA 80,41
001BA:  DATA 00,C1
001BC:  DATA 81,40
001BE:  DATA 00,C1
001C0:  DATA 81,40
001C2:  DATA 01,C0
001C4:  DATA 80,41
001C6:  DATA 00,C1
001C8:  DATA 81,40
001CA:  DATA 01,C0
001CC:  DATA 80,41
001CE:  DATA 01,C0
001D0:  DATA 80,41
001D2:  DATA 00,C1
001D4:  DATA 81,40
001D6:  CLRF   FF7
001D8:  ADDLW  E6
001DA:  MOVWF  FF6
001DC:  MOVLW  01
001DE:  ADDWFC FF7,F
001E0:  TBLRD*+
001E2:  MOVF   FF5,W
001E4:  RETURN 0
001E6:  DATA 00,C0
001E8:  DATA C1,01
001EA:  DATA C3,03
001EC:  DATA 02,C2
001EE:  DATA C6,06
001F0:  DATA 07,C7
001F2:  DATA 05,C5
001F4:  DATA C4,04
001F6:  DATA CC,0C
001F8:  DATA 0D,CD
001FA:  DATA 0F,CF
001FC:  DATA CE,0E
001FE:  DATA 0A,CA
00200:  DATA CB,0B
00202:  DATA C9,09
00204:  DATA 08,C8
00206:  DATA D8,18
00208:  DATA 19,D9
0020A:  DATA 1B,DB
0020C:  DATA DA,1A
0020E:  DATA 1E,DE
00210:  DATA DF,1F
00212:  DATA DD,1D
00214:  DATA 1C,DC
00216:  DATA 14,D4
00218:  DATA D5,15
0021A:  DATA D7,17
0021C:  DATA 16,D6
0021E:  DATA D2,12
00220:  DATA 13,D3
00222:  DATA 11,D1
00224:  DATA D0,10
00226:  DATA F0,30
00228:  DATA 31,F1
0022A:  DATA 33,F3
0022C:  DATA F2,32
0022E:  DATA 36,F6
00230:  DATA F7,37
00232:  DATA F5,35
00234:  DATA 34,F4
00236:  DATA 3C,FC
00238:  DATA FD,3D
0023A:  DATA FF,3F
0023C:  DATA 3E,FE
0023E:  DATA FA,3A
00240:  DATA 3B,FB
00242:  DATA 39,F9
00244:  DATA F8,38
00246:  DATA 28,E8
00248:  DATA E9,29
0024A:  DATA EB,2B
0024C:  DATA 2A,EA
0024E:  DATA EE,2E
00250:  DATA 2F,EF
00252:  DATA 2D,ED
00254:  DATA EC,2C
00256:  DATA E4,24
00258:  DATA 25,E5
0025A:  DATA 27,E7
0025C:  DATA E6,26
0025E:  DATA 22,E2
00260:  DATA E3,23
00262:  DATA E1,21
00264:  DATA 20,E0
00266:  DATA A0,60
00268:  DATA 61,A1
0026A:  DATA 63,A3
0026C:  DATA A2,62
0026E:  DATA 66,A6
00270:  DATA A7,67
00272:  DATA A5,65
00274:  DATA 64,A4
00276:  DATA 6C,AC
00278:  DATA AD,6D
0027A:  DATA AF,6F
0027C:  DATA 6E,AE
0027E:  DATA AA,6A
00280:  DATA 6B,AB
00282:  DATA 69,A9
00284:  DATA A8,68
00286:  DATA 78,B8
00288:  DATA B9,79
0028A:  DATA BB,7B
0028C:  DATA 7A,BA
0028E:  DATA BE,7E
00290:  DATA 7F,BF
00292:  DATA 7D,BD
00294:  DATA BC,7C
00296:  DATA B4,74
00298:  DATA 75,B5
0029A:  DATA 77,B7
0029C:  DATA B6,76
0029E:  DATA 72,B2
002A0:  DATA B3,73
002A2:  DATA B1,71
002A4:  DATA 70,B0
002A6:  DATA 50,90
002A8:  DATA 91,51
002AA:  DATA 93,53
002AC:  DATA 52,92
002AE:  DATA 96,56
002B0:  DATA 57,97
002B2:  DATA 55,95
002B4:  DATA 94,54
002B6:  DATA 9C,5C
002B8:  DATA 5D,9D
002BA:  DATA 5F,9F
002BC:  DATA 9E,5E
002BE:  DATA 5A,9A
002C0:  DATA 9B,5B
002C2:  DATA 99,59
002C4:  DATA 58,98
002C6:  DATA 88,48
002C8:  DATA 49,89
002CA:  DATA 4B,8B
002CC:  DATA 8A,4A
002CE:  DATA 4E,8E
002D0:  DATA 8F,4F
002D2:  DATA 8D,4D
002D4:  DATA 4C,8C
002D6:  DATA 44,84
002D8:  DATA 85,45
002DA:  DATA 87,47
002DC:  DATA 46,86
002DE:  DATA 82,42
002E0:  DATA 43,83
002E2:  DATA 41,81
002E4:  DATA 80,40
002E6:  DATA 41,54
002E8:  DATA 2B,43
002EA:  DATA 4D,47
002EC:  DATA 46,3D
002EE:  DATA 31,00
002F0:  DATA 41,54
002F2:  DATA 2B,43
002F4:  DATA 4D,47
002F6:  DATA 53,3D
002F8:  DATA 22,00
*
00680:  DATA 41,54
00682:  DATA 2B,43
00684:  DATA 4D,47
00686:  DATA 46,3D
00688:  DATA 31,00
*
015DC:  MOVLB  7
015DE:  MOVF   xD3,W
015E0:  ANDLW  07
015E2:  MOVWF  00
015E4:  RRCF   xD3,W
015E6:  MOVWF  01
015E8:  RRCF   01,F
015EA:  RRCF   01,F
015EC:  MOVLW  1F
015EE:  ANDWF  01,F
015F0:  MOVF   01,W
015F2:  ADDWF  xD4,W
015F4:  MOVWF  FE9
015F6:  MOVLW  00
015F8:  ADDWFC xD5,W
015FA:  MOVWF  FEA
015FC:  MOVFF  FEF,01
01600:  INCF   00,F
01602:  BRA    1606
01604:  RRCF   01,F
01606:  DECFSZ 00,F
01608:  BRA    1604
0160A:  MOVLW  01
0160C:  ANDWF  01,F
0160E:  MOVLB  0
01610:  RETURN 0
01612:  MOVLB  7
01614:  MOVF   xD4,W
01616:  MULWF  xD6
01618:  MOVFF  FF3,01
0161C:  MOVFF  FF4,00
01620:  MULWF  xD7
01622:  MOVF   FF3,W
01624:  ADDWF  00,F
01626:  MOVF   xD5,W
01628:  MULWF  xD6
0162A:  MOVF   FF3,W
0162C:  ADDWFC 00,W
0162E:  MOVWF  02
01630:  MOVLB  0
01632:  RETURN 0
01634:  MOVLB  7
01636:  MOVF   xD3,W
01638:  ANDLW  07
0163A:  MOVWF  00
0163C:  RRCF   xD3,W
0163E:  MOVWF  01
01640:  RRCF   01,F
01642:  RRCF   01,F
01644:  MOVLW  1F
01646:  ANDWF  01,F
01648:  MOVF   01,W
0164A:  ADDWF  xD5,W
0164C:  MOVWF  FE9
0164E:  MOVLW  00
01650:  ADDWFC xD6,W
01652:  MOVWF  FEA
01654:  CLRF   01
01656:  INCF   01,F
01658:  INCF   00,F
0165A:  BRA    165E
0165C:  RLCF   01,F
0165E:  DECFSZ 00,F
01660:  BRA    165C
01662:  MOVF   xD4,F
01664:  BZ    166C
01666:  MOVF   01,W
01668:  IORWF  FEF,F
0166A:  BRA    1672
0166C:  COMF   01,F
0166E:  MOVF   01,W
01670:  ANDWF  FEF,F
01672:  MOVLB  0
01674:  RETURN 0
*
01E06:  ADDWF  FE8,W
01E08:  CLRF   FF7
01E0A:  RLCF   FF7,F
01E0C:  ADDLW  21
01E0E:  MOVWF  FF6
01E10:  MOVLW  1E
01E12:  ADDWFC FF7,F
01E14:  TBLRD*-
01E16:  MOVF   FF5,W
01E18:  MOVWF  FFA
01E1A:  TBLRD*
01E1C:  MOVF   FF5,W
01E1E:  MOVWF  FF9
01E20:  DATA 80,19
01E22:  DATA 86,19
01E24:  DATA 8C,19
01E26:  DATA 92,19
01E28:  DATA 98,19
01E2A:  DATA 9E,19
01E2C:  DATA A4,19
01E2E:  DATA AA,19
01E30:  DATA B0,19
01E32:  DATA B6,19
01E34:  ADDWF  FE8,W
01E36:  CLRF   FF7
01E38:  RLCF   FF7,F
01E3A:  ADDLW  4F
01E3C:  MOVWF  FF6
01E3E:  MOVLW  1E
01E40:  ADDWFC FF7,F
01E42:  TBLRD*-
01E44:  MOVF   FF5,W
01E46:  MOVWF  FFA
01E48:  TBLRD*
01E4A:  MOVF   FF5,W
01E4C:  MOVWF  FF9
01E4E:  DATA 9C,1A
01E50:  DATA A2,1A
01E52:  DATA A8,1A
01E54:  DATA AE,1A
01E56:  DATA B4,1A
01E58:  DATA BA,1A
01E5A:  DATA C0,1A
01E5C:  DATA C6,1A
01E5E:  DATA CC,1A
01E60:  DATA D2,1A
01E62:  ADDWF  FE8,W
01E64:  CLRF   FF7
01E66:  RLCF   FF7,F
01E68:  ADDLW  7D
01E6A:  MOVWF  FF6
01E6C:  MOVLW  1E
01E6E:  ADDWFC FF7,F
01E70:  TBLRD*-
01E72:  MOVF   FF5,W
01E74:  MOVWF  FFA
01E76:  TBLRD*
01E78:  MOVF   FF5,W
01E7A:  MOVWF  FF9
01E7C:  DATA EC,1B
01E7E:  DATA F2,1B
01E80:  DATA F8,1B
01E82:  DATA FE,1B
01E84:  DATA 04,1C
01E86:  DATA 0A,1C
01E88:  DATA 10,1C
01E8A:  DATA 16,1C
01E8C:  DATA 1C,1C
01E8E:  DATA 22,1C
01E90:  ADDWF  FE8,W
01E92:  CLRF   FF7
01E94:  RLCF   FF7,F
01E96:  ADDLW  AB
01E98:  MOVWF  FF6
01E9A:  MOVLW  1E
01E9C:  ADDWFC FF7,F
01E9E:  TBLRD*-
01EA0:  MOVF   FF5,W
01EA2:  MOVWF  FFA
01EA4:  TBLRD*
01EA6:  MOVF   FF5,W
01EA8:  MOVWF  FF9
01EAA:  DATA 06,1D
01EAC:  DATA 0C,1D
01EAE:  DATA 12,1D
01EB0:  DATA 18,1D
01EB2:  DATA 1E,1D
01EB4:  DATA 24,1D
01EB6:  DATA 2A,1D
01EB8:  DATA 30,1D
01EBA:  DATA 36,1D
01EBC:  DATA 3C,1D
*
01F30:  TBLRD*+
01F32:  MOVF   FF5,F
01F34:  BZ    1F4E
01F36:  MOVFF  FF6,7CF
01F3A:  MOVFF  FF7,7D0
01F3E:  MOVFF  FF5,7D1
01F42:  RCALL  1EEA
01F44:  MOVFF  7CF,FF6
01F48:  MOVFF  7D0,FF7
01F4C:  BRA    1F30
01F4E:  RETURN 0
*
0615A:  MOVF   FEF,F
0615C:  BZ    617E
0615E:  MOVFF  FEA,7D0
06162:  MOVFF  FE9,7CF
06166:  MOVFF  FEF,7D1
0616A:  CALL   1EEA
0616E:  MOVFF  7D0,FEA
06172:  MOVFF  7CF,FE9
06176:  INCF   FE9,F
06178:  BTFSC  FD8.2
0617A:  INCF   FEA,F
0617C:  BRA    615A
0617E:  RETURN 0
*
06A18:  ADDWF  FE8,W
06A1A:  CLRF   FF7
06A1C:  RLCF   FF7,F
06A1E:  ADDLW  33
06A20:  MOVWF  FF6
06A22:  MOVLW  6A
06A24:  ADDWFC FF7,F
06A26:  TBLRD*-
06A28:  MOVF   FF5,W
06A2A:  MOVWF  FFA
06A2C:  TBLRD*
06A2E:  MOVF   FF5,W
06A30:  MOVWF  FF9
06A32:  DATA 64,67
06A34:  DATA 6A,67
06A36:  DATA 70,67
06A38:  DATA 76,67
06A3A:  DATA 7C,67
06A3C:  DATA 82,67
06A3E:  DATA 88,67
06A40:  DATA 8E,67
06A42:  DATA 94,67
06A44:  DATA 9A,67
06A46:  ADDWF  FE8,W
06A48:  CLRF   FF7
06A4A:  RLCF   FF7,F
06A4C:  ADDLW  61
06A4E:  MOVWF  FF6
06A50:  MOVLW  6A
06A52:  ADDWFC FF7,F
06A54:  TBLRD*-
06A56:  MOVF   FF5,W
06A58:  MOVWF  FFA
06A5A:  TBLRD*
06A5C:  MOVF   FF5,W
06A5E:  MOVWF  FF9
06A60:  DATA B8,67
06A62:  DATA BE,67
06A64:  DATA C4,67
06A66:  DATA CA,67
06A68:  DATA D0,67
06A6A:  DATA D6,67
06A6C:  DATA DC,67
06A6E:  DATA E2,67
06A70:  DATA E8,67
06A72:  DATA EE,67
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
*
0430C:  MOVFF  7D0,7D4
04310:  MOVFF  7CF,7D3
04314:  MOVFF  7D4,FEA
04318:  MOVLB  7
0431A:  MOVFF  7D3,FE9
0431E:  MOVF   FEF,F
04320:  BZ    432E
04322:  INCF   xD3,F
04324:  BTFSC  FD8.2
04326:  INCF   xD4,F
04328:  MOVLB  0
0432A:  BRA    4314
0432C:  MOVLB  7
....................    while(*s2 != '\0')
0432E:  MOVFF  7D2,FEA
04332:  MOVFF  7D1,FE9
04336:  MOVF   FEF,F
04338:  BZ    4360
....................    {
....................       *s = *s2;
0433A:  MOVFF  7D2,FEA
0433E:  MOVFF  7D1,FE9
04342:  MOVFF  FEF,7D7
04346:  MOVFF  7D4,FEA
0434A:  MOVFF  7D3,FE9
0434E:  MOVFF  7D7,FEF
....................       ++s;
04352:  INCF   xD3,F
04354:  BTFSC  FD8.2
04356:  INCF   xD4,F
....................       ++s2;
04358:  INCF   xD1,F
0435A:  BTFSC  FD8.2
0435C:  INCF   xD2,F
0435E:  BRA    432E
....................    }
.................... 
....................    *s = '\0';
04360:  MOVFF  7D4,FEA
04364:  MOVFF  7D3,FE9
04368:  CLRF   FEF
....................    return(s1);
0436A:  MOVFF  7CF,01
0436E:  MOVFF  7D0,02
04372:  MOVLB  0
04374:  RETURN 0
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
*
060E0:  MOVFF  7D0,FEA
060E4:  MOVLB  7
060E6:  MOVFF  7CF,FE9
060EA:  MOVFF  FEF,7D3
060EE:  MOVFF  7D2,FEA
060F2:  MOVFF  7D1,FE9
060F6:  MOVF   FEF,W
060F8:  SUBWF  xD3,W
060FA:  BNZ   612A
....................       if (*s1 == '\0')
060FC:  MOVFF  7D0,03
06100:  MOVFF  7CF,FE9
06104:  MOVFF  03,FEA
06108:  MOVF   FEF,F
0610A:  BNZ   6112
....................          return(0);
0610C:  MOVLW  00
0610E:  MOVWF  01
06110:  BRA    6154
06112:  MOVFF  7D0,03
06116:  MOVF   xCF,W
06118:  INCF   xCF,F
0611A:  BTFSC  FD8.2
0611C:  INCF   xD0,F
0611E:  INCF   xD1,F
06120:  BTFSC  FD8.2
06122:  INCF   xD2,F
06124:  MOVLB  0
06126:  BRA    60E0
06128:  MOVLB  7
....................    return((*s1 < *s2) ? -1: 1);
0612A:  MOVFF  7D0,03
0612E:  MOVFF  7CF,FE9
06132:  MOVFF  03,FEA
06136:  MOVFF  FEF,7D3
0613A:  MOVFF  7D2,03
0613E:  MOVFF  7D1,FE9
06142:  MOVFF  03,FEA
06146:  MOVF   FEF,W
06148:  SUBWF  xD3,W
0614A:  BC    6150
0614C:  MOVLW  FF
0614E:  BRA    6152
06150:  MOVLW  01
06152:  MOVWF  01
06154:  MOVLB  0
06156:  GOTO   6196 (RETURN)
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    unsigned int8 n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... #include "D:\jobESP\ESPAN-04\Firmware\SPAN-04\ESPAN04_20 - Delay - SP - SMD - PIC18F252\ESPAN-04.h"
.................... //#include <18F252.h>
.................... #include <18F26K22.h>
.................... //////////// Standard Header file for the PIC18F26K22 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F26K22
.................... 
.................... #list
.................... 
.................... //#device adc=8
.................... #FUSES WDT
.................... #FUSES WDT64                    //Watch Dog Timer uses 1:64 Postscale
.................... //#FUSES HS                     //High speed Osc (> 4mhz)(for 18F2525)
.................... #fuses INTRC_IO         //High speed Osc, high power 16MHz-25MHz(for 18F26k22)
.................... #FUSES NOPROTECT                //Code not protected from reading
.................... //#FUSES IESO                     //Internal External Switch Over mode enabled
.................... #FUSES BROWNOUT                 //Reset when brownout detected
.................... //#FUSES BORV20                   //Brownout reset at 2.0V
.................... #FUSES NOPUT                    //No Power Up Timer
.................... #FUSES NOCPD                    //No EE protection
.................... //#FUSES STVREN                   //Stack full/underflow will cause reset
.................... //#FUSES LVP                      //Low Voltage Programming on B3(PIC16) or B5(PIC18)
.................... //#FUSES NOWRT                    //Program memory not write protected
.................... //#FUSES NOWRTD                   //Data EEPROM not write protected
.................... #FUSES NOEBTR                   //Memory not protected from table reads
.................... #FUSES NOCPB                    //No Boot Block code protection
.................... #FUSES NOEBTRB                  //Boot block not protected from table reads
.................... #FUSES NOWRTC                   //configuration not registers write protected
.................... #FUSES NOWRTB                   //Boot block not write protected
.................... //#FUES FCMEN                    //Fail-safe clock monitor enabled
.................... 
.................... #FUSES NODEBUG                  //No Debug mode for ICD
.................... //#device icd = true
.................... 
.................... /* //jj
.................... #FUSES NOXINST                  //Extended set extension and Indexed Addressing mode disabled (Legacy mode)
.................... #FUSES PBADEN                   //PORTB pins are configured as analog input channels on RESET
.................... #FUSES LPT1OSC                  //Timer1 configured for low-power operation
.................... #FUSES MCLR                     //Master Clear pin enabled
.................... */
.................... #define CLOCK_SP   16000000   //Clock Speed 20MHz
.................... 
.................... //23S17 Define
.................... #define IO_MULTIPLE_DEVICES
.................... #define IO_CS_PIN PIN_A5
.................... 
.................... #use delay(clock=16000000,RESTART_WDT)
*
0068A:  MOVLW  07
0068C:  MOVWF  FEA
0068E:  MOVLW  D8
00690:  MOVWF  FE9
00692:  MOVF   FEF,W
00694:  BZ    06B8
00696:  MOVLW  05
00698:  MOVWF  01
0069A:  MOVLW  BF
0069C:  MOVWF  00
0069E:  CLRWDT
006A0:  DECFSZ 00,F
006A2:  BRA    069E
006A4:  DECFSZ 01,F
006A6:  BRA    069A
006A8:  MOVLW  2E
006AA:  MOVWF  00
006AC:  DECFSZ 00,F
006AE:  BRA    06AC
006B0:  NOP   
006B2:  CLRWDT
006B4:  DECFSZ FEF,F
006B6:  BRA    0696
006B8:  RETURN 0
.................... //#use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8)
.................... 
.................... /*
.................... #include <16F886.h>
.................... #device adc=10
.................... 
.................... #FUSES WDT                      //Watch Dog Timer
.................... #FUSES HS                       //High speed Osc (> 4mhz)
.................... #FUSES NOPUT                    //No Power Up Timer
.................... //#FUSES MCLR                     //Master Clear pin enabled
.................... #FUSES PROTECT                  //Code protected from reads
.................... //#FUSES CPD                      //Data EEPROM Code Protected
.................... #FUSES NOBROWNOUT               //No brownout reset
.................... //#FUSES IESO                     //Internal External Switch Over mode enabled
.................... //#FUSES FCMEN                    //Fail-safe clock monitor enabled
.................... //#FUSES LVP                      //Low Voltage Programming on B3(PIC16) or B5(PIC18)
.................... #FUSES NODEBUG                  //No Debug mode for ICD
.................... //#FUSES BORV21                   //Brownout reset at 2.1V
.................... //#FUSES WRT                      //Program Memory Write Protected
.................... 
.................... #use delay(clock=20000000,RESTART_WDT)
.................... #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,restart_wdt)
.................... */
.................... 
.................... 
.................... #include "D:\jobESP\ESPAN-04\Firmware\SPAN-04\ESPAN04_20 - Delay - SP - SMD - PIC18F252\23S17.c" // 16 bit I/O Expander
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... ////                        23S17.c                                      ////
.................... ////                                                                   ////
.................... ////   Library for a MicroChip MCP23S17 SPI Port Expansion Chip        ////
.................... ////                                                                   ////
.................... //// The MCP23S17 device provides 16-bit, general purpose parallel I/O ////
.................... //// expansion for SPI applications. The 16-bit I/O port functionally  ////
.................... //// consists of two 8-bit ports (PORTA and PORTB). There are two      ////
.................... //// interrupt pins, INTA and INTB, that can be associated with their  ////
.................... //// respective ports, or can be logically OR’ed together so that both ////
.................... //// pins will activate if either port causes an interrupt. The        ////
.................... //// hardware address pins are used to determine the device address.   ////                                                 ////
.................... ////                                                                   ////
.................... ////  A #use spi must be provided by the main program.                 ////
.................... ////                                                                   ////
.................... ////  -------------------------------------------------------------    ////
.................... ////  PIN LAYOUT                                                       ////
.................... ////  -------------------------------------------------------------    ////
.................... ////                                                                    ////
.................... ////        -------------------------------------------                ////
.................... ////        | 1 : GPB0          | 28: GPA7            |                ////
.................... ////        |                   |                     |                ////
.................... ////        | 2 : GPB1          | 27: GPA6            |                ////
.................... ////        |                   |                     |                ////
.................... ////        | 3 : GPB2          | 26: GPA5            |                ////
.................... ////        |                   |                     |                ////
.................... ////        | 4 : GPB3          | 25: GPA4            |                ////
.................... ////        |                   |                     |                ////
.................... ////        | 5 : GPB4          | 24: GPA3            |                ////
.................... ////        |                   |                     |                ////
.................... ////        | 6 : GPB5          | 23: GPA2            |                ////
.................... ////        |                   |                     |                ////
.................... ////        | 7 : GPB6          | 22: GPA1            |                ////
.................... ////        |                   |                     |                ////
.................... ////        | 8 : GPB7          | 21: GPA0            |                ////
.................... ////        |                   |                     |                ////
.................... ////        | 9 : Vdd           | 20: INTA            |                ////
.................... ////        |                   |                     |                ////
.................... ////        | 10: Vss           | 19: INTB            |                ////
.................... ////        |     __            |     _____           |                ////
.................... ////        | 11: CS            | 18: RESET           |                ////
.................... ////        |                   |                     |                ////
.................... ////        | 12: SCK           | 17: A2              |                ////
.................... ////        |                   |                     |                ////
.................... ////        | 13: SI            | 16: A1              |                ////
.................... ////        |                   |                     |                ////
.................... ////        | 14: SO            | 15: A0              |                ////
.................... ////        -------------------------------------------                ////
.................... ////                                                                   ////
.................... ////  -------------------------------------------------------------    ////
.................... ////  FUNCTIONS                                                        ////
.................... ////  -------------------------------------------------------------    ////
.................... ////                                                                   ////
.................... ////   void IO_INIT()                                                   ////                   
.................... ////     Initializes the 23S17 chips on the SPI bus                      ////                                                 
.................... ////                                                                   ////  
.................... ////  void IO_WRITE_REGISTER(int8 address, int8 reg, int8 data)        ////
.................... ////     Writes the value to the specified register and device          ////                                                            
.................... ////                                                                   ////  
.................... ////  int8 IO_READ_REGISTER(int8 address, int8 reg);                    ////
.................... ////     Reads the value of the specified register and device          ////                                                           
.................... ////                                                                   ////  
.................... ////  void IO_OUTPUT_A(int8 address, int8 data);                       ////
.................... ////     Outputs the value to PORTA on the specified device. Doesn't   ////
.................... ////     change the direction of the port.                             ////
.................... ////                                                                   ////      
.................... ////  void IO_OUTPUT_B(int8 address, int8 data);                       ////
.................... ////     Outputs the value to PORTB on the specified device. Doesn't   ////
.................... ////     change the direction of the port.                             ////
.................... ////                                                                   ////      
.................... ////  int8 IO_INPUT_A(int8 address)                                    ////
.................... ////     Returns the value of PORTA on the specified device. Doesn't   ////
.................... ////     change the direction of the port.                             ////
.................... ////                                                                   ////      
.................... ////  int8 IO_INPUT_B(int8 address)                                    ////
.................... ////     Returns the value of PORTB on the specified device. Doesn't   ////
.................... ////     change the direction of the port.                             ////
.................... ////                                                                   ////      
.................... ////  void IO_OUTPUT_BIT(int8 address, int8 pin, int1 state)           ////
.................... ////     Outputs the value to specified pin and device. Doesn't change ////
.................... ////      the direction of the pin.                                     ////
.................... ////                                                                   ////      
.................... ////  void IO_OUTPUT_HIGH(int8 address, int8 pin)                      ////
.................... ////     Sets the output high on the specified pin and device. Doesn't ////
.................... ////     change the direction of the pin.                              ////
.................... ////                                                                   ////      
.................... ////  void IO_OUTPUT_LOW(int8 address, int8 pin)                       ////
.................... ////     Sets the output low on the specified pin and device. Doesn't  ////
.................... ////     change the direction of the pin.                              ////
.................... ////                                                                   ////   
.................... ////  void IO_OUTPUT_FLOAT(int8 address, int8 pin)                     ////
.................... ////     Sets the pin to an input on the specified device.             ////
.................... ////                                                                   ////
.................... ////  void IO_OUTPUT_TOGGLE(int8 address, int8 pin)                    ////
.................... ////     Toggles the output on the specified pin and device. Doesn't   ////
.................... ////     change the direction of the pin.                              ////
.................... ////                                                                   ////      
.................... ////  void IO_OUTPUT_DRIVE(int8 address, int8 pin)                     ////
.................... ////     Sets the pin to an output on the specified device.            ////
.................... ////                                                                   ////      
.................... ////  int1 IO_INPUT(int8 address, int8 pin)                            ////
.................... ////     Gets the current value on the specified pin and device.       ////
.................... ////                                                                   ////      
.................... ////  int1 IO_INPUT_STATE(int8 address, int8 pin)                      ////
.................... ////     Gets the current value on the specified pin and device.       //// 
.................... ////     Doesn't change the direction of the pin.                      ////
.................... ////                                                                   ////      
.................... ////  int8 IO_GET_TRIS_A(int8 address)                                 ////
.................... ////     Gets the data direction register for PORTA on the specified   //// 
.................... ////      device.                                                       ////
.................... ////                                                                   ////      
.................... ////  void IO_SET_TRIS_A(int8 address, int8 data)                      ////
.................... ////     Sets the data direction register for PORTA on the specified   //// 
.................... ////      device.                                                       ////
.................... ////                                                                   ////      
.................... ////  int8 IO_GET_TRIS_B(int8 address)                                 ////
.................... ////     Gets the data direction register for PORTB on the specified   //// 
.................... ////      device.                                                       ////
.................... ////                                                                   ////      
.................... ////  void IO_SET_TRIS_B(int8 address, int8 data)                      ////
.................... ////     Sets the data direction register for PORTB on the specified   //// 
.................... ////      device.                                                       ////
.................... ////                                                                   ////                                                                    ////
.................... ////  NOTE: address is only valid if IO_MULTIPLE_DEVICES is defined    ////
.................... ////        in your main program. Use the provided #defines as         ////
.................... ////        parameters for the address, pin, and reg fields.           ////
.................... ////                                                                    ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... //// VERSION HISTORY:                                                  ////
.................... ////                                                                   ////
.................... //// Author Date        Comments                                       ////
.................... //// -----  -------     ----------------------------------             ////
.................... //// TMH    Jul-29-2009 File Created                                   ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2009 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #ifndef MCP23S17
.................... #define MCP23S17
.................... 
.................... /******************************************************************************
.................... **** DEFINES
.................... ******************************************************************************/
.................... 
.................... //This is the device address mask. Device supports up to 8 of the chips on the
.................... //same bus. If multiple devices are to be used on the same bus, define 
.................... //IO_MULTIPLE_DEVICES in your program. This will add an address field to all 
.................... //functions. If IO_MULTIPLE_DEVICE is not defined, an address of 0 will be 
.................... //assumed (i.e. ground A2, A1, A0)
.................... #define IO_DEVICE_ADDRESS_READ   0b01000001
.................... #define IO_DEVICE_ADDRESS_WRITE  0b01000000
.................... 
.................... //User must define a CS pin in main. This pin can be connected to all similar
.................... //devices on the bus.
.................... //!#ifndef IO_CS_PIN
.................... //!#error Must define a chip select pin.
.................... //!#endif
.................... 
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //// Address Defines
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //// Use these in the address field if using multiple 23S17 devices. If bit 3
.................... //// in IOCON is cleared these no longer work and only device 0 can be operated
.................... ///////////////////////////////////////////////////////////////////////////////
.................... #ifdef IO_MULTIPLE_DEVICES
.................... 
.................... #define IO_DEVICE_0   0b00000000
.................... #define IO_DEVICE_1   0b00000010
.................... #define IO_DEVICE_2   0b00000100
.................... #define IO_DEVICE_3   0b00000110
.................... #define IO_DEVICE_4   0b00001000
.................... #define IO_DEVICE_5   0b00001010
.................... #define IO_DEVICE_6   0b00001100
.................... #define IO_DEVICE_7   0b00001110
.................... 
.................... #endif
.................... 
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //// Device Register Defines
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //// Used in the reg field. If IOCON bit 7 is cleared these no longer are 
.................... //// correct, use values to right. Refer to data sheet for more information
.................... //// on their use.
.................... ///////////////////////////////////////////////////////////////////////////////
.................... #define IODIRA      0x00     //0x00   Data Direction Register for PORTA
.................... #define IPOLA     0x01     //0x02   Input Polarity Register for PORTA
.................... #define GPINTENA    0x02     //0x04     Interrupt-on-change enable Register for PORTA                        
.................... #define DEFVALA   0x03     //0x06   Default Value Register for PORTA
.................... #define INTCONA   0x04     //0x08   Interrupt-on-change control Register for PORTA                          
.................... #define IOCON      0x05     //0x0A   Configuration register for device                      
.................... #define GPPUA      0x06     //0x0C   100kOhm pullup resistor register for PORTA (sets pin to input when set)                           
.................... #define INTFA      0x07     //0x0E   Interrupt flag Register for PORTA                             
.................... #define INTCAPA   0x08     //0x10   Interrupt captured value Register for PORTA                  
.................... #define GPIOA      0x09     //0x12   General purpose I/O Register for PORTA                            
.................... #define OLATA      0x0A     //0x14   Output latch Register for PORTA
.................... 
.................... #define IODIRB    0x10     //0x01   Data Direction Register for PORTB
.................... #define IPOLB     0x11     //0x03   Input Polarity Register for PORTB
.................... #define GPINTENB    0x12     //0x05     Interrupt-on-change enable Register for PORTB
.................... #define DEFVALB   0x13     //0x07   Default Value Register for PORTB
.................... #define INTCONB   0x14     //0x09   Interrupt-on-change control Register for PORTB
.................... //#define IOCON      0x15     //0x0B   //IOCON has 2 different addresses, both write to same register                              
.................... #define GPPUB      0x16     //0x0D   100kOhm pullup resistor register for PORTB (sets pin to input when set)
.................... #define INTFB      0x17     //0x0F   Interrupt flag Register for PORTB 
.................... #define INTCAPB   0x18     //0x11   Interrupt captured value Register for PORTB
.................... #define GPIOB      0x19     //0x13   General purpose I/O Register for PORTB
.................... #define OLATB      0x1A     //0x15   Output latch Register for PORTB
.................... 
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //// Pin Defines
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //// Use in the Pin field.
.................... ///////////////////////////////////////////////////////////////////////////////
.................... 
.................... #define IO_PIN_A0      0x80
.................... #define IO_PIN_A1      0x81
.................... #define IO_PIN_A2      0x82
.................... #define IO_PIN_A3      0x83
.................... #define IO_PIN_A4      0x84
.................... #define IO_PIN_A5      0x85
.................... #define IO_PIN_A6      0x86
.................... #define IO_PIN_A7      0x87
.................... 
.................... #define IO_PIN_B0      0x00
.................... #define IO_PIN_B1      0x01
.................... #define IO_PIN_B2      0x02
.................... #define IO_PIN_B3      0x03
.................... #define IO_PIN_B4      0x04
.................... #define IO_PIN_B5      0x05
.................... #define IO_PIN_B6      0x06
.................... #define IO_PIN_B7      0x07
.................... 
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //// IOCON Bits
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //// OR wanted options together when setting the IOCON register.
.................... ///////////////////////////////////////////////////////////////////////////////
.................... 
.................... #define IO_IOCON_BANK      0x80   //Sets register addresses. Initialized to 1.                            
.................... #define IO_IOCON_MIRROR    0x40   //Internally connect interrupt PINs. 
.................... #define IO_IOCON_SEQOP     0x20   //Sets ~Sequential/Byte mode. Driver only uses byte mode.
.................... #define IO_IOCON_DISSLW    0x10    //Enables slew rate for SDA output                             
.................... #define IO_IOCON_HAEN      0x08   //Enables hardware address pins. If 0 only one device can be used.
.................... #define IO_IOCON_ODR       0x04   //Open drain/~active drive interrupt pin outputs
.................... #define IO_IOCON_INTPOL    0x02   //Sets INT output as active high/~low
.................... 
.................... /******************************************************************************
.................... **** FUNCTION PROTOTYPES
.................... ******************************************************************************/
.................... 
.................... void IO_INIT();   //don't need multiple inits because all devices are assumed 0 before HAEN is set
.................... 
.................... #ifndef IO_MULTIPLE_DEVICES
.................... void IO_WRITE_REGISTER(int8 reg, int8 data);
.................... int8 IO_READ_REGISTER(int8 reg);
.................... void IO_OUTPUT_A(int8 data);
.................... void IO_OUTPUT_B(int8 data);
.................... int8 IO_INPUT_A();
.................... int8 IO_INPUT_B();
.................... void IO_OUTPUT_BIT(int8 pin, int1 state);
.................... void IO_OUTPUT_HIGH(int8 pin);
.................... void IO_OUTPUT_LOW(int8 pin);
.................... void IO_OUTPUT_FLOAT(int8 pin);
.................... void IO_OUTPUT_TOGGLE(int8 pin);
.................... void IO_OUTPUT_DRIVE(int8 pin);
.................... int1 IO_INPUT(int8 pin);
.................... int1 IO_INPUT_STATE(int8 pin);
.................... int8 IO_GET_TRIS_A();
.................... void IO_SET_TRIS_A(int8 data);
.................... int8 IO_GET_TRIS_B();
.................... void IO_SET_TRIS_B(int8 data);
.................... #else
.................... void IO_WRITE_REGISTER(int8 address, int8 reg, int8 data);
.................... int8 IO_READ_REGISTER(int8 address, int8 reg);
.................... void IO_OUTPUT_A(int8 address, int8 data);
.................... void IO_OUTPUT_B(int8 address, int8 data);
.................... int8 IO_INPUT_A(int8 address);
.................... int8 IO_INPUT_B(int8 address);
.................... void IO_OUTPUT_BIT(int8 address, int8 pin, int1 state);
.................... void IO_OUTPUT_HIGH(int8 address, int8 pin);
.................... void IO_OUTPUT_LOW(int8 address, int8 pin);
.................... void IO_OUTPUT_FLOAT(int8 address, int8 pin);
.................... void IO_OUTPUT_TOGGLE(int8 address, int8 pin);
.................... void IO_OUTPUT_DRIVE(int8 address, int8 pin);
.................... int1 IO_INPUT(int8 address, int8 pin);
.................... int1 IO_INPUT_STATE(int8 address, int8 pin);
.................... int8 IO_GET_TRIS_A(int8 address);
.................... void IO_SET_TRIS_A(int8 address, int8 data);
.................... int8 IO_GET_TRIS_B(int8 address);
.................... void IO_SET_TRIS_B(int8 address, int8 data);
.................... #endif
.................... 
.................... /******************************************************************************
.................... **** FUNCTIONS
.................... ******************************************************************************/
.................... 
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //// IO_INIT
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //// Must be called before anything else. Enables the MCP23S17 chip to have 
.................... //// the following settings:
.................... ////      IO_IOCON_BANK    = 1    Sets addresses to align with the #defines
.................... ////      IO_IOCON_MIRROR  = 0      INT pins are not internally connected
.................... ////      IO_IOCON_SEQOP     = 1      Operating in Byte mode   
.................... ////      IO_IOCON_DISSLW  = 0      SDA output slew rate is enabled                             
.................... ////      IO_IOCON_HAEN     = x      A2, A1, A0 enabled only if IO_MULTIPLE_DEVICES is defined   
.................... ////      IO_IOCON_ODR      = 0      Interrupt will drive its level   
.................... ////      IO_IOCON_INTPOL  = 1      Interrupt is active-high
.................... ////
.................... //// If different settings are required, use an IO_WRITE_REGISTER() with IOCON
.................... //// as the reg parameter. Note: if IO_IOCON_BANK is cleared then the #defines
.................... //// for the register values are no longer valid.
.................... ///////////////////////////////////////////////////////////////////////////////
.................... void IO_INIT(){
.................... 
....................    output_high(IO_CS_PIN);
*
006EC:  BCF    F92.5
006EE:  BSF    F89.5
....................    output_drive(IO_CS_PIN);
006F0:  BCF    F92.5
....................    #ifndef IO_MULTIPLE_DEVICES
....................    IO_WRITE_REGISTER(0x0A, 0xA2);   //IOCON's address is 0xA until IOCON.Bank is set                         
....................    #else
....................    IO_WRITE_REGISTER(IO_DEVICE_0, 0x0A, 0xAA);
006F2:  MOVLB  7
006F4:  CLRF   xD9
006F6:  MOVLW  0A
006F8:  MOVWF  xDA
006FA:  MOVLW  AA
006FC:  MOVWF  xDB
006FE:  MOVLB  0
00700:  RCALL  06BA
....................    IO_WRITE_REGISTER(IO_DEVICE_1, 0x0A, 0xAA);  //Edit by Jack
00702:  MOVLW  02
00704:  MOVLB  7
00706:  MOVWF  xD9
00708:  MOVLW  0A
0070A:  MOVWF  xDA
0070C:  MOVLW  AA
0070E:  MOVWF  xDB
00710:  MOVLB  0
00712:  RCALL  06BA
....................    IO_WRITE_REGISTER(IO_DEVICE_2, 0x0A, 0xAA);  //Edit by Jack
00714:  MOVLW  04
00716:  MOVLB  7
00718:  MOVWF  xD9
0071A:  MOVLW  0A
0071C:  MOVWF  xDA
0071E:  MOVLW  AA
00720:  MOVWF  xDB
00722:  MOVLB  0
00724:  RCALL  06BA
....................    IO_WRITE_REGISTER(IO_DEVICE_3, 0x0A, 0xAA);  //Edit by Jack
00726:  MOVLW  06
00728:  MOVLB  7
0072A:  MOVWF  xD9
0072C:  MOVLW  0A
0072E:  MOVWF  xDA
00730:  MOVLW  AA
00732:  MOVWF  xDB
00734:  MOVLB  0
00736:  RCALL  06BA
....................    IO_WRITE_REGISTER(IO_DEVICE_4, 0x0A, 0xAA);  //Edit by Jack
00738:  MOVLW  08
0073A:  MOVLB  7
0073C:  MOVWF  xD9
0073E:  MOVLW  0A
00740:  MOVWF  xDA
00742:  MOVLW  AA
00744:  MOVWF  xDB
00746:  MOVLB  0
00748:  RCALL  06BA
....................    IO_WRITE_REGISTER(IO_DEVICE_5, 0x0A, 0xAA);  //Edit by Jack
0074A:  MOVLW  0A
0074C:  MOVLB  7
0074E:  MOVWF  xD9
00750:  MOVWF  xDA
00752:  MOVLW  AA
00754:  MOVWF  xDB
00756:  MOVLB  0
00758:  RCALL  06BA
....................    IO_WRITE_REGISTER(IO_DEVICE_6, 0x0A, 0xAA);  //Edit by Jack
0075A:  MOVLW  0C
0075C:  MOVLB  7
0075E:  MOVWF  xD9
00760:  MOVLW  0A
00762:  MOVWF  xDA
00764:  MOVLW  AA
00766:  MOVWF  xDB
00768:  MOVLB  0
0076A:  RCALL  06BA
....................    IO_WRITE_REGISTER(IO_DEVICE_7, 0x0A, 0xAA);  //Edit by Jack
0076C:  MOVLW  0E
0076E:  MOVLB  7
00770:  MOVWF  xD9
00772:  MOVLW  0A
00774:  MOVWF  xDA
00776:  MOVLW  AA
00778:  MOVWF  xDB
0077A:  MOVLB  0
0077C:  RCALL  06BA
....................    #endif
0077E:  GOTO   633E (RETURN)
.................... }
.................... 
.................... 
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //// IO_WRITE_REGISTER
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //// Sets the value of the specified register.
.................... ////
.................... //// Parameters:
.................... ////      reg - the register to be written. use provided defines.
.................... ////      data - the data to be written.
.................... ////     address - address of the device. use provided defines.
.................... ////
.................... //// Returns:
.................... ////      void
.................... ///////////////////////////////////////////////////////////////////////////////
.................... #ifndef IO_MULTIPLE_DEVICES
.................... void IO_WRITE_REGISTER(int8 reg, int8 data){
.................... #else
.................... void IO_WRITE_REGISTER(int8 address, int8 reg, int8 data){
.................... #endif
....................    
....................    output_low(IO_CS_PIN);
*
006BA:  BCF    F92.5
006BC:  BCF    F89.5
....................    
....................    #ifndef IO_MULTIPLE_DEVICES
....................    spi_write(IO_DEVICE_ADDRESS_WRITE);
....................    #else
....................    spi_write(IO_DEVICE_ADDRESS_WRITE | address);
006BE:  MOVLB  7
006C0:  MOVF   xD9,W
006C2:  IORLW  40
006C4:  MOVWF  xDC
006C6:  MOVF   FC9,W
006C8:  MOVFF  7DC,FC9
006CC:  RRCF   FC7,W
006CE:  BNC   06CC
....................    #endif
....................    
....................    spi_write(reg);
006D0:  MOVF   FC9,W
006D2:  MOVFF  7DA,FC9
006D6:  RRCF   FC7,W
006D8:  BNC   06D6
....................    spi_write(data);
006DA:  MOVF   FC9,W
006DC:  MOVFF  7DB,FC9
006E0:  RRCF   FC7,W
006E2:  BNC   06E0
....................    
....................    output_high(IO_CS_PIN);
006E4:  BCF    F92.5
006E6:  BSF    F89.5
006E8:  MOVLB  0
006EA:  RETURN 0
.................... 
.................... }
.................... 
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //// IO_READ_REGISTER
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //// Gets the current value of the specified register.
.................... ////
.................... //// Parameters:
.................... ////      reg - the register to be read. use provided defines.
.................... ////     address - address of the device. use provided defines.
.................... ////
.................... //// Returns:
.................... ////      int8 - the current value of the requested register
.................... ///////////////////////////////////////////////////////////////////////////////
.................... #ifndef IO_MULTIPLE_DEVICES
.................... int8 IO_READ_REGISTER(int8 reg){
.................... #else
.................... int8 IO_READ_REGISTER(int8 address, int8 reg){
.................... #endif
....................    int8 retVal;
.................... 
....................    output_low(IO_CS_PIN);
*
0156C:  BCF    F92.5
0156E:  BCF    F89.5
....................    
....................    #ifndef IO_MULTIPLE_DEVICES
....................    spi_write(IO_DEVICE_ADDRESS_READ);
....................    #else
....................    spi_write(IO_DEVICE_ADDRESS_READ | address);
01570:  MOVLB  7
01572:  MOVF   xD2,W
01574:  IORLW  41
01576:  MOVWF  xD5
01578:  MOVF   FC9,W
0157A:  MOVFF  7D5,FC9
0157E:  RRCF   FC7,W
01580:  BNC   157E
....................    #endif
....................    
....................    spi_write(reg);
01582:  MOVF   FC9,W
01584:  MOVFF  7D3,FC9
01588:  RRCF   FC7,W
0158A:  BNC   1588
....................    retVal = spi_read(0);
0158C:  MOVF   FC9,W
0158E:  CLRF   FC9
01590:  RRCF   FC7,W
01592:  BNC   1590
01594:  MOVFF  FC9,7D4
....................    
....................    output_high(IO_CS_PIN);
01598:  BCF    F92.5
0159A:  BSF    F89.5
....................    
....................    return retVal;
0159C:  MOVFF  7D4,01
015A0:  MOVLB  0
015A2:  RETURN 0
.................... 
.................... }
.................... 
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //// IO_OUTPUT_A
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //// Sets the current output value of Port A. Does NOT change the PORT's 
.................... //// direction
.................... ////
.................... //// Parameters:
.................... ////      data - the value to be written to Port A
.................... ////     address - address of the device. use provided defines.
.................... ////
.................... //// Returns:
.................... ////      void
.................... ///////////////////////////////////////////////////////////////////////////////
.................... #ifndef IO_MULTIPLE_DEVICES
.................... void IO_OUTPUT_A(int8 data){
.................... #else
.................... void IO_OUTPUT_A(int8 address, int8 data){
.................... #endif
.................... 
....................    #ifndef IO_MULTIPLE_DEVICES
....................    IO_WRITE_REGISTER(OLATA, data);
....................    #else
....................    IO_WRITE_REGISTER(address, OLATA, data);
*
01EBE:  MOVFF  7D7,7D9
01EC2:  MOVLW  0A
01EC4:  MOVLB  7
01EC6:  MOVWF  xDA
01EC8:  MOVFF  7D8,7DB
01ECC:  MOVLB  0
01ECE:  CALL   06BA
....................    #endif
01ED2:  RETURN 0
.................... 
.................... }
.................... 
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //// IO_OUTPUT_B
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //// Sets the current output value of Port B. Does NOT change the PORT's 
.................... //// direction
.................... ////
.................... //// Parameters:
.................... ////      data - the value to be written to Port B
.................... ////     address - address of the device. use provided defines.
.................... ////
.................... //// Returns:
.................... ////      void
.................... ///////////////////////////////////////////////////////////////////////////////
.................... #ifndef IO_MULTIPLE_DEVICES
.................... void IO_OUTPUT_B(int8 data){
.................... #else
.................... void IO_OUTPUT_B(int8 address, int8 data){
.................... #endif
.................... 
....................    #ifndef IO_MULTIPLE_DEVICES
....................    IO_WRITE_REGISTER(OLATB, data);
....................    #else
....................    IO_WRITE_REGISTER(address, OLATB, data);
01ED4:  MOVFF  7D7,7D9
01ED8:  MOVLW  1A
01EDA:  MOVLB  7
01EDC:  MOVWF  xDA
01EDE:  MOVFF  7D8,7DB
01EE2:  MOVLB  0
01EE4:  CALL   06BA
....................    #endif
01EE8:  RETURN 0
.................... 
.................... }
.................... 
.................... 
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //// IO_INPUT_A
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //// Gets the current input value of Port A. Does NOT change the PORT's 
.................... //// direction
.................... ////
.................... //// Parameters:
.................... ////     address - address of the device. use provided defines.
.................... ////
.................... //// Returns:
.................... ////      int8 - PORTA's input value
.................... ///////////////////////////////////////////////////////////////////////////////
.................... #ifndef IO_MULTIPLE_DEVICES
.................... int8 IO_INPUT_A(){
.................... #else
.................... int8 IO_INPUT_A(int8 address){
.................... #endif
.................... 
....................    int8 retVal;
....................    
....................    #ifndef IO_MULTIPLE_DEVICES
....................    retVal = IO_READ_REGISTER(GPIOA);
....................    #else
....................    retVal = IO_READ_REGISTER(address, GPIOA);
*
015A4:  MOVFF  7D0,7D2
015A8:  MOVLW  09
015AA:  MOVLB  7
015AC:  MOVWF  xD3
015AE:  MOVLB  0
015B0:  RCALL  156C
015B2:  MOVFF  01,7D1
....................    #endif
....................    
....................    return retVal;
015B6:  MOVLB  7
015B8:  MOVFF  7D1,01
015BC:  MOVLB  0
015BE:  RETURN 0
.................... 
.................... }
.................... 
.................... 
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //// IO_INPUT_B
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //// Gets the current input value of Port B. Does NOT change the PORT's 
.................... //// direction
.................... ////
.................... //// Parameters:
.................... ////     address - address of the device. use provided defines.
.................... ////
.................... //// Returns:
.................... ////      int8 - PORTB's input value
.................... ///////////////////////////////////////////////////////////////////////////////
.................... #ifndef IO_MULTIPLE_DEVICES
.................... int8 IO_INPUT_B(){
.................... #else
.................... int8 IO_INPUT_B(int8 address){
.................... #endif
.................... 
....................    int8 retVal;
....................    
....................    #ifndef IO_MULTIPLE_DEVICES
....................    retVal = IO_READ_REGISTER(GPIOB);
....................    #else
....................    retVal = IO_READ_REGISTER(address, GPIOB);
015C0:  MOVFF  7D0,7D2
015C4:  MOVLW  19
015C6:  MOVLB  7
015C8:  MOVWF  xD3
015CA:  MOVLB  0
015CC:  RCALL  156C
015CE:  MOVFF  01,7D1
....................    #endif
....................    
....................    return retVal;
015D2:  MOVLB  7
015D4:  MOVFF  7D1,01
015D8:  MOVLB  0
015DA:  RETURN 0
.................... 
.................... }
.................... 
.................... 
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //// IO_OUTPUT_BIT
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //// Sets the specified PIN to the desired state. Does NOT change the PIN's 
.................... //// direction
.................... ////
.................... //// Parameters:
.................... ////      pin - pin to be changed. use provided defines.
.................... ////     address - address of the device. use provided defines.
.................... ////
.................... //// Returns:
.................... ////      void
.................... ///////////////////////////////////////////////////////////////////////////////
.................... #ifndef IO_MULTIPLE_DEVICES
.................... void IO_OUTPUT_BIT(int8 pin, int1 state){
.................... #else
.................... void IO_OUTPUT_BIT(int8 address, int8 pin, int1 state){
.................... #endif
....................    
....................    int8 tempReg;
....................    
....................    if(bit_test(pin, 7)){ //PIN A
....................       #ifndef IO_MULTIPLE_DEVICES
....................       tempReg = IO_READ_REGISTER(OLATA);
....................       #else
....................       tempReg = IO_READ_REGISTER(address, OLATA);
....................       #endif
....................       if(state){    //set high                      
....................          bit_set(tempReg, pin &0x0F);     
....................       }else{        //set low                      
....................          bit_clear(tempReg, pin &0x0F);
....................       }
....................       #ifndef IO_MULTIPLE_DEVICES
....................       IO_WRITE_REGISTER(OLATA, tempReg);
....................       #else
....................       IO_WRITE_REGISTER(address, OLATA, tempReg);
....................       #endif
....................    }else{    //PIN B   
....................       #ifndef IO_MULTIPLE_DEVICES
....................       tempReg = IO_READ_REGISTER(OLATB);
....................       #else
....................       tempReg = IO_READ_REGISTER(address, OLATB);
....................       #endif
....................       if(state){    //set high                      
....................          bit_set(tempReg, pin);      
....................       }else{        //set low                      
....................          bit_clear(tempReg, pin);
....................       }
....................       #ifndef IO_MULTIPLE_DEVICES
....................       IO_WRITE_REGISTER(OLATB, tempReg);
....................       #else
....................       IO_WRITE_REGISTER(address, OLATB, tempReg);
....................       #endif
....................    }
.................... 
.................... }
.................... 
.................... 
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //// IO_OUTPUT_HIGH
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //// Sets the specified PIN to output high. Does NOT change the PIN's direction
.................... ////
.................... //// Parameters:
.................... ////      pin - pin to be set. use provided defines.
.................... ////     address - address of the device. use provided defines.
.................... ////
.................... //// Returns:
.................... ////      void
.................... ///////////////////////////////////////////////////////////////////////////////
.................... #ifndef IO_MULTIPLE_DEVICES
.................... void IO_OUTPUT_HIGH(int8 pin){
.................... #else
.................... void IO_OUTPUT_HIGH(int8 address, int8 pin){
.................... #endif
.................... 
....................    int8 tempReg;
....................    
....................    if(bit_test(pin, 7)){ //PIN A
....................       #ifndef IO_MULTIPLE_DEVICES
....................       tempReg = IO_READ_REGISTER(OLATA);
....................       #else
....................       tempReg = IO_READ_REGISTER(address, OLATA);
....................       #endif
....................       bit_set(tempReg, pin &0x0F); 
....................       #ifndef IO_MULTIPLE_DEVICES
....................       IO_WRITE_REGISTER(OLATA, tempReg);
....................       #else
....................       IO_WRITE_REGISTER(address, OLATA, tempReg);
....................       #endif
....................    }else{    //PIN B   
....................       #ifndef IO_MULTIPLE_DEVICES
....................       tempReg = IO_READ_REGISTER(OLATB);
....................       #else
....................       tempReg = IO_READ_REGISTER(address, OLATB);
....................       #endif
....................       bit_set(tempReg, pin); 
....................       #ifndef IO_MULTIPLE_DEVICES
....................       IO_WRITE_REGISTER(OLATB, tempReg);
....................       #else
....................       IO_WRITE_REGISTER(address, OLATB, tempReg);
....................       #endif
....................    }
.................... 
.................... }
.................... 
.................... 
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //// IO_OUTPUT_LOW
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //// Sets the specified PIN to output low. Does NOT change the PIN's direction
.................... ////
.................... //// Parameters:
.................... ////      pin - pin to be cleared. use provided defines.
.................... ////     address - address of the device. use provided defines.
.................... ////
.................... //// Returns:
.................... ////      void
.................... ///////////////////////////////////////////////////////////////////////////////
.................... #ifndef IO_MULTIPLE_DEVICES
.................... void IO_OUTPUT_LOW(int8 pin){
.................... #else
.................... void IO_OUTPUT_LOW(int8 address, int8 pin){
.................... #endif
.................... 
....................    int8 tempReg;
....................    
....................    if(bit_test(pin, 7)){ //PIN A
....................       #ifndef IO_MULTIPLE_DEVICES
....................       tempReg = IO_READ_REGISTER(OLATA);
....................       #else
....................       tempReg = IO_READ_REGISTER(address, OLATA);
....................       #endif
....................       bit_clear(tempReg, pin &0x0F);
....................       #ifndef IO_MULTIPLE_DEVICES
....................       IO_WRITE_REGISTER(OLATA, tempReg);
....................       #else
....................       IO_WRITE_REGISTER(address, OLATA, tempReg);
....................       #endif
....................    }else{    //PIN B   
....................       #ifndef IO_MULTIPLE_DEVICES
....................       tempReg = IO_READ_REGISTER(OLATB);
....................       #else
....................       tempReg = IO_READ_REGISTER(address, OLATB);
....................       #endif
....................       bit_clear(tempReg, pin);
....................       #ifndef IO_MULTIPLE_DEVICES
....................       IO_WRITE_REGISTER(OLATB, tempReg);
....................       #else
....................       IO_WRITE_REGISTER(address, OLATB, tempReg);
....................       #endif
....................    }
.................... 
.................... }
.................... 
.................... 
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //// IO_OUTPUT_FLOAT
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //// Sets the specified PIN to an input.
.................... ////
.................... //// Parameters:
.................... ////      pin - pin to be changed. use provided defines.
.................... ////     address - address of the device. use provided defines.
.................... ////
.................... //// Returns:
.................... ////      void
.................... ///////////////////////////////////////////////////////////////////////////////
.................... #ifndef IO_MULTIPLE_DEVICES
.................... void IO_OUTPUT_FLOAT(int8 pin){
.................... #else
.................... void IO_OUTPUT_FLOAT(int8 address, int8 pin){
.................... #endif
.................... 
....................    int8 tempReg;
....................    
....................    if(bit_test(pin, 7)){ //PIN A
....................       #ifndef IO_MULTIPLE_DEVICES
....................       tempReg = IO_GET_TRIS_A();
....................       #else
....................       tempReg = IO_GET_TRIS_A(address);
....................       #endif
....................       bit_set(tempReg, pin &0x0F); 
....................       #ifndef IO_MULTIPLE_DEVICES
....................       IO_SET_TRIS_A(tempReg);
....................       #else
....................       IO_SET_TRIS_A(address, tempReg);
....................       #endif
....................    }else{    //PIN B   
....................       #ifndef IO_MULTIPLE_DEVICES
....................       tempReg = IO_GET_TRIS_B();
....................       #else
....................       tempReg = IO_GET_TRIS_B(address);
....................       #endif
....................       bit_set(tempReg, pin);      
....................       #ifndef IO_MULTIPLE_DEVICES
....................       IO_SET_TRIS_B(tempReg);
....................       #else
....................       IO_SET_TRIS_B(address, tempReg);
....................       #endif
....................    }
.................... 
.................... }
.................... 
.................... 
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //// IO_OUTPUT_TOGGLE
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //// Toggles the specified PIN's output.
.................... ////
.................... //// Parameters:
.................... ////      pin - pin to be toggled. use provided defines.
.................... ////     address - address of the device. use provided defines.
.................... ////
.................... //// Returns:
.................... ////      void
.................... ///////////////////////////////////////////////////////////////////////////////
.................... #ifndef IO_MULTIPLE_DEVICES
.................... void IO_OUTPUT_TOGGLE(int8 pin){
.................... #else
.................... void IO_OUTPUT_TOGGLE(int8 address, int8 pin){
.................... #endif
.................... 
....................    int8 tempReg;
....................    
....................    if(bit_test(pin, 7)){ //PIN A
....................       #ifndef IO_MULTIPLE_DEVICES
....................       tempReg = IO_READ_REGISTER(OLATA);
....................       #else
....................       tempReg = IO_READ_REGISTER(address, OLATA);
....................       #endif
....................       tempReg ^= (1<< (pin&0x0F));
....................       #ifndef IO_MULTIPLE_DEVICES
....................       IO_WRITE_REGISTER(OLATA, tempReg);
....................       #else
....................       IO_WRITE_REGISTER(address, OLATA, tempReg);
....................       #endif
....................    }else{    //PIN B   
....................       #ifndef IO_MULTIPLE_DEVICES
....................       tempReg = IO_READ_REGISTER(OLATB);
....................       #else
....................       tempReg = IO_READ_REGISTER(address, OLATB);
....................       #endif
....................       tempReg ^= (1<< (pin&0x0F));
....................       #ifndef IO_MULTIPLE_DEVICES
....................       IO_WRITE_REGISTER(OLATB, tempReg);
....................       #else
....................       IO_WRITE_REGISTER(address, OLATB, tempReg);
....................       #endif
....................    }
.................... 
.................... }
.................... 
.................... 
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //// IO_OUTPUT_DRIVE
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //// Sets the specified PIN to an output.
.................... ////
.................... //// Parameters:
.................... ////      pin - pin to be changed. use provided defines.
.................... ////     address - address of the device. use provided defines.
.................... ////
.................... //// Returns:
.................... ////      void
.................... ///////////////////////////////////////////////////////////////////////////////
.................... #ifndef IO_MULTIPLE_DEVICES
.................... void IO_OUTPUT_DRIVE(int8 pin){
.................... #else
.................... void IO_OUTPUT_DRIVE(int8 address, int8 pin){
.................... #endif
.................... 
....................    int8 tempReg;
....................    
....................    if(bit_test(pin, 7)){ //PIN A
....................       #ifndef IO_MULTIPLE_DEVICES
....................       tempReg = IO_GET_TRIS_A();
....................       #else
....................       tempReg = IO_GET_TRIS_A(address);
....................       #endif
....................       bit_clear(tempReg, pin &0x0F);
....................       #ifndef IO_MULTIPLE_DEVICES
....................       IO_SET_TRIS_A(tempReg);
....................       #else
....................       IO_SET_TRIS_A(address, tempReg);
....................       #endif
....................    }else{    //PIN B   
....................       #ifndef IO_MULTIPLE_DEVICES
....................       tempReg = IO_GET_TRIS_B();
....................       #else
....................       tempReg = IO_GET_TRIS_B(address);
....................       #endif
....................       bit_clear(tempReg, pin);      
....................       #ifndef IO_MULTIPLE_DEVICES
....................       IO_SET_TRIS_B(tempReg);
....................       #else
....................       IO_SET_TRIS_B(address, tempReg);
....................       #endif
....................    }
.................... 
.................... }
.................... 
.................... 
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //// IO_INPUT
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //// Gets the specified PIN's current input. Changes the PIN's direction to an
.................... //// input.
.................... ////
.................... //// Parameters:
.................... ////      pin - pin to be read. use provided defines.
.................... ////     address - address of the device. use provided defines.
.................... ////
.................... //// Returns:
.................... ////      int1 - the state of the pin
.................... ///////////////////////////////////////////////////////////////////////////////
.................... #ifndef IO_MULTIPLE_DEVICES
.................... int1 IO_INPUT(int8 pin){
.................... #else
.................... int1 IO_INPUT(int8 address, int8 pin){
.................... #endif
....................    int1 retVal;
....................    int8 tempReg;
....................    
....................    #ifndef IO_MULTIPLE_DEVICES
....................    IO_OUTPUT_FLOAT(pin);
....................    #else
....................    IO_OUTPUT_FLOAT(address, pin);
....................    #endif
....................    
....................    if(bit_test(pin, 7)){
....................       #ifndef IO_MULTIPLE_DEVICES
....................       tempReg = IO_READ_REGISTER(GPIOA);
....................       #else
....................       tempReg = IO_READ_REGISTER(address, GPIOA);
....................       #endif
....................    }else{
....................       #ifndef IO_MULTIPLE_DEVICES
....................       tempReg = IO_READ_REGISTER(GPIOB);
....................       #else
....................       tempReg = IO_READ_REGISTER(address, GPIOB);
....................       #endif
....................    }
....................    retVal = bit_test(tempReg, pin&0x0F);
....................    
....................    return retVal;
.................... 
.................... }
.................... 
.................... 
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //// IO_INPUT_STATE
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //// Gets the specified PIN's current input. Does NOT change the PIN's direction
.................... ////
.................... //// Parameters:
.................... ////      pin - pin to be read. use provided defines.
.................... ////     address - address of the device. use provided defines.
.................... ////
.................... //// Returns:
.................... ////      int1 - the state of the pin
.................... ///////////////////////////////////////////////////////////////////////////////
.................... #ifndef IO_MULTIPLE_DEVICES
.................... int1 IO_INPUT_STATE(int8 pin){
.................... #else
.................... int1 IO_INPUT_STATE(int8 address, int8 pin){
.................... #endif
....................    int1 retVal;
....................    int8 tempReg;
....................    
....................    if(bit_test(pin, 7)){
....................       #ifndef IO_MULTIPLE_DEVICES
....................       tempReg = IO_READ_REGISTER(GPIOA);
....................       #else
....................       tempReg = IO_READ_REGISTER(address, GPIOA);
....................       #endif
....................    }else{
....................       #ifndef IO_MULTIPLE_DEVICES
....................       tempReg = IO_READ_REGISTER(GPIOB);
....................       #else
....................       tempReg = IO_READ_REGISTER(address, GPIOB);
....................       #endif
....................    }
....................    retVal = bit_test(tempReg, pin&0x0F);
....................    
....................    return retVal;
.................... 
.................... }
.................... 
.................... 
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //// IO_GET_TRIS_A
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //// Gets the device's port A data direction register.
.................... ////
.................... //// Parameters:
.................... ////     address - address of the device. use provided defines.
.................... ////
.................... //// Returns:
.................... ////      The device's IODIRB register value
.................... ///////////////////////////////////////////////////////////////////////////////
.................... #ifndef IO_MULTIPLE_DEVICES
.................... int8 IO_GET_TRIS_A(){
.................... #else
.................... int8 IO_GET_TRIS_A(int8 address){
.................... #endif
.................... 
....................    int8 retVal;
....................    
....................    #ifndef IO_MULTIPLE_DEVICES
....................    retVal = IO_READ_REGISTER(IODIRA);
....................    #else
....................    retVal = IO_READ_REGISTER(address, IODIRA);
....................    #endif
....................    
....................    return retVal;
.................... 
.................... }
.................... 
.................... 
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //// IO_SET_TRIS_A
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //// Sets the device's port A data direction register to the specified value.
.................... ////
.................... //// Parameters:
.................... ////      data - value to be written to the register
.................... ////     address - address of the device. use provided defines.
.................... ////
.................... //// Returns:
.................... ////      void
.................... ///////////////////////////////////////////////////////////////////////////////
.................... #ifndef IO_MULTIPLE_DEVICES
.................... void IO_SET_TRIS_A(int8 data){
.................... #else
.................... void IO_SET_TRIS_A(int8 address, int8 data){
.................... #endif
....................    
....................    #ifndef IO_MULTIPLE_DEVICES
....................    IO_WRITE_REGISTER(IODIRA, data);
....................    #else
....................    IO_WRITE_REGISTER(address, IODIRA, data);
*
00782:  MOVFF  7CF,7D9
00786:  MOVLB  7
00788:  CLRF   xDA
0078A:  MOVFF  7D0,7DB
0078E:  MOVLB  0
00790:  RCALL  06BA
....................    #endif
00792:  RETURN 0
.................... 
.................... }
.................... 
.................... 
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //// IO_GET_TRIS_B
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //// Gets the device's port B data direction register.
.................... ////
.................... //// Parameters:
.................... ////     address - address of the device. use provided defines.
.................... ////
.................... //// Returns:
.................... ////      The device's IODIRB register value
.................... ///////////////////////////////////////////////////////////////////////////////
.................... #ifndef IO_MULTIPLE_DEVICES
.................... int8 IO_GET_TRIS_B(){
.................... #else
.................... int8 IO_GET_TRIS_B(int8 address){
.................... #endif
.................... 
....................    int8 retVal;
....................    
....................    #ifndef IO_MULTIPLE_DEVICES
....................    retVal = IO_READ_REGISTER(IODIRB);
....................    #else
....................    retVal = IO_READ_REGISTER(address, IODIRB);
....................    #endif
....................    
....................    return retVal;
.................... 
.................... }
.................... 
.................... 
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //// IO_SET_TRIS_B
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //// Sets the device's port B data direction register to the specified value.
.................... ////
.................... //// Parameters:
.................... ////      data - value to be written to the register
.................... ////     address - address of the device. use provided defines.
.................... ////
.................... //// Returns:
.................... ////      void
.................... ///////////////////////////////////////////////////////////////////////////////
.................... #ifndef IO_MULTIPLE_DEVICES
.................... void IO_SET_TRIS_B(int8 data){
.................... #else
.................... void IO_SET_TRIS_B(int8 address, int8 data){
.................... #endif
.................... 
....................    #ifndef IO_MULTIPLE_DEVICES
....................    IO_WRITE_REGISTER(IODIRB, data);
....................    #else
....................    IO_WRITE_REGISTER(address, IODIRB, data);
00794:  MOVFF  7CF,7D9
00798:  MOVLW  10
0079A:  MOVLB  7
0079C:  MOVWF  xDA
0079E:  MOVFF  7D0,7DB
007A2:  MOVLB  0
007A4:  RCALL  06BA
....................    #endif
007A6:  RETURN 0
.................... 
.................... }
.................... 
.................... #endif
.................... 
.................... 
.................... #define Pled        PIN_B5
.................... #define I2C_SDA     PIN_C4
.................... #define I2C_SCL     PIN_C3
.................... 
.................... #define Pack        PIN_C0
.................... #define Preset      PIN_C1
.................... #define Ptest       PIN_C2
.................... 
.................... #define Pbell       PIN_A3
.................... #define Pbuzzer     PIN_A4
.................... 
.................... #define P485ctrl    PIN_B3       // ---jj
.................... #define PTxD        PIN_C6
.................... #define PRxD        PIN_C7
.................... 
.................... //#define PsyncR      PIN_B3
.................... //#define PsyncS      PIN_B4
.................... 
.................... #define EXP_OUT_ENABLE  PIN_B0
.................... #define EXP_OUT_CLOCK   PIN_B1
.................... #define EXP_OUT_DO      PIN_B2
.................... 
.................... #define Red       0
.................... #define Green     1
.................... #define Ambian    2
.................... 
.................... //#define NUMBER_OF_595 8
.................... 
.................... //#use rs232(baud=9600,parity=N,xmit=PTxD,rcv=PRxD,bits=8,restart_wdt)
.................... /* Config and Enable Hardware UART1(RC6=TX1,RC7=RX1 */
.................... #use rs232(uart1, baud=9600, stream=CH1)
*
01FA6:  BTFSS  F9E.4
01FA8:  BRA    1FA6
01FAA:  MOVWF  FAD
01FAC:  RETURN 0
.................... 
.................... /* Config and Enable Software UART2(RC0=TX2,RC1=RX2 */
.................... 
.................... #define TX2 PIN_B0                                                            // RC0 = TXD
.................... #define RX2 PIN_B1                                                            // RC1 = RXD
.................... #use rs232(baud=9600, xmit=TX2, rcv=RX2,stream=CH2)
*
01EEA:  BCF    F93.0
01EEC:  BCF    F8A.0
01EEE:  MOVLW  08
01EF0:  MOVWF  01
01EF2:  BRA    1EF4
01EF4:  NOP   
01EF6:  BSF    01.7
01EF8:  BRA    1F1A
01EFA:  BCF    01.7
01EFC:  MOVLB  7
01EFE:  RRCF   xD1,F
01F00:  MOVLB  0
01F02:  BTFSC  FD8.0
01F04:  BSF    F8A.0
01F06:  BTFSS  FD8.0
01F08:  BCF    F8A.0
01F0A:  BSF    01.6
01F0C:  BRA    1F1A
01F0E:  BCF    01.6
01F10:  DECFSZ 01,F
01F12:  BRA    1EFC
01F14:  BRA    1F16
01F16:  NOP   
01F18:  BSF    F8A.0
01F1A:  MOVLW  84
01F1C:  MOVWF  FE9
01F1E:  DECFSZ FE9,F
01F20:  BRA    1F1E
01F22:  BRA    1F24
01F24:  NOP   
01F26:  BTFSC  01.7
01F28:  BRA    1EFA
01F2A:  BTFSC  01.6
01F2C:  BRA    1F0E
01F2E:  RETURN 0
.................... 
.................... 
.................... //#USE SPI (  FORCE_HW, BITS=16, ENABLE=IO_CS_PIN, SAMPLE_RISE, stream=SPI_STREAM) 
.................... //#USE SPI (  FORCE_HW, BITS=16, ENABLE=IO_CS_PIN, SAMPLE_RISE, stream=SPI_STREAM2)
.................... 
.................... //#use spi(MASTER, MODE=0, SPI1, FORCE_HW)
.................... //#use spi(MASTER, MSB_FIRST, BITS=8, MODE=0, BAUD=100000)
.................... //#use spi(DI=PIN_B1, DO=PIN_B0, CLK=PIN_B2, ENABLE=PIN_B4, BITS=8)
.................... 
.................... void check_ack(void);
.................... void check_test(void);
.................... void check_reset(void);
.................... int1 CheckAutoReset(unsigned char DatType);
.................... void Read_Config(void);
.................... void ForceAllAlarm(void);
.................... void Read_input(void);
.................... 
.................... int8 StatusTime = 0;         //Hearth beat LED Timer
.................... int1 HearthbeatInd = 0;      //Hearth beat Indicator
.................... int8 FlashingRateTime = 25;
.................... int1 FlashingFlag = 0;
.................... int8 TimeBase1s = 100;
.................... int8 AutoAckDelayTime = 0;
.................... 
.................... int8 Input1_8_Send;
.................... int8 Input9_16_Send;
.................... int8 Input17_24_Send;
.................... int8 Input25_32_Send;
.................... int8 Input33_40_Send;
.................... int8 Input41_48_Send;
.................... int8 Input49_56_Send;
.................... int8 Input57_64_Send;
.................... 
.................... int8 Ack1_8_Send;
.................... int8 Ack9_16_Send;
.................... int8 Ack17_24_Send;
.................... int8 Ack25_32_Send;
.................... int8 Ack33_40_Send;
.................... int8 Ack41_48_Send;
.................... int8 Ack49_56_Send;
.................... int8 Ack57_64_Send;
.................... 
.................... int1 AutoAckFlag = 0;
.................... int1 AutoResetFlag = 0;
.................... int1 AutoTestFlag = 0;
.................... 
.................... int8 SBUF = 0x00;
.................... 
.................... int1 Test_fault = 0;
.................... int8 T_test = 0x00;
.................... 
.................... int1 Test = 0;
.................... int1 Ack_F = 0;
.................... int1 Reset_F = 0;
.................... 
.................... volatile int1 functointest_f = 0;
.................... 
.................... int1 SyncStatus = 0;   //"0" -> No Sync signal
.................... int1 SyncFlag = 0;     //use for debounce sync signal
.................... int8 Synctimer = 0x00; //use for debounce sync signal
.................... 
.................... //int8 Input1_8;
.................... int8 Input9_16;
.................... 
.................... 
.................... int8 Output1_8;
.................... int8 Output9_16;
.................... 
.................... int8 Output595[4];
.................... 
.................... int8 tempdata;
.................... //int8 EEP_Config = 0x00;   //
.................... //int8 NUMBER_OF_595 ;
.................... 
.................... int8 EEpDat;
.................... 
.................... ///////// Data from EEProm ///////
.................... //int Device_Addr;
.................... 
.................... int8 InputType1_8;
.................... int8 InputType9_16;
.................... int8 InputType17_24;
.................... 
.................... int8 FaultType1_8;
.................... int8 FaultType9_16;
.................... int8 FaultType17_24;
.................... 
.................... 
.................... int8 OutputType1_8;
.................... int8 OutputType9_16;
.................... int8 OutputType17_24;
.................... 
.................... int8 OutputBoth1_8;
.................... int8 OutputBoth9_16;
.................... int8 OutputBoth17_24;
.................... 
.................... int8 Alarm_Indicator1_8;
.................... int8 Alarm_Indicator9_16;
.................... int8 Alarm_Indicator17_24;
.................... 
.................... int8 Input1_8;
.................... int8 Input9_10;
.................... int8 Input11_18;
.................... int8 Input19_20;
.................... 
.................... int8 Red1_8;
.................... int8 Red9_10 ;
.................... int8 Red11_18 ;
.................... int8 Red19_20 ;
.................... int8 Green1_8 ;
.................... int8 Green9_10 ;
.................... int8 Green11_18 ;
.................... int8 Green19_20 ;
.................... 
.................... int8 OUTRed1_8;
.................... int8 OUTRed9_10 ;
.................... int8 OUTRed11_18 ;
.................... int8 OUTRed19_20 ;
.................... int8 OUTGreen1_8 ;
.................... int8 OUTGreen9_10 ;
.................... int8 OUTGreen11_18 ;
.................... int8 OUTGreen19_20 ;
.................... 
.................... int8 AutoAck;
.................... int8 AutoAckTime;
.................... int8 FlashingRate;
.................... int8 NoOfPoint;
.................... int8 MasterSlaveSync;
.................... 
.................... int1 StartRead = 0;
.................... volatile int8 StartReadCount;
.................... 
.................... volatile int1 RefreshConfigData =0;
.................... ////////////////////////////////
.................... ///////// tempolary register //////////
.................... //int8 temp;
.................... //int1 RxDreceive = 0;
.................... 
.................... //////////////////////////////////////
.................... unsigned char const addr_sq = 0x10,end_sq = 0x11,code_sq = 0x12,start_addr_hi_sq = 0x13,start_addr_lo_sq = 0x14;         //serial sequnce
.................... unsigned char const ubyte_hi_sq = 0x15,ubyte_lo_sq = 0x16,crc_hi_sq = 0x17, second_numofdata = 0x18,byte_count_sq = 0x19,data_sq = 0x20;      //serial sequnce
.................... 
.................... int1 recieve_completed = 0;
.................... unsigned char sequence;         //keep sequence use for RxD
.................... unsigned char Address;
.................... unsigned int16 RxD_DataLen = 0x00;
.................... unsigned char TxD_Buff[256];
.................... unsigned char RxD_Buff[512];
.................... unsigned char CRC_Lo;
.................... unsigned char CRC_Hi;
.................... int16 Send_check_Time = 500; //if no send reset buffer every 5 second
.................... 
.................... int16 Start_Address = 0x0000;
.................... int16 No_PointCount = 0x0000;
.................... unsigned char Data_ByteCount = 0x00;
.................... unsigned char Data_Buff[512];
.................... //unsigned char DataTemp;
.................... //unsigned char TxD_DataLen;
.................... 
.................... int8 MCP23s17_Ip_dat;
.................... 
.................... int8 MCP23s17_Op_dat;
.................... 
.................... unsigned char T_timeout;   //use for calculate RxD timeout
.................... unsigned int16 index = 0x00;         //use for Loop
.................... 
.................... int8 outmcp23 = 0;
.................... 
.................... unsigned char sms_phonenumber[15];
.................... 
.................... //unsigned char SMS_Massage[20][20];
.................... 
.................... unsigned char SMS_Massage1[32];
.................... unsigned char SMS_Massage2[32];
.................... unsigned char SMS_Massage3[32];
.................... unsigned char SMS_Massage4[32];
.................... unsigned char SMS_Massage5[32];
.................... unsigned char SMS_Massage6[32];
.................... unsigned char SMS_Massage7[32];
.................... unsigned char SMS_Massage8[32];
.................... unsigned char SMS_Massage9[32];
.................... unsigned char SMS_Massage10[32];
.................... 
.................... unsigned char SMS_MassageSUM[160] = ">>";
.................... 
.................... unsigned char spacestring[] = " ";
.................... 
.................... volatile int8 send_SMS_period ,send_SMS_count ;
.................... 
.................... unsigned char const CRC_Table_Hi[] = {
.................... 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81,
.................... 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
.................... 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01,
.................... 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
.................... 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81,
.................... 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0,
.................... 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01,
.................... 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
.................... 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81,
.................... 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
.................... 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01,
.................... 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
.................... 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 
.................... 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
.................... 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 
.................... 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
.................... 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81,
.................... 0x40
.................... } ; 
.................... 
.................... unsigned  char const CRC_Table_Lo[] = {
.................... 0x00, 0xC0, 0xC1, 0x01, 0xC3, 0x03, 0x02, 0xC2, 0xC6, 0x06, 0x07, 0xC7, 0x05, 0xC5, 0xC4,
.................... 0x04, 0xCC, 0x0C, 0x0D, 0xCD, 0x0F, 0xCF, 0xCE, 0x0E, 0x0A, 0xCA, 0xCB, 0x0B, 0xC9, 0x09,
.................... 0x08, 0xC8, 0xD8, 0x18, 0x19, 0xD9, 0x1B, 0xDB, 0xDA, 0x1A, 0x1E, 0xDE, 0xDF, 0x1F, 0xDD,
.................... 0x1D, 0x1C, 0xDC, 0x14, 0xD4, 0xD5, 0x15, 0xD7, 0x17, 0x16, 0xD6, 0xD2, 0x12, 0x13, 0xD3,
.................... 0x11, 0xD1, 0xD0, 0x10, 0xF0, 0x30, 0x31, 0xF1, 0x33, 0xF3, 0xF2, 0x32, 0x36, 0xF6, 0xF7,
.................... 0x37, 0xF5, 0x35, 0x34, 0xF4, 0x3C, 0xFC, 0xFD, 0x3D, 0xFF, 0x3F, 0x3E, 0xFE, 0xFA, 0x3A,
.................... 0x3B, 0xFB, 0x39, 0xF9, 0xF8, 0x38, 0x28, 0xE8, 0xE9, 0x29, 0xEB, 0x2B, 0x2A, 0xEA, 0xEE,
.................... 0x2E, 0x2F, 0xEF, 0x2D, 0xED, 0xEC, 0x2C, 0xE4, 0x24, 0x25, 0xE5, 0x27, 0xE7, 0xE6, 0x26, 
.................... 0x22, 0xE2, 0xE3, 0x23, 0xE1, 0x21, 0x20, 0xE0, 0xA0, 0x60, 0x61, 0xA1, 0x63, 0xA3, 0xA2,
.................... 0x62, 0x66, 0xA6, 0xA7, 0x67, 0xA5, 0x65, 0x64, 0xA4, 0x6C, 0xAC, 0xAD, 0x6D, 0xAF, 0x6F, 
.................... 0x6E, 0xAE, 0xAA, 0x6A, 0x6B, 0xAB, 0x69, 0xA9, 0xA8, 0x68, 0x78, 0xB8, 0xB9, 0x79, 0xBB,
.................... 0x7B, 0x7A, 0xBA, 0xBE, 0x7E, 0x7F, 0xBF, 0x7D, 0xBD, 0xBC, 0x7C, 0xB4, 0x74, 0x75, 0xB5, 
.................... 0x77, 0xB7, 0xB6, 0x76, 0x72, 0xB2, 0xB3, 0x73, 0xB1, 0x71, 0x70, 0xB0, 0x50, 0x90, 0x91,
.................... 0x51, 0x93, 0x53, 0x52, 0x92, 0x96, 0x56, 0x57, 0x97, 0x55, 0x95, 0x94, 0x54, 0x9C, 0x5C,
.................... 0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E, 0x5A, 0x9A, 0x9B, 0x5B, 0x99, 0x59, 0x58, 0x98, 0x88,
.................... 0x48, 0x49, 0x89, 0x4B, 0x8B, 0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C,
.................... 0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83, 0x41, 0x81, 0x80,
.................... 0x40
.................... } ;
.................... 
.................... ///////////// Define Bit register ////////////////////////////
.................... 
.................... struct Bit64    // Input
.................... {
....................    int1 B1,B2,B3,B4,B5,B6,B7,B8,B9,B10;
....................    //int1 B11,B12,B13,B14,B15,B16,B17,B18,B19,B20;
....................    //int1 B21,B22,B23,B24,B25,B26,B27,B28,B29,B30;
....................    //int1 B31,B32,B33,B34,B35,B36,B37,B38,B39,B40;
....................    //int1 B41,B42,B43,B44,B45,B46,B47,B48,B49,B50;
....................    //int1 B51,B52,B53,B54,B55,B56,B57,B58,B59,B60;
....................    //int1 B61,B62,B63,B64;
.................... };
.................... 
.................... struct Bit64 Inputt,Output,InputType,FaultType,OutputType,OutputBoth;
.................... struct Bit64 AlarmIndicator,Ack,In,In2;
.................... struct Bit64 LED_Colour,AckSend,RED_Colour,GREEN_Colour;
.................... struct Bit64 SendSMS;
.................... 
.................... int1 FaultAgo[11];
.................... int1 FaultNow[11];
.................... int16 ReleaseTime[11];
.................... int16 FaultDelayTime[11];
.................... 
.................... int1 FaultNCNO[11];
.................... #define NO 1
.................... #define NC 0
.................... 
.................... //////////////////////////////--Function--/////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////MODBUS Routine//////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... 
.................... void StoreReleaseFault()
*
01676:  MOVLB  7
01678:  CLRF   xD0
.................... {
....................    Signed int8 i=0;
....................    for(i=0;i<=10;i++)
0167A:  CLRF   xD0
0167C:  BTFSC  xD0.7
0167E:  BRA    1686
01680:  MOVF   xD0,W
01682:  SUBLW  0A
01684:  BNC   16CC
....................    {
....................       FaultAgo[i] = FaultNow[i];
01686:  CLRF   03
01688:  MOVF   xD0,W
0168A:  MOVWF  00
0168C:  BTFSC  FE8.7
0168E:  DECF   03,F
01690:  MOVWF  xD1
01692:  MOVFF  03,7D2
01696:  CLRF   03
01698:  MOVF   xD0,W
0169A:  MOVWF  00
0169C:  BTFSC  FE8.7
0169E:  DECF   03,F
016A0:  MOVWF  xD3
016A2:  MOVLW  07
016A4:  MOVWF  xD5
016A6:  MOVLW  95
016A8:  MOVWF  xD4
016AA:  MOVLB  0
016AC:  RCALL  15DC
016AE:  MOVFF  7D1,7D3
016B2:  MOVLB  7
016B4:  CLRF   xD4
016B6:  BTFSC  01.0
016B8:  INCF   xD4,F
016BA:  MOVLW  07
016BC:  MOVWF  xD6
016BE:  MOVLW  93
016C0:  MOVWF  xD5
016C2:  MOVLB  0
016C4:  RCALL  1634
016C6:  MOVLB  7
016C8:  INCF   xD0,F
016CA:  BRA    167C
....................    }
016CC:  MOVLB  0
016CE:  GOTO   1D6C (RETURN)
.................... }
.................... 
.................... 
.................... void CRC(unsigned char *puchMsg , unsigned char usDataLen)
.................... { 
....................    unsigned char uIndex ;                   /* fill index into CRC lookup table */
....................    unsigned char i ;
.................... 
....................    CRC_Hi = 0xFF ;                      /* high byte of CRC initialized */
*
01F50:  MOVLB  3
01F52:  SETF   x74
....................    CRC_Lo = 0xFF ;                      /* low byte of CRC initialized */
01F54:  SETF   x73
.................... 
....................    for(i = 0;i < usDataLen;i++)
01F56:  MOVLB  7
01F58:  CLRF   xDE
01F5A:  MOVF   xDC,W
01F5C:  SUBWF  xDE,W
01F5E:  BC    1FA2
....................    {
....................       restart_wdt() ;
01F60:  CLRWDT
....................       uIndex = CRC_Hi ^ (unsigned char) puchMsg[i] ;
01F62:  MOVF   xDE,W
01F64:  ADDWF  xDA,W
01F66:  MOVWF  FE9
01F68:  MOVLW  00
01F6A:  ADDWFC xDB,W
01F6C:  MOVWF  FEA
01F6E:  MOVF   FEF,W
01F70:  MOVLB  3
01F72:  XORWF  x74,W
01F74:  MOVLB  7
01F76:  MOVWF  xDD
....................       CRC_Hi = CRC_Lo ^ CRC_Table_Hi[uIndex] ;
01F78:  CLRF   03
01F7A:  MOVF   xDD,W
01F7C:  MOVLB  0
01F7E:  CALL   00C6
01F82:  MOVWF  01
01F84:  MOVLB  3
01F86:  MOVF   x73,W
01F88:  XORWF  01,W
01F8A:  MOVWF  x74
....................       CRC_Lo = CRC_Table_Lo[uIndex] ;
01F8C:  CLRF   03
01F8E:  MOVLB  7
01F90:  MOVF   xDD,W
01F92:  MOVLB  0
01F94:  CALL   01D6
01F98:  MOVFF  FE8,373
01F9C:  MOVLB  7
01F9E:  INCF   xDE,F
01FA0:  BRA    1F5A
....................    }
01FA2:  MOVLB  0
01FA4:  RETURN 0
.................... }
.................... //////////////////////////////////////////////////////////
.................... 
.................... char blankSigned[] = ">>";
.................... void sendsum_sms(void)
.................... {
....................    if(strcmp(SMS_MassageSUM, blankSigned) != 0) {
*
06180:  MOVLW  06
06182:  MOVLB  7
06184:  MOVWF  xD0
06186:  MOVLW  D1
06188:  MOVWF  xCF
0618A:  MOVLW  07
0618C:  MOVWF  xD2
0618E:  MOVLW  C5
06190:  MOVWF  xD1
06192:  MOVLB  0
06194:  BRA    60E0
06196:  MOVF   01,F
06198:  BZ    6232
....................    
....................       fprintf(CH2,"AT+CMGF=1"); 
0619A:  MOVLW  E6
0619C:  MOVWF  FF6
0619E:  MOVLW  02
061A0:  MOVWF  FF7
061A2:  CALL   1F30
....................       putc('\n',CH2);
061A6:  MOVLW  0A
061A8:  MOVLB  7
061AA:  MOVWF  xD1
061AC:  MOVLB  0
061AE:  CALL   1EEA
....................       delay_ms(10);
061B2:  MOVLW  0A
061B4:  MOVLB  7
061B6:  MOVWF  xD8
061B8:  MOVLB  0
061BA:  CALL   068A
....................    
....................       fprintf(CH2,"AT+CMGS=\"");
061BE:  MOVLW  F0
061C0:  MOVWF  FF6
061C2:  MOVLW  02
061C4:  MOVWF  FF7
061C6:  CALL   1F30
....................       fprintf(CH2,sms_phonenumber);
061CA:  MOVLW  05
061CC:  MOVWF  FEA
061CE:  MOVLW  82
061D0:  MOVWF  FE9
061D2:  RCALL  615A
....................       
....................       fprintf(CH2,"\"");
061D4:  MOVLW  22
061D6:  MOVLB  7
061D8:  MOVWF  xD1
061DA:  MOVLB  0
061DC:  CALL   1EEA
....................       putc('\n',CH2);
061E0:  MOVLW  0A
061E2:  MOVLB  7
061E4:  MOVWF  xD1
061E6:  MOVLB  0
061E8:  CALL   1EEA
....................       delay_ms(50);
061EC:  MOVLW  32
061EE:  MOVLB  7
061F0:  MOVWF  xD8
061F2:  MOVLB  0
061F4:  CALL   068A
....................      
....................      fprintf(CH2,SMS_MassageSUM);
061F8:  MOVLW  06
061FA:  MOVWF  FEA
061FC:  MOVLW  D1
061FE:  MOVWF  FE9
06200:  RCALL  615A
....................      putc('\n',CH2);
06202:  MOVLW  0A
06204:  MOVLB  7
06206:  MOVWF  xD1
06208:  MOVLB  0
0620A:  CALL   1EEA
....................      putc(26,CH2);
0620E:  MOVLW  1A
06210:  MOVLB  7
06212:  MOVWF  xD1
06214:  MOVLB  0
06216:  CALL   1EEA
....................      
....................      strcpy(SMS_MassageSUM, blankSigned);
0621A:  MOVLW  06
0621C:  MOVWF  FEA
0621E:  MOVLW  D1
06220:  MOVWF  FE9
06222:  MOVLW  07
06224:  MOVWF  FE2
06226:  MOVLW  C5
06228:  MOVWF  FE1
0622A:  MOVF   FE7,F
0622C:  MOVFF  FE6,FEE
06230:  BNZ   622A
.................... 
....................    }
06232:  GOTO   6918 (RETURN)
.................... }
.................... /********************************6B595 Driver*********************************/
.................... /*
.................... void Driver595()
.................... {
....................    Signed int8 j=0;
....................    int8 data_out ;
.................... 
....................    restart_wdt();
....................    
....................     data_out = (~Input19_20);
....................     for(j=7;j>=0;j--)
....................     {
....................      //output_bit(EXP_OUT_DO,bit_test(Output595[i],j));
....................      output_bit(EXP_OUT_DO,bit_test(data_out,j));
....................      output_high(EXP_OUT_CLOCK);
....................      delay_us(1);
....................      output_low(EXP_OUT_CLOCK);
....................     }
....................     
....................     data_out = (~Input11_18);
....................     for(j=7;j>=0;j--)
....................     {
....................      //output_bit(EXP_OUT_DO,bit_test(Output595[i],j));
....................      output_bit(EXP_OUT_DO,bit_test(data_out,j));
....................      output_high(EXP_OUT_CLOCK);
....................      delay_us(1);
....................      output_low(EXP_OUT_CLOCK);
....................     }
....................     
....................     data_out = (~Input9_10);
....................     for(j=7;j>=0;j--)
....................     {
....................      //output_bit(EXP_OUT_DO,bit_test(Output595[i],j));
....................      output_bit(EXP_OUT_DO,bit_test(data_out,j));
....................      output_high(EXP_OUT_CLOCK);
....................      delay_us(1);
....................      output_low(EXP_OUT_CLOCK);
....................     }
....................     
....................     data_out = (~Input1_8);
....................     for(j=7;j>=0;j--)
....................     {
....................      //output_bit(EXP_OUT_DO,bit_test(Output595[i],j));
....................      output_bit(EXP_OUT_DO,bit_test(data_out,j));
....................      output_high(EXP_OUT_CLOCK);
....................      delay_us(1);
....................      output_low(EXP_OUT_CLOCK);
....................     }
....................  // } 
....................    output_high(EXP_OUT_ENABLE);
....................    delay_us(1);
....................    output_low(EXP_OUT_ENABLE);
.................... }
.................... */
.................... ////////////////////////////////////////////////////////////////////////////////
.................... 
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... 
.................... void Alarmtosend(void)
.................... {
....................    Input1_8_Send = 0x00;
*
01FAE:  CLRF   20
....................    Input9_16_Send = 0x00;
01FB0:  CLRF   21
....................    
....................    
....................    Ack1_8_Send = 0x00;
01FB2:  CLRF   28
....................    Ack9_16_Send = 0x00;
01FB4:  CLRF   29
.................... 
....................    
....................    /////////////////////////////////////////////////////
....................   
....................    if((In.B1 == 0) && (Output.B1 ==0))
01FB6:  MOVLB  7
01FB8:  BTFSC  x85.0
01FBA:  BRA    1FC4
01FBC:  BTFSC  x77.0
01FBE:  BRA    1FC4
....................       AckSend.B1 = 1;
01FC0:  BSF    x8B.0
01FC2:  BRA    1FC6
....................    else
....................       AckSend.B1 = 0;
01FC4:  BCF    x8B.0
....................    if((In.B2 == 0) && (Output.B2 ==0))
01FC6:  BTFSC  x85.1
01FC8:  BRA    1FD2
01FCA:  BTFSC  x77.1
01FCC:  BRA    1FD2
....................       AckSend.B2 = 1;
01FCE:  BSF    x8B.1
01FD0:  BRA    1FD4
....................    else
....................       AckSend.B2 = 0;
01FD2:  BCF    x8B.1
....................    if((In.B3 == 0) && (Output.B3 ==0))
01FD4:  BTFSC  x85.2
01FD6:  BRA    1FE0
01FD8:  BTFSC  x77.2
01FDA:  BRA    1FE0
....................       AckSend.B3 = 1;
01FDC:  BSF    x8B.2
01FDE:  BRA    1FE2
....................    else
....................       AckSend.B3 = 0;
01FE0:  BCF    x8B.2
....................    if((In.B4 == 0) && (Output.B4 ==0))
01FE2:  BTFSC  x85.3
01FE4:  BRA    1FEE
01FE6:  BTFSC  x77.3
01FE8:  BRA    1FEE
....................       AckSend.B4 = 1;
01FEA:  BSF    x8B.3
01FEC:  BRA    1FF0
....................    else
....................       AckSend.B4 = 0;
01FEE:  BCF    x8B.3
....................    if((In.B5 == 0) && (Output.B5 ==0))
01FF0:  BTFSC  x85.4
01FF2:  BRA    1FFC
01FF4:  BTFSC  x77.4
01FF6:  BRA    1FFC
....................       AckSend.B5 = 1;
01FF8:  BSF    x8B.4
01FFA:  BRA    1FFE
....................    else
....................       AckSend.B5 = 0;
01FFC:  BCF    x8B.4
....................    if((In.B6 == 0) && (Output.B6 ==0))
01FFE:  BTFSC  x85.5
02000:  BRA    200A
02002:  BTFSC  x77.5
02004:  BRA    200A
....................       AckSend.B6 = 1;
02006:  BSF    x8B.5
02008:  BRA    200C
....................    else
....................       AckSend.B6 = 0;
0200A:  BCF    x8B.5
....................    if((In.B7 == 0) && (Output.B7 ==0))
0200C:  BTFSC  x85.6
0200E:  BRA    2018
02010:  BTFSC  x77.6
02012:  BRA    2018
....................       AckSend.B7 = 1;
02014:  BSF    x8B.6
02016:  BRA    201A
....................    else
....................       AckSend.B7 = 0;
02018:  BCF    x8B.6
....................    if((In.B8 == 0) && (Output.B8 ==0))
0201A:  BTFSC  x85.7
0201C:  BRA    2026
0201E:  BTFSC  x77.7
02020:  BRA    2026
....................       AckSend.B8 = 1;
02022:  BSF    x8B.7
02024:  BRA    2028
....................    else
....................       AckSend.B8 = 0;
02026:  BCF    x8B.7
....................    if((In.B9 == 0) && (Output.B9 ==0))
02028:  BTFSC  x86.0
0202A:  BRA    2034
0202C:  BTFSC  x78.0
0202E:  BRA    2034
....................       AckSend.B9 = 1;
02030:  BSF    x8C.0
02032:  BRA    2036
....................    else
....................       AckSend.B9 = 0;
02034:  BCF    x8C.0
....................    if((In.B10 == 0) && (Output.B10 ==0))
02036:  BTFSC  x86.1
02038:  BRA    2042
0203A:  BTFSC  x78.1
0203C:  BRA    2042
....................       AckSend.B10 = 1;
0203E:  BSF    x8C.1
02040:  BRA    2044
....................    else
....................       AckSend.B10 = 0;
02042:  BCF    x8C.1
.................... 
.................... 
....................    ///////////////////Ack/////////////////////////////////
....................    Ack1_8_Send = Ack1_8_Send | AckSend.B8;
02044:  MOVLW  00
02046:  BTFSC  x8B.7
02048:  MOVLW  01
0204A:  IORWF  28,F
....................    Ack1_8_Send = (Ack1_8_Send << 1) | AckSend.B7;
0204C:  BCF    FD8.0
0204E:  RLCF   28,W
02050:  MOVWF  xD9
02052:  MOVLW  00
02054:  BTFSC  x8B.6
02056:  MOVLW  01
02058:  IORWF  xD9,W
0205A:  MOVWF  28
....................    Ack1_8_Send = (Ack1_8_Send << 1) | AckSend.B6;
0205C:  BCF    FD8.0
0205E:  RLCF   28,W
02060:  MOVWF  xD9
02062:  MOVLW  00
02064:  BTFSC  x8B.5
02066:  MOVLW  01
02068:  IORWF  xD9,W
0206A:  MOVWF  28
....................    Ack1_8_Send = (Ack1_8_Send << 1) | AckSend.B5;
0206C:  BCF    FD8.0
0206E:  RLCF   28,W
02070:  MOVWF  xD9
02072:  MOVLW  00
02074:  BTFSC  x8B.4
02076:  MOVLW  01
02078:  IORWF  xD9,W
0207A:  MOVWF  28
....................    Ack1_8_Send = (Ack1_8_Send << 1) | AckSend.B4;
0207C:  BCF    FD8.0
0207E:  RLCF   28,W
02080:  MOVWF  xD9
02082:  MOVLW  00
02084:  BTFSC  x8B.3
02086:  MOVLW  01
02088:  IORWF  xD9,W
0208A:  MOVWF  28
....................    Ack1_8_Send = (Ack1_8_Send << 1) | AckSend.B3;
0208C:  BCF    FD8.0
0208E:  RLCF   28,W
02090:  MOVWF  xD9
02092:  MOVLW  00
02094:  BTFSC  x8B.2
02096:  MOVLW  01
02098:  IORWF  xD9,W
0209A:  MOVWF  28
....................    Ack1_8_Send = (Ack1_8_Send << 1) | AckSend.B2;
0209C:  BCF    FD8.0
0209E:  RLCF   28,W
020A0:  MOVWF  xD9
020A2:  MOVLW  00
020A4:  BTFSC  x8B.1
020A6:  MOVLW  01
020A8:  IORWF  xD9,W
020AA:  MOVWF  28
....................    Ack1_8_Send = (Ack1_8_Send << 1) | AckSend.B1;
020AC:  BCF    FD8.0
020AE:  RLCF   28,W
020B0:  MOVWF  xD9
020B2:  MOVLW  00
020B4:  BTFSC  x8B.0
020B6:  MOVLW  01
020B8:  IORWF  xD9,W
020BA:  MOVWF  28
....................    
....................    Ack9_16_Send = Ack9_16_Send | AckSend.B10;
020BC:  MOVLW  00
020BE:  BTFSC  x8C.1
020C0:  MOVLW  01
020C2:  IORWF  29,F
....................    Ack9_16_Send = (Ack9_16_Send << 1) | AckSend.B9;
020C4:  BCF    FD8.0
020C6:  RLCF   29,W
020C8:  MOVWF  xD9
020CA:  MOVLW  00
020CC:  BTFSC  x8C.0
020CE:  MOVLW  01
020D0:  IORWF  xD9,W
020D2:  MOVWF  29
....................   
....................    ///////////////////Fault/////////////////////////////////
....................    Input1_8_Send = Input1_8_Send | In.B8;
020D4:  MOVLW  00
020D6:  BTFSC  x85.7
020D8:  MOVLW  01
020DA:  IORWF  20,F
....................    Input1_8_Send = (Input1_8_Send << 1) | In.B7;
020DC:  BCF    FD8.0
020DE:  RLCF   20,W
020E0:  MOVWF  xD9
020E2:  MOVLW  00
020E4:  BTFSC  x85.6
020E6:  MOVLW  01
020E8:  IORWF  xD9,W
020EA:  MOVWF  20
....................    Input1_8_Send = (Input1_8_Send << 1) | In.B6;
020EC:  BCF    FD8.0
020EE:  RLCF   20,W
020F0:  MOVWF  xD9
020F2:  MOVLW  00
020F4:  BTFSC  x85.5
020F6:  MOVLW  01
020F8:  IORWF  xD9,W
020FA:  MOVWF  20
....................    Input1_8_Send = (Input1_8_Send << 1) | In.B5;
020FC:  BCF    FD8.0
020FE:  RLCF   20,W
02100:  MOVWF  xD9
02102:  MOVLW  00
02104:  BTFSC  x85.4
02106:  MOVLW  01
02108:  IORWF  xD9,W
0210A:  MOVWF  20
....................    Input1_8_Send = (Input1_8_Send << 1) | In.B4;
0210C:  BCF    FD8.0
0210E:  RLCF   20,W
02110:  MOVWF  xD9
02112:  MOVLW  00
02114:  BTFSC  x85.3
02116:  MOVLW  01
02118:  IORWF  xD9,W
0211A:  MOVWF  20
....................    Input1_8_Send = (Input1_8_Send << 1) | In.B3;
0211C:  BCF    FD8.0
0211E:  RLCF   20,W
02120:  MOVWF  xD9
02122:  MOVLW  00
02124:  BTFSC  x85.2
02126:  MOVLW  01
02128:  IORWF  xD9,W
0212A:  MOVWF  20
....................    Input1_8_Send = (Input1_8_Send << 1) | In.B2;
0212C:  BCF    FD8.0
0212E:  RLCF   20,W
02130:  MOVWF  xD9
02132:  MOVLW  00
02134:  BTFSC  x85.1
02136:  MOVLW  01
02138:  IORWF  xD9,W
0213A:  MOVWF  20
....................    Input1_8_Send = (Input1_8_Send << 1) | In.B1;
0213C:  BCF    FD8.0
0213E:  RLCF   20,W
02140:  MOVWF  xD9
02142:  MOVLW  00
02144:  BTFSC  x85.0
02146:  MOVLW  01
02148:  IORWF  xD9,W
0214A:  MOVWF  20
....................    
....................    Input9_16_Send = Input9_16_Send | In.B10;
0214C:  MOVLW  00
0214E:  BTFSC  x86.1
02150:  MOVLW  01
02152:  IORWF  21,F
....................    Input9_16_Send = (Input9_16_Send << 1) | In.B9;
02154:  BCF    FD8.0
02156:  RLCF   21,W
02158:  MOVWF  xD9
0215A:  MOVLW  00
0215C:  BTFSC  x86.0
0215E:  MOVLW  01
02160:  IORWF  xD9,W
02162:  MOVWF  21
02164:  MOVLB  0
02166:  GOTO   28CE (RETURN)
.................... 
.................... }
.................... 
.................... ////////////////////////////////////////////////////////////////////////////////
.................... 
.................... void checkCommand(void)
.................... {
....................    static int8 count_bytecount =0;
....................    restart_wdt();
*
002FA:  CLRWDT
.................... 
....................    //if(sequence == end_sq && Address == SBUF)     //check Address
....................    if(sequence == end_sq )     //check Address
002FC:  MOVF   x66,W
002FE:  SUBWF  x6F,W
00300:  BNZ   0330
....................    {
....................      RxD_DataLen = 0x00 ;
00302:  CLRF   x72
00304:  CLRF   x71
....................      RxD_Buff[RxD_DataLen] = SBUF ;      //Byte 1   Address
00306:  MOVLW  73
00308:  ADDWF  x71,W
0030A:  MOVWF  FE9
0030C:  MOVLW  01
0030E:  ADDWFC x72,W
00310:  MOVWF  FEA
00312:  MOVFF  30,FEF
....................      restart_wdt();
00316:  CLRWDT
....................      RxD_DataLen ++ ;
00318:  INCF   x71,F
0031A:  BTFSC  FD8.2
0031C:  INCF   x72,F
....................      sequence = addr_sq;
0031E:  MOVLW  10
00320:  MOVWF  x6F
....................      count_bytecount =0; // bytecount = 2 Byte //jj10092564
00322:  MOVLB  7
00324:  CLRF   xCA
....................      
....................      T_timeout = 0x14; //200ms
00326:  MOVLW  14
00328:  MOVLB  5
0032A:  MOVWF  x7E
....................    }
0032C:  BRA    05B0
0032E:  MOVLB  0
....................    else if(sequence == addr_sq)
00330:  MOVF   x6F,W
00332:  SUBLW  10
00334:  BNZ   03DA
....................    {
....................       RxD_Buff[RxD_DataLen] = SBUF ;      //Byte 2   Function Code
00336:  MOVLW  73
00338:  ADDWF  x71,W
0033A:  MOVWF  FE9
0033C:  MOVLW  01
0033E:  ADDWFC x72,W
00340:  MOVWF  FEA
00342:  MOVFF  30,FEF
....................       restart_wdt();
00346:  CLRWDT
....................       RxD_DataLen ++ ;
00348:  INCF   x71,F
0034A:  BTFSC  FD8.2
0034C:  INCF   x72,F
.................... 
....................        if(RxD_Buff[1] < 0x17)   //Function Code Must be less than 0x20
0034E:  MOVLB  1
00350:  MOVF   x74,W
00352:  SUBLW  16
00354:  BNC   0364
....................        {
....................            sequence = code_sq;
00356:  MOVFF  67,6F
....................            T_timeout = 0x14; //200ms
0035A:  MOVLW  14
0035C:  MOVLB  5
0035E:  MOVWF  x7E
....................        }
00360:  BRA    03D6
00362:  MOVLB  1
....................        else if(RxD_Buff[1] == 0x20)   /////Read Setting//////
00364:  MOVF   x74,W
00366:  SUBLW  20
00368:  BNZ   0378
....................        {
....................           sequence = ubyte_lo_sq;
0036A:  MOVFF  6A,6F
....................           T_timeout = 0x14; //200ms
0036E:  MOVLW  14
00370:  MOVLB  5
00372:  MOVWF  x7E
....................        }
00374:  BRA    03D6
00376:  MOVLB  1
....................        else if(RxD_Buff[1] == 0x21)   /////Write setting/////
00378:  MOVF   x74,W
0037A:  SUBLW  21
0037C:  BNZ   038A
....................        { 
....................           sequence = byte_count_sq ;
0037E:  MOVFF  6D,6F
....................           T_timeout = 0x14; //200ms
00382:  MOVLW  14
00384:  MOVLB  5
00386:  MOVWF  x7E
....................        }
00388:  BRA    03D6
....................        //   SMS     
....................        else if(RxD_Buff[RxD_DataLen - 1] == 0x22)   /////SMS setting/////
0038A:  MOVLW  01
0038C:  MOVLB  0
0038E:  SUBWF  x71,W
00390:  MOVLB  7
00392:  MOVWF  xDF
00394:  MOVLW  00
00396:  MOVLB  0
00398:  SUBWFB x72,W
0039A:  MOVLB  7
0039C:  MOVWF  xE0
0039E:  MOVLW  73
003A0:  ADDWF  xDF,W
003A2:  MOVWF  FE9
003A4:  MOVLW  01
003A6:  ADDWFC xE0,W
003A8:  MOVWF  FEA
003AA:  MOVF   FEF,W
003AC:  SUBLW  22
003AE:  BNZ   03BE
....................        {
....................           sequence = second_numofdata ;
003B0:  MOVFF  6C,6F
....................           T_timeout = 0x14; //200ms
003B4:  MOVLW  14
003B6:  MOVLB  5
003B8:  MOVWF  x7E
....................        }
003BA:  BRA    03D6
003BC:  MOVLB  7
....................        else                           // Invalid Code
....................        {
....................           RxD_DataLen = 0x00;
003BE:  MOVLB  0
003C0:  CLRF   x72
003C2:  CLRF   x71
....................           sequence = end_sq;
003C4:  MOVFF  66,6F
....................           T_timeout = 0x00; 
003C8:  MOVLB  5
003CA:  CLRF   x7E
....................           output_bit(P485ctrl,0);
003CC:  BCF    F8A.3
003CE:  BCF    F93.3
....................           count_bytecount =0; // bytecount = 2 Byte //jj10092564
003D0:  MOVLB  7
003D2:  CLRF   xCA
003D4:  MOVLB  5
....................        }
....................    }
003D6:  BRA    05B0
003D8:  MOVLB  0
....................    ////////////////////////////////
....................    else if(sequence == second_numofdata)
003DA:  MOVF   x6C,W
003DC:  SUBWF  x6F,W
003DE:  BNZ   0406
....................    {
....................       RxD_Buff[RxD_DataLen] = SBUF ;      //Byte 3   Start address High Byte
003E0:  MOVLW  73
003E2:  ADDWF  x71,W
003E4:  MOVWF  FE9
003E6:  MOVLW  01
003E8:  ADDWFC x72,W
003EA:  MOVWF  FEA
003EC:  MOVFF  30,FEF
....................       restart_wdt();
003F0:  CLRWDT
....................       RxD_DataLen ++ ;
003F2:  INCF   x71,F
003F4:  BTFSC  FD8.2
003F6:  INCF   x72,F
....................       sequence = byte_count_sq;
003F8:  MOVFF  6D,6F
....................       T_timeout = 0x14; //200ms
003FC:  MOVLW  14
003FE:  MOVLB  5
00400:  MOVWF  x7E
.................... 
....................    }
00402:  BRA    05B0
00404:  MOVLB  0
....................    else if(sequence == byte_count_sq)
00406:  MOVF   x6D,W
00408:  SUBWF  x6F,W
0040A:  BNZ   0472
....................    {
....................       RxD_Buff[RxD_DataLen] = SBUF ;      //Byte 3   Data Byte Count
0040C:  MOVLW  73
0040E:  ADDWF  x71,W
00410:  MOVWF  FE9
00412:  MOVLW  01
00414:  ADDWFC x72,W
00416:  MOVWF  FEA
00418:  MOVFF  30,FEF
....................       restart_wdt();
0041C:  CLRWDT
....................       RxD_DataLen ++ ;
0041E:  INCF   x71,F
00420:  BTFSC  FD8.2
00422:  INCF   x72,F
....................       if(RxD_Buff[1] == 0x22)   /////SMS setting/////
00424:  MOVLB  1
00426:  MOVF   x74,W
00428:  SUBLW  22
0042A:  BNZ   043E
....................       {
....................          index = (RxD_Buff[2] * 0x64) + RxD_Buff[3];
0042C:  MOVF   x75,W
0042E:  MULLW  64
00430:  MOVF   FF3,W
00432:  ADDWF  x76,W
00434:  MOVLB  5
00436:  MOVWF  x7F
00438:  CLRF   x80
....................       }
0043A:  BRA    0466
0043C:  MOVLB  1
....................       else{
....................          index = RxD_Buff[RxD_DataLen - 1] ;    //Data Byte Count
0043E:  MOVLW  01
00440:  MOVLB  0
00442:  SUBWF  x71,W
00444:  MOVLB  7
00446:  MOVWF  xDF
00448:  MOVLW  00
0044A:  MOVLB  0
0044C:  SUBWFB x72,W
0044E:  MOVLB  7
00450:  MOVWF  xE0
00452:  MOVLW  73
00454:  ADDWF  xDF,W
00456:  MOVWF  FE9
00458:  MOVLW  01
0045A:  ADDWFC xE0,W
0045C:  MOVWF  FEA
0045E:  MOVLB  5
00460:  CLRF   x80
00462:  MOVFF  FEF,57F
....................       }
....................       
....................       T_timeout = 0x14; //200ms
00466:  MOVLW  14
00468:  MOVWF  x7E
....................       sequence = data_sq ;
0046A:  MOVFF  6E,6F
....................    }
0046E:  BRA    05B0
00470:  MOVLB  0
....................    else if(sequence == data_sq)
00472:  MOVF   x6E,W
00474:  SUBWF  x6F,W
00476:  BNZ   04AE
....................    {
....................       RxD_Buff[RxD_DataLen] = SBUF ;      //
00478:  MOVLW  73
0047A:  ADDWF  x71,W
0047C:  MOVWF  FE9
0047E:  MOVLW  01
00480:  ADDWFC x72,W
00482:  MOVWF  FEA
00484:  MOVFF  30,FEF
....................       restart_wdt();
00488:  CLRWDT
....................       RxD_DataLen ++ ;
0048A:  INCF   x71,F
0048C:  BTFSC  FD8.2
0048E:  INCF   x72,F
....................       index -- ;                     //Data Byte Count
00490:  MOVLB  5
00492:  MOVF   x7F,W
00494:  BTFSC  FD8.2
00496:  DECF   x80,F
00498:  DECF   x7F,F
....................       if(index == 0x00)
0049A:  MOVF   x7F,F
0049C:  BNZ   04A6
0049E:  MOVF   x80,F
004A0:  BNZ   04A6
....................       {
....................          sequence = ubyte_lo_sq ;      //next CRC
004A2:  MOVFF  6A,6F
....................       }
....................       T_timeout = 0x14; //200ms
004A6:  MOVLW  14
004A8:  MOVWF  x7E
....................    }
004AA:  BRA    05B0
004AC:  MOVLB  0
....................    else if(sequence == code_sq)
004AE:  MOVF   x67,W
004B0:  SUBWF  x6F,W
004B2:  BNZ   04DA
....................    {
....................       RxD_Buff[RxD_DataLen] = SBUF ;      //Byte 3   Start address High Byte
004B4:  MOVLW  73
004B6:  ADDWF  x71,W
004B8:  MOVWF  FE9
004BA:  MOVLW  01
004BC:  ADDWFC x72,W
004BE:  MOVWF  FEA
004C0:  MOVFF  30,FEF
....................       restart_wdt();
004C4:  CLRWDT
....................       RxD_DataLen ++ ;
004C6:  INCF   x71,F
004C8:  BTFSC  FD8.2
004CA:  INCF   x72,F
....................       sequence = start_addr_hi_sq;
004CC:  MOVFF  68,6F
....................       T_timeout = 0x14; //200ms
004D0:  MOVLW  14
004D2:  MOVLB  5
004D4:  MOVWF  x7E
.................... 
....................    }
004D6:  BRA    05B0
004D8:  MOVLB  0
....................    else if(sequence == start_addr_hi_sq)
004DA:  MOVF   x68,W
004DC:  SUBWF  x6F,W
004DE:  BNZ   0506
....................    {
....................       RxD_Buff[RxD_DataLen] = SBUF ;         //Byte 4   Start address Low Byte
004E0:  MOVLW  73
004E2:  ADDWF  x71,W
004E4:  MOVWF  FE9
004E6:  MOVLW  01
004E8:  ADDWFC x72,W
004EA:  MOVWF  FEA
004EC:  MOVFF  30,FEF
....................       restart_wdt();
004F0:  CLRWDT
....................       RxD_DataLen ++ ;
004F2:  INCF   x71,F
004F4:  BTFSC  FD8.2
004F6:  INCF   x72,F
....................       sequence = start_addr_lo_sq;
004F8:  MOVFF  69,6F
....................       T_timeout = 0x14; //200ms
004FC:  MOVLW  14
004FE:  MOVLB  5
00500:  MOVWF  x7E
....................    }
00502:  BRA    05B0
00504:  MOVLB  0
....................    else if(sequence == start_addr_lo_sq)
00506:  MOVF   x69,W
00508:  SUBWF  x6F,W
0050A:  BNZ   0532
....................    {
....................       RxD_Buff[RxD_DataLen] = SBUF ;         //Byte 5   No. of point/force data High Byte
0050C:  MOVLW  73
0050E:  ADDWF  x71,W
00510:  MOVWF  FE9
00512:  MOVLW  01
00514:  ADDWFC x72,W
00516:  MOVWF  FEA
00518:  MOVFF  30,FEF
....................       restart_wdt();
0051C:  CLRWDT
....................       RxD_DataLen ++ ;
0051E:  INCF   x71,F
00520:  BTFSC  FD8.2
00522:  INCF   x72,F
....................       sequence = ubyte_hi_sq;
00524:  MOVLW  15
00526:  MOVWF  x6F
....................       T_timeout = 0x14; //200ms
00528:  MOVLW  14
0052A:  MOVLB  5
0052C:  MOVWF  x7E
....................    }
0052E:  BRA    05B0
00530:  MOVLB  0
....................    else if(sequence == ubyte_hi_sq)
00532:  MOVF   x6F,W
00534:  SUBLW  15
00536:  BNZ   055E
....................    {
....................       RxD_Buff[RxD_DataLen] = SBUF ;         //Byte 6   No. of point/force data Low Byte
00538:  MOVLW  73
0053A:  ADDWF  x71,W
0053C:  MOVWF  FE9
0053E:  MOVLW  01
00540:  ADDWFC x72,W
00542:  MOVWF  FEA
00544:  MOVFF  30,FEF
....................       restart_wdt();
00548:  CLRWDT
....................       RxD_DataLen ++ ;
0054A:  INCF   x71,F
0054C:  BTFSC  FD8.2
0054E:  INCF   x72,F
....................       sequence = ubyte_lo_sq;
00550:  MOVFF  6A,6F
....................       T_timeout = 0x14; //200ms
00554:  MOVLW  14
00556:  MOVLB  5
00558:  MOVWF  x7E
....................    }
0055A:  BRA    05B0
0055C:  MOVLB  0
....................    else if(sequence == ubyte_lo_sq)
0055E:  MOVF   x6A,W
00560:  SUBWF  x6F,W
00562:  BNZ   058A
....................    {
....................       RxD_Buff[RxD_DataLen] = SBUF ;         //Byte 7   CRC High Byte
00564:  MOVLW  73
00566:  ADDWF  x71,W
00568:  MOVWF  FE9
0056A:  MOVLW  01
0056C:  ADDWFC x72,W
0056E:  MOVWF  FEA
00570:  MOVFF  30,FEF
....................       restart_wdt();
00574:  CLRWDT
....................       RxD_DataLen ++ ;
00576:  INCF   x71,F
00578:  BTFSC  FD8.2
0057A:  INCF   x72,F
....................       sequence = crc_hi_sq;
0057C:  MOVFF  6B,6F
....................       T_timeout = 0x14; //200ms
00580:  MOVLW  14
00582:  MOVLB  5
00584:  MOVWF  x7E
....................    }
00586:  BRA    05B0
00588:  MOVLB  0
....................    else if(sequence == crc_hi_sq)
0058A:  MOVF   x6B,W
0058C:  SUBWF  x6F,W
0058E:  BNZ   05B0
....................    {
....................       RxD_Buff[RxD_DataLen] = SBUF ;         //Byte 8   CRC Low Byte
00590:  MOVLW  73
00592:  ADDWF  x71,W
00594:  MOVWF  FE9
00596:  MOVLW  01
00598:  ADDWFC x72,W
0059A:  MOVWF  FEA
0059C:  MOVFF  30,FEF
....................       restart_wdt();
005A0:  CLRWDT
....................       sequence = end_sq;
005A2:  MOVFF  66,6F
....................       T_timeout = 0x00;
005A6:  MOVLB  5
005A8:  CLRF   x7E
....................       //T_timeout = 0x14; //200ms
....................       recieve_completed = 1 ;            //Recieve completed then translate
005AA:  BSF    32.6
....................       output_bit(P485ctrl,0);
005AC:  BCF    F8A.3
005AE:  BCF    F93.3
005B0:  MOVLB  0
....................    }
005B2:  GOTO   05C0 (RETURN)
.................... }
.................... 
.................... ///////////////////////////////////////////////////////////////////////////////
.................... 
.................... 
.................... ////////////////////////////////////////////////////////////////////////////////
.................... ///////////////////// MODBUS FUNCTION //////////////////////////////////////////
.................... ////////////////////////////////////////////////////////////////////////////////
.................... void Modbus_Function(void)
.................... {
....................    restart_wdt();
*
0216A:  CLRWDT
....................    CRC(RxD_Buff , RxD_DataLen - 1);
0216C:  MOVLW  01
0216E:  SUBWF  x71,W
02170:  MOVLB  7
02172:  MOVWF  xD8
02174:  MOVLW  00
02176:  MOVLB  0
02178:  SUBWFB x72,W
0217A:  MOVLB  7
0217C:  MOVWF  xD9
0217E:  MOVLW  01
02180:  MOVWF  xDB
02182:  MOVLW  73
02184:  MOVWF  xDA
02186:  MOVFF  7D8,7DC
0218A:  MOVLB  0
0218C:  RCALL  1F50
.................... 
....................    if(CRC_Hi == RxD_Buff[RxD_DataLen - 1] && CRC_Lo == RxD_Buff[RxD_DataLen])
0218E:  MOVLW  01
02190:  SUBWF  x71,W
02192:  MOVLB  7
02194:  MOVWF  xD8
02196:  MOVLW  00
02198:  MOVLB  0
0219A:  SUBWFB x72,W
0219C:  MOVLB  7
0219E:  MOVWF  xD9
021A0:  MOVLW  73
021A2:  ADDWF  xD8,W
021A4:  MOVWF  FE9
021A6:  MOVLW  01
021A8:  ADDWFC xD9,W
021AA:  MOVWF  FEA
021AC:  MOVF   FEF,W
021AE:  MOVLB  3
021B0:  SUBWF  x74,W
021B2:  BTFSS  FD8.2
021B4:  GOTO   3F5A
021B8:  MOVLW  73
021BA:  MOVLB  0
021BC:  ADDWF  x71,W
021BE:  MOVWF  FE9
021C0:  MOVLW  01
021C2:  ADDWFC x72,W
021C4:  MOVWF  FEA
021C6:  MOVF   FEF,W
021C8:  MOVLB  3
021CA:  SUBWF  x73,W
021CC:  BTFSS  FD8.2
021CE:  GOTO   3F5A
....................    {
....................    
....................          
....................       if((RxD_Buff[0] == 0xAA)&&(RxD_Buff[1] == 0x20)) //Read Setting//0xAA Is Any Address 
021D2:  MOVLB  1
021D4:  MOVF   x73,W
021D6:  SUBLW  AA
021D8:  BTFSS  FD8.2
021DA:  BRA    2498
021DC:  MOVF   x74,W
021DE:  SUBLW  20
021E0:  BTFSS  FD8.2
021E2:  BRA    2498
....................       {
....................          TxD_Buff[0] = Address ;         //Address
021E4:  MOVFF  70,73
....................          TxD_Buff[1] = 0x20 ;            //function code
021E8:  MOVLW  20
021EA:  MOVLB  0
021EC:  MOVWF  x74
....................          TxD_Buff[2] = 0x1C ;           //28 Byte  //Data Byte count
021EE:  MOVLW  1C
021F0:  MOVWF  x75
....................          TxD_Buff[3] = InputType1_8 ;    //1
021F2:  MOVFF  3D,76
....................          TxD_Buff[4] = InputType9_16 ;  //2
021F6:  MOVFF  3E,77
....................          TxD_Buff[5] = InputType17_24 ;//3
021FA:  MOVFF  3F,78
....................          
....................          TxD_Buff[6] = FaultType1_8 ;  //4
021FE:  MOVFF  40,79
....................          TxD_Buff[7] = FaultType9_16 ; //5
02202:  MOVFF  41,7A
....................          TxD_Buff[8] = FaultType17_24 ;   //6
02206:  MOVFF  42,7B
....................         
....................          TxD_Buff[9] = OutputType1_8 ; //7
0220A:  MOVFF  43,7C
....................          TxD_Buff[10] = OutputType9_16 ;  //8
0220E:  MOVFF  44,7D
....................          TxD_Buff[11] = OutputType17_24 ; //9
02212:  MOVFF  45,7E
....................         
....................          TxD_Buff[12] = OutputBoth1_8 ;   //10
02216:  MOVFF  46,7F
....................          TxD_Buff[13] = OutputBoth9_16 ;  //11
0221A:  MOVFF  47,80
....................          TxD_Buff[14] = OutputBoth17_24 ; //12
0221E:  MOVFF  48,81
....................         
....................          TxD_Buff[15] = Alarm_Indicator1_8 ; //13
02222:  MOVFF  49,82
....................          TxD_Buff[16] = Alarm_Indicator9_16 ;   //14
02226:  MOVFF  4A,83
....................          TxD_Buff[17] = Alarm_Indicator17_24 ;  //15
0222A:  MOVFF  4B,84
....................         
....................           TxD_Buff[18] = read_eeprom(0x10);//Red1_8;    //16
0222E:  MOVFF  FF2,7D8
02232:  BCF    FF2.7
02234:  CLRF   FAA
02236:  MOVLW  10
02238:  MOVWF  FA9
0223A:  BCF    FA6.6
0223C:  BCF    FA6.7
0223E:  BSF    FA6.0
02240:  MOVF   FA8,W
02242:  MOVLB  7
02244:  BTFSC  xD8.7
02246:  BSF    FF2.7
02248:  MOVLB  0
0224A:  MOVWF  x85
....................           TxD_Buff[19] = read_eeprom(0x11);//Red9_10;      //17
0224C:  MOVFF  FF2,7D8
02250:  BCF    FF2.7
02252:  CLRF   FAA
02254:  MOVLW  11
02256:  MOVWF  FA9
02258:  BCF    FA6.6
0225A:  BCF    FA6.7
0225C:  BSF    FA6.0
0225E:  MOVF   FA8,W
02260:  MOVLB  7
02262:  BTFSC  xD8.7
02264:  BSF    FF2.7
02266:  MOVLB  0
02268:  MOVWF  x86
....................           TxD_Buff[20] = read_eeprom(0x12);//Red11_18;     //18
0226A:  MOVFF  FF2,7D8
0226E:  BCF    FF2.7
02270:  CLRF   FAA
02272:  MOVLW  12
02274:  MOVWF  FA9
02276:  BCF    FA6.6
02278:  BCF    FA6.7
0227A:  BSF    FA6.0
0227C:  MOVF   FA8,W
0227E:  MOVLB  7
02280:  BTFSC  xD8.7
02282:  BSF    FF2.7
02284:  MOVLB  0
02286:  MOVWF  x87
....................           TxD_Buff[21] = read_eeprom(0x13);//Red19_20;     //19
02288:  MOVFF  FF2,7D8
0228C:  BCF    FF2.7
0228E:  CLRF   FAA
02290:  MOVLW  13
02292:  MOVWF  FA9
02294:  BCF    FA6.6
02296:  BCF    FA6.7
02298:  BSF    FA6.0
0229A:  MOVF   FA8,W
0229C:  MOVLB  7
0229E:  BTFSC  xD8.7
022A0:  BSF    FF2.7
022A2:  MOVLB  0
022A4:  MOVWF  x88
....................           
....................           TxD_Buff[22] = read_eeprom(0x14);//Green1_8;     //20
022A6:  MOVFF  FF2,7D8
022AA:  BCF    FF2.7
022AC:  CLRF   FAA
022AE:  MOVLW  14
022B0:  MOVWF  FA9
022B2:  BCF    FA6.6
022B4:  BCF    FA6.7
022B6:  BSF    FA6.0
022B8:  MOVF   FA8,W
022BA:  MOVLB  7
022BC:  BTFSC  xD8.7
022BE:  BSF    FF2.7
022C0:  MOVLB  0
022C2:  MOVWF  x89
....................           TxD_Buff[23] = read_eeprom(0x15);//Green9_10;    //21
022C4:  MOVFF  FF2,7D8
022C8:  BCF    FF2.7
022CA:  CLRF   FAA
022CC:  MOVLW  15
022CE:  MOVWF  FA9
022D0:  BCF    FA6.6
022D2:  BCF    FA6.7
022D4:  BSF    FA6.0
022D6:  MOVF   FA8,W
022D8:  MOVLB  7
022DA:  BTFSC  xD8.7
022DC:  BSF    FF2.7
022DE:  MOVLB  0
022E0:  MOVWF  x8A
....................           TxD_Buff[24] = read_eeprom(0x16);//Green11_18;      //22
022E2:  MOVFF  FF2,7D8
022E6:  BCF    FF2.7
022E8:  CLRF   FAA
022EA:  MOVLW  16
022EC:  MOVWF  FA9
022EE:  BCF    FA6.6
022F0:  BCF    FA6.7
022F2:  BSF    FA6.0
022F4:  MOVF   FA8,W
022F6:  MOVLB  7
022F8:  BTFSC  xD8.7
022FA:  BSF    FF2.7
022FC:  MOVLB  0
022FE:  MOVWF  x8B
....................           TxD_Buff[25] = read_eeprom(0x17);//Green19_20;      //23
02300:  MOVFF  FF2,7D8
02304:  BCF    FF2.7
02306:  CLRF   FAA
02308:  MOVLW  17
0230A:  MOVWF  FA9
0230C:  BCF    FA6.6
0230E:  BCF    FA6.7
02310:  BSF    FA6.0
02312:  MOVF   FA8,W
02314:  MOVLB  7
02316:  BTFSC  xD8.7
02318:  BSF    FF2.7
0231A:  MOVLB  0
0231C:  MOVWF  x8C
....................        
....................        
....................          TxD_Buff[26] = AutoAck ;            //24
0231E:  MOVFF  60,8D
....................          TxD_Buff[27] = AutoAckTime ;        //25
02322:  MOVFF  61,8E
....................          TxD_Buff[28] = FlashingRate ;       //26
02326:  MOVFF  62,8F
....................          TxD_Buff[29] = NoOfPoint ;          //27
0232A:  MOVFF  63,90
....................          TxD_Buff[30] = FaultDelayTime ;    //28
0232E:  MOVLW  AD
02330:  MOVWF  x91
....................          TxD_Buff[31] = Address ;            //29
02332:  MOVFF  70,92
.................... 
.................... 
....................          TxD_Buff[32] = FaultDelayTime[1] ;
02336:  MOVFF  7AF,93
....................          TxD_Buff[33] = FaultDelayTime[2] ;
0233A:  MOVFF  7B1,94
....................          TxD_Buff[34] = FaultDelayTime[3] ;
0233E:  MOVFF  7B3,95
....................          TxD_Buff[35] = FaultDelayTime[4] ;
02342:  MOVFF  7B5,96
....................          TxD_Buff[36] = FaultDelayTime[5] ;
02346:  MOVFF  7B7,97
....................          TxD_Buff[37] = FaultDelayTime[6] ;
0234A:  MOVFF  7B9,98
....................          TxD_Buff[38] = FaultDelayTime[7] ;
0234E:  MOVFF  7BB,99
....................          TxD_Buff[39] = FaultDelayTime[8] ;
02352:  MOVFF  7BD,9A
....................          TxD_Buff[40] = FaultDelayTime[9] ;
02356:  MOVFF  7BF,9B
....................          TxD_Buff[41] = FaultDelayTime[10] ;
0235A:  MOVFF  7C1,9C
....................          TxD_Buff[42] = FaultDelayTime[11] ;
0235E:  MOVFF  7C3,9D
....................          TxD_Buff[43] = FaultDelayTime[12] ;
02362:  MOVFF  7C5,9E
....................          TxD_Buff[44] = FaultDelayTime[13] ;
02366:  MOVFF  7C7,9F
....................          TxD_Buff[45] = FaultDelayTime[14] ;
0236A:  MOVFF  7C9,A0
....................          TxD_Buff[46] = FaultDelayTime[15] ;
0236E:  MOVFF  7CB,A1
....................          TxD_Buff[47] = FaultDelayTime[16] ;
02372:  MOVFF  7CD,A2
....................          TxD_Buff[48] = FaultDelayTime[17] ;
02376:  MOVFF  7CF,A3
....................          TxD_Buff[49] = FaultDelayTime[18] ;
0237A:  MOVFF  7D1,A4
....................          TxD_Buff[50] = FaultDelayTime[19] ;
0237E:  MOVFF  7D3,A5
....................          TxD_Buff[51] = FaultDelayTime[20] ;
02382:  MOVFF  7D5,A6
....................          
....................          
....................          CRC(TxD_Buff,52)   ; //Cal CRC 49 byte
02386:  MOVLB  7
02388:  CLRF   xDB
0238A:  MOVLW  73
0238C:  MOVWF  xDA
0238E:  MOVLW  34
02390:  MOVWF  xDC
02392:  MOVLB  0
02394:  RCALL  1F50
.................... 
....................          TxD_Buff[52] = CRC_Hi ;
02396:  MOVFF  374,A7
....................          TxD_Buff[53] = CRC_Lo ;
0239A:  MOVFF  373,A8
.................... 
....................          output_bit(P485ctrl,1);
0239E:  BSF    F8A.3
023A0:  BCF    F93.3
....................          delay_ms(10);
023A2:  MOVLW  0A
023A4:  MOVLB  7
023A6:  MOVWF  xD8
023A8:  MOVLB  0
023AA:  CALL   068A
.................... 
....................          putc(Txd_Buff[0]);
023AE:  MOVF   x73,W
023B0:  RCALL  1FA6
....................          putc(Txd_Buff[1]);
023B2:  MOVF   x74,W
023B4:  RCALL  1FA6
....................          putc(Txd_Buff[2]);
023B6:  MOVF   x75,W
023B8:  RCALL  1FA6
....................          putc(Txd_Buff[3]);
023BA:  MOVF   x76,W
023BC:  RCALL  1FA6
....................          putc(Txd_Buff[4]);
023BE:  MOVF   x77,W
023C0:  RCALL  1FA6
....................          putc(Txd_Buff[5]);
023C2:  MOVF   x78,W
023C4:  RCALL  1FA6
....................          putc(Txd_Buff[6]);
023C6:  MOVF   x79,W
023C8:  RCALL  1FA6
....................          putc(Txd_Buff[7]);
023CA:  MOVF   x7A,W
023CC:  RCALL  1FA6
....................          putc(Txd_Buff[8]);
023CE:  MOVF   x7B,W
023D0:  RCALL  1FA6
....................          putc(Txd_Buff[9]);
023D2:  MOVF   x7C,W
023D4:  RCALL  1FA6
....................          putc(Txd_Buff[10]);
023D6:  MOVF   x7D,W
023D8:  RCALL  1FA6
....................          putc(Txd_Buff[11]);
023DA:  MOVF   x7E,W
023DC:  RCALL  1FA6
....................          putc(Txd_Buff[12]);
023DE:  MOVF   x7F,W
023E0:  RCALL  1FA6
....................          putc(Txd_Buff[13]);
023E2:  MOVF   x80,W
023E4:  RCALL  1FA6
....................          putc(Txd_Buff[14]);
023E6:  MOVF   x81,W
023E8:  RCALL  1FA6
....................          putc(Txd_Buff[15]);
023EA:  MOVF   x82,W
023EC:  RCALL  1FA6
....................          putc(Txd_Buff[16]);
023EE:  MOVF   x83,W
023F0:  RCALL  1FA6
....................          putc(Txd_Buff[17]);
023F2:  MOVF   x84,W
023F4:  RCALL  1FA6
....................          putc(Txd_Buff[18]);
023F6:  MOVF   x85,W
023F8:  RCALL  1FA6
....................          putc(Txd_Buff[19]);
023FA:  MOVF   x86,W
023FC:  RCALL  1FA6
....................          putc(Txd_Buff[20]);
023FE:  MOVF   x87,W
02400:  RCALL  1FA6
....................          putc(Txd_Buff[21]);
02402:  MOVF   x88,W
02404:  RCALL  1FA6
....................          putc(Txd_Buff[22]);
02406:  MOVF   x89,W
02408:  RCALL  1FA6
....................          putc(Txd_Buff[23]);
0240A:  MOVF   x8A,W
0240C:  RCALL  1FA6
....................          putc(Txd_Buff[24]);
0240E:  MOVF   x8B,W
02410:  RCALL  1FA6
....................          putc(Txd_Buff[25]);
02412:  MOVF   x8C,W
02414:  RCALL  1FA6
....................          putc(Txd_Buff[26]);
02416:  MOVF   x8D,W
02418:  RCALL  1FA6
....................          putc(Txd_Buff[27]);
0241A:  MOVF   x8E,W
0241C:  RCALL  1FA6
....................          putc(Txd_Buff[28]);
0241E:  MOVF   x8F,W
02420:  RCALL  1FA6
....................          putc(Txd_Buff[29]);
02422:  MOVF   x90,W
02424:  RCALL  1FA6
....................          putc(Txd_Buff[30]);
02426:  MOVF   x91,W
02428:  RCALL  1FA6
....................          putc(Txd_Buff[31]);
0242A:  MOVF   x92,W
0242C:  RCALL  1FA6
....................          
....................          putc(Txd_Buff[32]);
0242E:  MOVF   x93,W
02430:  RCALL  1FA6
....................          putc(Txd_Buff[33]);
02432:  MOVF   x94,W
02434:  RCALL  1FA6
....................          putc(Txd_Buff[34]);
02436:  MOVF   x95,W
02438:  RCALL  1FA6
....................          putc(Txd_Buff[35]);
0243A:  MOVF   x96,W
0243C:  RCALL  1FA6
....................          putc(Txd_Buff[36]);
0243E:  MOVF   x97,W
02440:  RCALL  1FA6
....................          putc(Txd_Buff[37]);
02442:  MOVF   x98,W
02444:  RCALL  1FA6
....................          putc(Txd_Buff[38]);
02446:  MOVF   x99,W
02448:  RCALL  1FA6
....................          putc(Txd_Buff[39]);
0244A:  MOVF   x9A,W
0244C:  RCALL  1FA6
....................          putc(Txd_Buff[40]);
0244E:  MOVF   x9B,W
02450:  RCALL  1FA6
....................          putc(Txd_Buff[41]);
02452:  MOVF   x9C,W
02454:  RCALL  1FA6
....................          
....................          putc(Txd_Buff[42]);
02456:  MOVF   x9D,W
02458:  RCALL  1FA6
....................          putc(Txd_Buff[43]);
0245A:  MOVF   x9E,W
0245C:  RCALL  1FA6
....................          putc(Txd_Buff[44]);
0245E:  MOVF   x9F,W
02460:  RCALL  1FA6
....................          putc(Txd_Buff[45]);
02462:  MOVF   xA0,W
02464:  RCALL  1FA6
....................          putc(Txd_Buff[46]);
02466:  MOVF   xA1,W
02468:  RCALL  1FA6
....................          putc(Txd_Buff[47]);
0246A:  MOVF   xA2,W
0246C:  RCALL  1FA6
....................          putc(Txd_Buff[48]);
0246E:  MOVF   xA3,W
02470:  RCALL  1FA6
....................          putc(Txd_Buff[49]);
02472:  MOVF   xA4,W
02474:  RCALL  1FA6
....................          putc(Txd_Buff[50]);
02476:  MOVF   xA5,W
02478:  RCALL  1FA6
....................          putc(Txd_Buff[51]);
0247A:  MOVF   xA6,W
0247C:  RCALL  1FA6
....................          
....................          putc(Txd_Buff[52]);
0247E:  MOVF   xA7,W
02480:  RCALL  1FA6
....................          putc(Txd_Buff[53]);
02482:  MOVF   xA8,W
02484:  RCALL  1FA6
....................        
....................          delay_ms(3);
02486:  MOVLW  03
02488:  MOVLB  7
0248A:  MOVWF  xD8
0248C:  MOVLB  0
0248E:  CALL   068A
....................          output_bit(P485ctrl,0);
02492:  BCF    F8A.3
02494:  BCF    F93.3
02496:  MOVLB  1
....................          
....................       }
....................    
....................    
....................    ///////////////////////////////////////////////////////////////
....................       if(RxD_Buff[0] == Address)
02498:  MOVLB  0
0249A:  MOVF   x70,W
0249C:  MOVLB  1
0249E:  SUBWF  x73,W
024A0:  BTFSS  FD8.2
024A2:  GOTO   3F50
....................       {
....................       
....................          if(RxD_Buff[1] == 0x01)///////////// READ COIL /////////////////////
024A6:  DECFSZ x74,W
024A8:  BRA    28C0
....................          {
....................                //Do Read Coil
....................                Start_Address = RxD_Buff[2] ;
024AA:  MOVLB  3
024AC:  CLRF   x78
024AE:  MOVFF  175,377
....................                Start_Address = (Start_Address << 8) | RxD_Buff[3] ;   //Start Address 16 bit
024B2:  MOVFF  377,378
024B6:  MOVLB  7
024B8:  CLRF   xD8
024BA:  MOVF   xD8,W
024BC:  MOVLB  1
024BE:  IORWF  x76,W
024C0:  MOVLB  3
024C2:  MOVWF  x77
024C4:  MOVLB  3
....................                No_PointCount = RxD_Buff[4] ;
024C6:  CLRF   x7A
024C8:  MOVFF  177,379
....................                No_PointCount = (No_PointCount << 8) | RxD_Buff[5] ;      //No. of Point 16 bit
024CC:  MOVFF  379,37A
024D0:  MOVLB  7
024D2:  CLRF   xD8
024D4:  MOVF   xD8,W
024D6:  MOVLB  1
024D8:  IORWF  x78,W
024DA:  MOVLB  3
024DC:  MOVWF  x79
024DE:  MOVLB  3
....................    
....................                if(Start_Address < 0x10 && (Start_Address + No_PointCount) < 0x11)  //Valid point 0-15
024E0:  MOVF   x78,F
024E2:  BTFSS  FD8.2
024E4:  BRA    284E
024E6:  MOVF   x77,W
024E8:  SUBLW  0F
024EA:  BTFSS  FD8.0
024EC:  BRA    284E
024EE:  MOVF   x79,W
024F0:  ADDWF  x77,W
024F2:  MOVLB  7
024F4:  MOVWF  xD8
024F6:  MOVLB  3
024F8:  MOVF   x7A,W
024FA:  ADDWFC x78,W
024FC:  MOVLB  7
024FE:  MOVWF  xD9
02500:  MOVF   xD9,F
02502:  BTFSC  FD8.2
02504:  BRA    250A
02506:  MOVLB  3
02508:  BRA    284E
0250A:  MOVF   xD8,W
0250C:  SUBLW  10
0250E:  BTFSC  FD8.0
02510:  BRA    2516
02512:  MOVLB  3
02514:  BRA    284E
....................                {
....................                   if(No_PointCount < 9) Data_ByteCount = 0x01 ;
02516:  MOVLB  3
02518:  MOVF   x7A,F
0251A:  BNZ   2528
0251C:  MOVF   x79,W
0251E:  SUBLW  08
02520:  BNC   2528
02522:  MOVLW  01
02524:  MOVWF  x7B
02526:  BRA    254C
....................                   else if(No_PointCount < 17) Data_ByteCount = 0x02 ;
02528:  MOVF   x7A,F
0252A:  BNZ   2538
0252C:  MOVF   x79,W
0252E:  SUBLW  10
02530:  BNC   2538
02532:  MOVLW  02
02534:  MOVWF  x7B
02536:  BRA    254C
....................                   else if(No_PointCount < 25) Data_ByteCount = 0x03 ;
02538:  MOVF   x7A,F
0253A:  BNZ   2548
0253C:  MOVF   x79,W
0253E:  SUBLW  18
02540:  BNC   2548
02542:  MOVLW  03
02544:  MOVWF  x7B
02546:  BRA    254C
....................                   else   Data_ByteCount = 0x01 ; //----Jack
02548:  MOVLW  01
0254A:  MOVWF  x7B
....................    
....................                   if(Data_ByteCount == 0x01)
0254C:  DECFSZ x7B,W
0254E:  BRA    2686
....................                   {
....................    
....................                      if(Start_Address < 0x09)
02550:  MOVF   x78,F
02552:  BNZ   256E
02554:  MOVF   x77,W
02556:  SUBLW  08
02558:  BNC   256E
....................                      {
....................                         //Data_Buff[0] = ~output[0] >> Start_Address ;
....................                         //DataTemp = ~output[1] << (0x08 - Start_Address) ;
....................                         //Data_Buff[0] = (~output[0] >> Start_Address) | DataTemp;   //Low Byte
....................                          Data_Buff[0] = Input1_8 >> Start_Address ;
0255A:  MOVFF  4C,37C
0255E:  MOVF   x77,W
02560:  MOVWF  01
02562:  BZ    256C
02564:  BCF    FD8.0
02566:  RRCF   x7C,F
02568:  DECFSZ 01,F
0256A:  BRA    2564
....................                          //DataTemp = Input9_16 << (0x08 - Start_Address) ;//JJ
....................                          //Data_Buff[0] = (Input1_8 >> Start_Address) | DataTemp;   //Low Byte//JJ
....................                      }
0256C:  BRA    25A2
....................                      else if(Start_Address > 0x08 && Start_Address < 0x10)
0256E:  MOVF   x78,F
02570:  BNZ   2578
02572:  MOVF   x77,W
02574:  SUBLW  08
02576:  BC    25A2
02578:  MOVF   x78,F
0257A:  BNZ   25A2
0257C:  MOVF   x77,W
0257E:  SUBLW  0F
02580:  BNC   25A2
....................                      {
....................                         //Data_Buff[0] = ~output[1] >> (Start_Address - 0x08) ;
....................                         Data_Buff[0] = Input9_16 >> (Start_Address - 0x08) ;
02582:  MOVLW  08
02584:  SUBWF  x77,W
02586:  MOVWF  00
02588:  MOVLW  00
0258A:  SUBWFB x78,W
0258C:  MOVWF  03
0258E:  MOVFF  00,01
02592:  MOVFF  34,37C
02596:  MOVF   01,F
02598:  BZ    25A2
0259A:  BCF    FD8.0
0259C:  RRCF   x7C,F
0259E:  DECFSZ 01,F
025A0:  BRA    259A
....................                      }
....................    
....................    
....................                      if(No_PointCount == 0x08)
025A2:  MOVF   x79,W
025A4:  SUBLW  08
025A6:  BNZ   25AE
025A8:  MOVF   x7A,F
025AA:  BNZ   25AE
....................                      {
....................                         Data_Buff[0] = Data_Buff[0] & 0xFF ; //8 Point High Byte
....................                      }
025AC:  BRA    2618
....................                      else if(No_PointCount == 0x07)
025AE:  MOVF   x79,W
025B0:  SUBLW  07
025B2:  BNZ   25BC
025B4:  MOVF   x7A,F
025B6:  BNZ   25BC
....................                      {
....................                         Data_Buff[0] =    Data_Buff[0] & 0x7F ; //7 Point High Byte
025B8:  BCF    x7C.7
....................                      }
025BA:  BRA    2618
....................                      else if(No_PointCount == 0x06)
025BC:  MOVF   x79,W
025BE:  SUBLW  06
025C0:  BNZ   25CC
025C2:  MOVF   x7A,F
025C4:  BNZ   25CC
....................                      {
....................                         Data_Buff[0] =    Data_Buff[0] & 0x3F ; //6 Point High Byte
025C6:  MOVLW  3F
025C8:  ANDWF  x7C,F
....................                      }
025CA:  BRA    2618
....................                      else if(No_PointCount == 0x05)
025CC:  MOVF   x79,W
025CE:  SUBLW  05
025D0:  BNZ   25DC
025D2:  MOVF   x7A,F
025D4:  BNZ   25DC
....................                      {
....................                         Data_Buff[0] =    Data_Buff[0] & 0x1F ; //5 Point High Byte
025D6:  MOVLW  1F
025D8:  ANDWF  x7C,F
....................                      }
025DA:  BRA    2618
....................                      else if(No_PointCount == 0x04)
025DC:  MOVF   x79,W
025DE:  SUBLW  04
025E0:  BNZ   25EC
025E2:  MOVF   x7A,F
025E4:  BNZ   25EC
....................                      {
....................                         Data_Buff[0] =    Data_Buff[0] & 0x0F ; //4 Point High Byte
025E6:  MOVLW  0F
025E8:  ANDWF  x7C,F
....................                      }
025EA:  BRA    2618
....................                      else if(No_PointCount == 0x03)
025EC:  MOVF   x79,W
025EE:  SUBLW  03
025F0:  BNZ   25FC
025F2:  MOVF   x7A,F
025F4:  BNZ   25FC
....................                      {
....................                         Data_Buff[0] =    Data_Buff[0] & 0x07 ; //3 Point High Byte
025F6:  MOVLW  07
025F8:  ANDWF  x7C,F
....................                      }
025FA:  BRA    2618
....................                      else if(No_PointCount == 0x02)
025FC:  MOVF   x79,W
025FE:  SUBLW  02
02600:  BNZ   260C
02602:  MOVF   x7A,F
02604:  BNZ   260C
....................                      {
....................                         Data_Buff[0] =    Data_Buff[0] & 0x03 ; //2 Point High Byte
02606:  MOVLW  03
02608:  ANDWF  x7C,F
....................                      }
0260A:  BRA    2618
....................                      else if(No_PointCount == 0x01)
0260C:  DECFSZ x79,W
0260E:  BRA    2618
02610:  MOVF   x7A,F
02612:  BNZ   2618
....................                      {
....................                         Data_Buff[0] =    Data_Buff[0] & 0x01 ; //1 Point High Byte
02614:  MOVLW  01
02616:  ANDWF  x7C,F
....................                      }
....................    
....................                      TxD_Buff[0] = Address ;         //Address
02618:  MOVFF  70,73
....................                      TxD_Buff[1] = 0x01 ;         //Function Code
0261C:  MOVLW  01
0261E:  MOVLB  0
02620:  MOVWF  x74
....................                      TxD_Buff[2] = Data_ByteCount ;   //Byte Count
02622:  MOVFF  37B,75
....................                      TxD_Buff[3] = Data_Buff[0] ;   //Data
02626:  MOVFF  37C,76
....................    
....................                      CRC(TxD_Buff,4)   ;            //Cal CRC 5 Byte
0262A:  MOVLB  7
0262C:  CLRF   xDB
0262E:  MOVLW  73
02630:  MOVWF  xDA
02632:  MOVLW  04
02634:  MOVWF  xDC
02636:  MOVLB  0
02638:  RCALL  1F50
....................    
....................                      TxD_Buff[4] = CRC_Hi ;
0263A:  MOVFF  374,77
....................                      TxD_Buff[5] = CRC_Lo ;
0263E:  MOVFF  373,78
.................... 
....................                      output_bit(P485ctrl,1);
02642:  BSF    F8A.3
02644:  BCF    F93.3
....................                      restart_wdt();
02646:  CLRWDT
....................                      delay_ms(4);
02648:  MOVLW  04
0264A:  MOVLB  7
0264C:  MOVWF  xD8
0264E:  MOVLB  0
02650:  CALL   068A
....................                      restart_wdt();
02654:  CLRWDT
....................    
....................                      putc(TxD_Buff[0]) ;               //Address
02656:  MOVF   x73,W
02658:  RCALL  1FA6
....................                      putc(TxD_Buff[1]) ;               //Function Code
0265A:  MOVF   x74,W
0265C:  RCALL  1FA6
....................                      putc(TxD_Buff[2]) ;               //Byte Count
0265E:  MOVF   x75,W
02660:  RCALL  1FA6
....................                      putc(TxD_Buff[3]) ;
02662:  MOVF   x76,W
02664:  RCALL  1FA6
....................                      putc(TxD_Buff[4]) ;
02666:  MOVF   x77,W
02668:  RCALL  1FA6
....................                      putc(TxD_Buff[5]) ;
0266A:  MOVF   x78,W
0266C:  RCALL  1FA6
....................                   
....................                      restart_wdt();
0266E:  CLRWDT
....................                      delay_ms(3);
02670:  MOVLW  03
02672:  MOVLB  7
02674:  MOVWF  xD8
02676:  MOVLB  0
02678:  CALL   068A
....................                      restart_wdt();
0267C:  CLRWDT
....................                      output_bit(P485ctrl,0);
0267E:  BCF    F8A.3
02680:  BCF    F93.3
....................                  
....................                   }
02682:  BRA    284A
02684:  MOVLB  3
....................                   else if(Data_ByteCount == 0x02)
02686:  MOVF   x7B,W
02688:  SUBLW  02
0268A:  BTFSS  FD8.2
0268C:  BRA    284C
....................                   {
....................                      Data_Buff[0] = Input1_8 >> Start_Address ;
0268E:  MOVFF  4C,37C
02692:  MOVF   x77,W
02694:  MOVWF  01
02696:  BZ    26A0
02698:  BCF    FD8.0
0269A:  RRCF   x7C,F
0269C:  DECFSZ 01,F
0269E:  BRA    2698
....................                      Data_Buff[1] = Input9_10 ;// >> Start_Address ;
026A0:  MOVFF  4D,37D
....................    
....................    
....................                      if((No_PointCount - 0x07) == 0x08)
026A4:  MOVLW  07
026A6:  SUBWF  x79,W
026A8:  MOVLB  7
026AA:  MOVWF  xD8
026AC:  MOVLW  00
026AE:  MOVLB  3
026B0:  SUBWFB x7A,W
026B2:  MOVLB  7
026B4:  MOVWF  xD9
026B6:  MOVF   xD8,W
026B8:  SUBLW  08
026BA:  BNZ   26C2
026BC:  MOVF   xD9,F
026BE:  BNZ   26C2
....................                      {
....................                         Data_Buff[1] = Data_Buff[1] & 0xFF ; //16 Point High Byte
....................                      }
026C0:  BRA    27C8
....................                      else if((No_PointCount - 0x07) == 0x07)
026C2:  MOVLW  07
026C4:  MOVLB  3
026C6:  SUBWF  x79,W
026C8:  MOVLB  7
026CA:  MOVWF  xD8
026CC:  MOVLW  00
026CE:  MOVLB  3
026D0:  SUBWFB x7A,W
026D2:  MOVLB  7
026D4:  MOVWF  xD9
026D6:  MOVF   xD8,W
026D8:  SUBLW  07
026DA:  BNZ   26E6
026DC:  MOVF   xD9,F
026DE:  BNZ   26E6
....................                      {
....................                         Data_Buff[1] =    Data_Buff[1] & 0x7F ; //15 Point High Byte
026E0:  MOVLB  3
026E2:  BCF    x7D.7
....................                      }
026E4:  BRA    27C6
....................                      else if((No_PointCount - 0x07) == 0x06)
026E6:  MOVLW  07
026E8:  MOVLB  3
026EA:  SUBWF  x79,W
026EC:  MOVLB  7
026EE:  MOVWF  xD8
026F0:  MOVLW  00
026F2:  MOVLB  3
026F4:  SUBWFB x7A,W
026F6:  MOVLB  7
026F8:  MOVWF  xD9
026FA:  MOVF   xD8,W
026FC:  SUBLW  06
026FE:  BNZ   270C
02700:  MOVF   xD9,F
02702:  BNZ   270C
....................                      {
....................                         Data_Buff[1] =    Data_Buff[1] & 0x3F ; //14 Point High Byte
02704:  MOVLW  3F
02706:  MOVLB  3
02708:  ANDWF  x7D,F
....................                      }
0270A:  BRA    27C6
....................                      else if((No_PointCount - 0x07) == 0x05)
0270C:  MOVLW  07
0270E:  MOVLB  3
02710:  SUBWF  x79,W
02712:  MOVLB  7
02714:  MOVWF  xD8
02716:  MOVLW  00
02718:  MOVLB  3
0271A:  SUBWFB x7A,W
0271C:  MOVLB  7
0271E:  MOVWF  xD9
02720:  MOVF   xD8,W
02722:  SUBLW  05
02724:  BNZ   2732
02726:  MOVF   xD9,F
02728:  BNZ   2732
....................                      {
....................                         Data_Buff[1] =    Data_Buff[1] & 0x1F ; //13 Point High Byte
0272A:  MOVLW  1F
0272C:  MOVLB  3
0272E:  ANDWF  x7D,F
....................                      }
02730:  BRA    27C6
....................                      else if((No_PointCount - 0x07) == 0x04)
02732:  MOVLW  07
02734:  MOVLB  3
02736:  SUBWF  x79,W
02738:  MOVLB  7
0273A:  MOVWF  xD8
0273C:  MOVLW  00
0273E:  MOVLB  3
02740:  SUBWFB x7A,W
02742:  MOVLB  7
02744:  MOVWF  xD9
02746:  MOVF   xD8,W
02748:  SUBLW  04
0274A:  BNZ   2758
0274C:  MOVF   xD9,F
0274E:  BNZ   2758
....................                      {
....................                         Data_Buff[1] =    Data_Buff[1] & 0x0F ; //12 Point High Byte
02750:  MOVLW  0F
02752:  MOVLB  3
02754:  ANDWF  x7D,F
....................                      }
02756:  BRA    27C6
....................                      else if((No_PointCount - 0x07) == 0x03)
02758:  MOVLW  07
0275A:  MOVLB  3
0275C:  SUBWF  x79,W
0275E:  MOVLB  7
02760:  MOVWF  xD8
02762:  MOVLW  00
02764:  MOVLB  3
02766:  SUBWFB x7A,W
02768:  MOVLB  7
0276A:  MOVWF  xD9
0276C:  MOVF   xD8,W
0276E:  SUBLW  03
02770:  BNZ   277E
02772:  MOVF   xD9,F
02774:  BNZ   277E
....................                      {
....................                         Data_Buff[1] =    Data_Buff[1] & 0x07 ; //11 Point High Byte
02776:  MOVLW  07
02778:  MOVLB  3
0277A:  ANDWF  x7D,F
....................                      }
0277C:  BRA    27C6
....................                      else if((No_PointCount - 0x07) == 0x02)
0277E:  MOVLW  07
02780:  MOVLB  3
02782:  SUBWF  x79,W
02784:  MOVLB  7
02786:  MOVWF  xD8
02788:  MOVLW  00
0278A:  MOVLB  3
0278C:  SUBWFB x7A,W
0278E:  MOVLB  7
02790:  MOVWF  xD9
02792:  MOVF   xD8,W
02794:  SUBLW  02
02796:  BNZ   27A4
02798:  MOVF   xD9,F
0279A:  BNZ   27A4
....................                      {
....................                         Data_Buff[1] =    Data_Buff[1] & 0x03 ; //10 Point High Byte
0279C:  MOVLW  03
0279E:  MOVLB  3
027A0:  ANDWF  x7D,F
....................                      }
027A2:  BRA    27C6
....................                      else if((No_PointCount - 0x07) == 0x01)
027A4:  MOVLW  07
027A6:  MOVLB  3
027A8:  SUBWF  x79,W
027AA:  MOVLB  7
027AC:  MOVWF  xD8
027AE:  MOVLW  00
027B0:  MOVLB  3
027B2:  SUBWFB x7A,W
027B4:  MOVLB  7
027B6:  MOVWF  xD9
027B8:  DECFSZ xD8,W
027BA:  BRA    27C8
027BC:  MOVF   xD9,F
027BE:  BNZ   27C8
....................                      {
....................                         Data_Buff[1] =    Data_Buff[1] & 0x01 ; //9 Point High Byte
027C0:  MOVLW  01
027C2:  MOVLB  3
027C4:  ANDWF  x7D,F
027C6:  MOVLB  7
....................                      }
....................    
....................                      TxD_Buff[0] = Address ;         //Address
027C8:  MOVFF  70,73
....................                      TxD_Buff[1] = 0x01 ;         //Function Code
027CC:  MOVLW  01
027CE:  MOVLB  0
027D0:  MOVWF  x74
....................                      TxD_Buff[2] = Data_ByteCount ;   //Byte Count
027D2:  MOVFF  37B,75
....................                      TxD_Buff[3] = Data_Buff[0] ;      //first byte Data
027D6:  MOVFF  37C,76
....................                      TxD_Buff[4] = Data_Buff[1] ;      //second byte Data
027DA:  MOVFF  37D,77
....................    
....................                      CRC(TxD_Buff,5)   ;            //Cal CRC 5 Byte
027DE:  MOVLB  7
027E0:  CLRF   xDB
027E2:  MOVLW  73
027E4:  MOVWF  xDA
027E6:  MOVLW  05
027E8:  MOVWF  xDC
027EA:  MOVLB  0
027EC:  CALL   1F50
....................    
....................                      TxD_Buff[5] = CRC_Hi ;
027F0:  MOVFF  374,78
....................                      TxD_Buff[6] = CRC_Lo ;
027F4:  MOVFF  373,79
.................... 
....................                      output_bit(P485ctrl,1);
027F8:  BSF    F8A.3
027FA:  BCF    F93.3
....................                      restart_wdt();
027FC:  CLRWDT
....................                      delay_ms(4);
027FE:  MOVLW  04
02800:  MOVLB  7
02802:  MOVWF  xD8
02804:  MOVLB  0
02806:  CALL   068A
....................                      restart_wdt();
0280A:  CLRWDT
....................    
....................                      putc(TxD_Buff[0]) ;               //Address
0280C:  MOVF   x73,W
0280E:  CALL   1FA6
....................                      putc(TxD_Buff[1]) ;               //Function Code
02812:  MOVF   x74,W
02814:  CALL   1FA6
....................                      putc(TxD_Buff[2]) ;               //Byte Count
02818:  MOVF   x75,W
0281A:  CALL   1FA6
....................                      putc(TxD_Buff[3]) ;
0281E:  MOVF   x76,W
02820:  CALL   1FA6
....................                      putc(TxD_Buff[4]) ;
02824:  MOVF   x77,W
02826:  CALL   1FA6
....................                      putc(TxD_Buff[5]) ;
0282A:  MOVF   x78,W
0282C:  CALL   1FA6
....................                      putc(TxD_Buff[6]) ;
02830:  MOVF   x79,W
02832:  CALL   1FA6
....................    
....................                      restart_wdt();
02836:  CLRWDT
....................                      delay_ms(3);
02838:  MOVLW  03
0283A:  MOVLB  7
0283C:  MOVWF  xD8
0283E:  MOVLB  0
02840:  CALL   068A
....................                      restart_wdt();
02844:  CLRWDT
....................                      output_bit(P485ctrl,0);
02846:  BCF    F8A.3
02848:  BCF    F93.3
0284A:  MOVLB  3
....................                  
....................                   }
....................                }
0284C:  BRA    28BE
....................                else
....................                {
....................                   //invalid parameter
....................                   TxD_Buff[0] = Address ;         //Address
0284E:  MOVFF  70,73
....................                   TxD_Buff[1] = 0x81 ;         //Function Code
02852:  MOVLW  81
02854:  MOVLB  0
02856:  MOVWF  x74
....................                   TxD_Buff[2] = 0x02 ;         //illegal data address
02858:  MOVLW  02
0285A:  MOVWF  x75
....................    
....................                   CRC(TxD_Buff,3)   ;            //Cal CRC 3 Byte
0285C:  MOVLB  7
0285E:  CLRF   xDB
02860:  MOVLW  73
02862:  MOVWF  xDA
02864:  MOVLW  03
02866:  MOVWF  xDC
02868:  MOVLB  0
0286A:  CALL   1F50
....................    
....................                   TxD_Buff[3] = CRC_Hi ;
0286E:  MOVFF  374,76
....................                   TxD_Buff[4] = CRC_Lo ;
02872:  MOVFF  373,77
.................... 
....................                   output_bit(P485ctrl,1);
02876:  BSF    F8A.3
02878:  BCF    F93.3
....................                   restart_wdt();
0287A:  CLRWDT
....................                   delay_ms(4);
0287C:  MOVLW  04
0287E:  MOVLB  7
02880:  MOVWF  xD8
02882:  MOVLB  0
02884:  CALL   068A
....................                   restart_wdt();
02888:  CLRWDT
....................    
....................                   putc(TxD_Buff[0]) ;               //Address
0288A:  MOVF   x73,W
0288C:  CALL   1FA6
....................                   putc(TxD_Buff[1]) ;               //Function Code
02890:  MOVF   x74,W
02892:  CALL   1FA6
....................                   putc(TxD_Buff[2]) ;               //Byte Count
02896:  MOVF   x75,W
02898:  CALL   1FA6
....................                   putc(TxD_Buff[3]) ;
0289C:  MOVF   x76,W
0289E:  CALL   1FA6
....................                   putc(TxD_Buff[4]) ;
028A2:  MOVF   x77,W
028A4:  CALL   1FA6
....................    
....................                   restart_wdt();
028A8:  CLRWDT
....................                   delay_ms(3);
028AA:  MOVLW  03
028AC:  MOVLB  7
028AE:  MOVWF  xD8
028B0:  MOVLB  0
028B2:  CALL   068A
....................                   restart_wdt();
028B6:  CLRWDT
....................                   output_bit(P485ctrl,0);
028B8:  BCF    F8A.3
028BA:  BCF    F93.3
028BC:  MOVLB  3
028BE:  MOVLB  1
....................                   
....................                }
....................             }
.................... 
.................... 
....................               /*-------------jack----*/
....................  
....................       if(RxD_Buff[1] == 0x07)///////////// READ COIL (esp code)////////////
028C0:  MOVF   x74,W
028C2:  SUBLW  07
028C4:  BTFSS  FD8.2
028C6:  BRA    2A2A
....................       {
....................          alarmtosend();
028C8:  MOVLB  0
028CA:  GOTO   1FAE
....................          
....................          disable_interrupts(INT_TIMER2);
028CE:  BCF    F9D.1
....................          //----------------------------------jj----------------------------//
....................          
....................             Data_Buff[0] = Input1_8_Send ; //>> Start_Address ;
028D0:  MOVFF  20,37C
....................             Data_Buff[1] = Input9_16_Send ;// >> Start_Address ;
028D4:  MOVFF  21,37D
....................             Data_Buff[2] = Input17_24_Send ;// >> Start_Address ;
028D8:  MOVFF  22,37E
....................             Data_Buff[3] = Input25_32_Send ;
028DC:  MOVFF  23,37F
....................             Data_Buff[4] = Input33_40_Send ;
028E0:  MOVFF  24,380
....................             Data_Buff[5] = Input41_48_Send ;
028E4:  MOVFF  25,381
....................             Data_Buff[6] = Input49_56_Send ;
028E8:  MOVFF  26,382
....................             Data_Buff[7] = Input57_64_Send ;
028EC:  MOVFF  27,383
....................            
....................             Data_Buff[8] = Ack1_8_Send ;
028F0:  MOVFF  28,384
....................             Data_Buff[9] = Ack9_16_Send ;
028F4:  MOVFF  29,385
....................             Data_Buff[10] = Ack17_24_Send ;
028F8:  MOVFF  2A,386
....................             Data_Buff[11] = Ack25_32_Send ;
028FC:  MOVFF  2B,387
....................             Data_Buff[12] = Ack33_40_Send ;
02900:  MOVFF  2C,388
....................             Data_Buff[13] = Ack41_48_Send ;
02904:  MOVFF  2D,389
....................             Data_Buff[14] = Ack49_56_Send ;
02908:  MOVFF  2E,38A
....................             Data_Buff[15] = Ack57_64_Send ;
0290C:  MOVFF  2F,38B
....................    
....................             
....................             
....................             TxD_Buff[0] = Address ;         //Address
02910:  MOVFF  70,73
....................             TxD_Buff[1] = 0x07 ;         //Function Code
02914:  MOVLW  07
02916:  MOVWF  x74
....................             TxD_Buff[2] = Data_ByteCount=0x10;   //Byte Count
02918:  MOVLW  10
0291A:  MOVLB  3
0291C:  MOVWF  x7B
0291E:  MOVFF  37B,75
....................             TxD_Buff[3] = Data_Buff[0] ;      //first byte Data
02922:  MOVFF  37C,76
....................             TxD_Buff[4] = Data_Buff[1] ;      //second byte Data
02926:  MOVFF  37D,77
....................             TxD_Buff[5] = Data_Buff[2] ;  
0292A:  MOVFF  37E,78
....................             TxD_Buff[6] = Data_Buff[3] ;
0292E:  MOVFF  37F,79
....................             TxD_Buff[7] = Data_Buff[4] ;
02932:  MOVFF  380,7A
....................             TxD_Buff[8] = Data_Buff[5] ;
02936:  MOVFF  381,7B
....................             TxD_Buff[9] = Data_Buff[6] ;
0293A:  MOVFF  382,7C
....................             TxD_Buff[10] = Data_Buff[7] ;
0293E:  MOVFF  383,7D
....................               
....................            TxD_Buff[11] = Data_Buff[8] ; //Ack1-8
02942:  MOVFF  384,7E
....................            TxD_Buff[12] = Data_Buff[9] ;
02946:  MOVFF  385,7F
....................            TxD_Buff[13] = Data_Buff[10] ;
0294A:  MOVFF  386,80
....................            TxD_Buff[14] = Data_Buff[11] ;
0294E:  MOVFF  387,81
....................            TxD_Buff[15] = Data_Buff[12] ;
02952:  MOVFF  388,82
....................            TxD_Buff[16] = Data_Buff[13] ;
02956:  MOVFF  389,83
....................            TxD_Buff[17] = Data_Buff[14] ;
0295A:  MOVFF  38A,84
....................            TxD_Buff[18] = Data_Buff[15] ; //Ack57-64
0295E:  MOVFF  38B,85
.................... 
....................            CRC(TxD_Buff,19);            //Cal CRC 5 Byte
02962:  MOVLB  7
02964:  CLRF   xDB
02966:  MOVLW  73
02968:  MOVWF  xDA
0296A:  MOVLW  13
0296C:  MOVWF  xDC
0296E:  MOVLB  0
02970:  CALL   1F50
.................... 
....................           TxD_Buff[19] = CRC_Hi ;
02974:  MOVFF  374,86
....................           TxD_Buff[20] = CRC_Lo ;
02978:  MOVFF  373,87
.................... 
....................         
....................          output_bit(P485ctrl,1);
0297C:  BSF    F8A.3
0297E:  BCF    F93.3
....................          restart_wdt();
02980:  CLRWDT
....................          delay_ms(4);
02982:  MOVLW  04
02984:  MOVLB  7
02986:  MOVWF  xD8
02988:  MOVLB  0
0298A:  CALL   068A
....................          restart_wdt();
0298E:  CLRWDT
....................          
....................          
....................          
....................          putc(TxD_Buff[0]) ;               //Address
02990:  MOVF   x73,W
02992:  CALL   1FA6
....................          putc(TxD_Buff[1]) ;               //Function Code
02996:  MOVF   x74,W
02998:  CALL   1FA6
....................          putc(TxD_Buff[2]) ;               //Byte Count
0299C:  MOVF   x75,W
0299E:  CALL   1FA6
....................          putc(TxD_Buff[3]) ;
029A2:  MOVF   x76,W
029A4:  CALL   1FA6
....................          putc(TxD_Buff[4]) ;
029A8:  MOVF   x77,W
029AA:  CALL   1FA6
....................          putc(TxD_Buff[5]) ;
029AE:  MOVF   x78,W
029B0:  CALL   1FA6
....................          putc(TxD_Buff[6]) ;
029B4:  MOVF   x79,W
029B6:  CALL   1FA6
....................          putc(TxD_Buff[7]) ;
029BA:  MOVF   x7A,W
029BC:  CALL   1FA6
....................          putc(TxD_Buff[8]) ;
029C0:  MOVF   x7B,W
029C2:  CALL   1FA6
....................          putc(TxD_Buff[9]) ;
029C6:  MOVF   x7C,W
029C8:  CALL   1FA6
....................          putc(TxD_Buff[10]) ;
029CC:  MOVF   x7D,W
029CE:  CALL   1FA6
....................          putc(TxD_Buff[11]) ;
029D2:  MOVF   x7E,W
029D4:  CALL   1FA6
....................          putc(TxD_Buff[12]) ;
029D8:  MOVF   x7F,W
029DA:  CALL   1FA6
....................          putc(TxD_Buff[13]) ;
029DE:  MOVF   x80,W
029E0:  CALL   1FA6
....................          putc(TxD_Buff[14]) ;
029E4:  MOVF   x81,W
029E6:  CALL   1FA6
....................          putc(TxD_Buff[15]) ;
029EA:  MOVF   x82,W
029EC:  CALL   1FA6
....................          putc(TxD_Buff[16]) ;
029F0:  MOVF   x83,W
029F2:  CALL   1FA6
....................          putc(TxD_Buff[17]) ;
029F6:  MOVF   x84,W
029F8:  CALL   1FA6
....................          putc(TxD_Buff[18]) ;
029FC:  MOVF   x85,W
029FE:  CALL   1FA6
....................          putc(TxD_Buff[19]) ;
02A02:  MOVF   x86,W
02A04:  CALL   1FA6
....................          putc(TxD_Buff[20]) ;
02A08:  MOVF   x87,W
02A0A:  CALL   1FA6
.................... 
....................          restart_wdt();
02A0E:  CLRWDT
....................          delay_ms(3);
02A10:  MOVLW  03
02A12:  MOVLB  7
02A14:  MOVWF  xD8
02A16:  MOVLB  0
02A18:  CALL   068A
....................          restart_wdt();
02A1C:  CLRWDT
....................          output_bit(P485ctrl,0);
02A1E:  BCF    F8A.3
02A20:  BCF    F93.3
....................            
....................         
....................          /////////////////////////////////////////
....................          
....................         enable_interrupts(INT_TIMER2); 
02A22:  BSF    F9D.1
....................      
....................        }
02A24:  GOTO   3EBC
02A28:  MOVLB  1
....................      
....................          else if(RxD_Buff[1] == 0x21)///////////// WRITE SETTING /////////////////////
02A2A:  MOVF   x74,W
02A2C:  SUBLW  21
02A2E:  BTFSS  FD8.2
02A30:  GOTO   3398
....................          {
.................... 
....................             write_eeprom(0x00,0x0F);
02A34:  MOVF   FF2,W
02A36:  MOVWF  00
02A38:  BCF    FF2.7
02A3A:  CLRF   FAA
02A3C:  CLRF   FA9
02A3E:  MOVLW  0F
02A40:  MOVWF  FA8
02A42:  BCF    FA6.6
02A44:  BCF    FA6.7
02A46:  BSF    FA6.2
02A48:  MOVLB  F
02A4A:  MOVLW  55
02A4C:  MOVWF  FA7
02A4E:  MOVLW  AA
02A50:  MOVWF  FA7
02A52:  BSF    FA6.1
02A54:  BTFSC  FA6.1
02A56:  BRA    2A54
02A58:  BCF    FA6.2
02A5A:  MOVF   00,W
02A5C:  IORWF  FF2,F
.................... 
....................             write_eeprom(0x01,RxD_Buff[3]);   //Input Type
02A5E:  MOVFF  FF2,00
02A62:  BCF    FF2.7
02A64:  CLRF   FAA
02A66:  MOVLW  01
02A68:  MOVWF  FA9
02A6A:  MOVFF  176,FA8
02A6E:  BCF    FA6.6
02A70:  BCF    FA6.7
02A72:  BSF    FA6.2
02A74:  MOVLW  55
02A76:  MOVWF  FA7
02A78:  MOVLW  AA
02A7A:  MOVWF  FA7
02A7C:  BSF    FA6.1
02A7E:  BTFSC  FA6.1
02A80:  BRA    2A7E
02A82:  BCF    FA6.2
02A84:  MOVF   00,W
02A86:  IORWF  FF2,F
....................             write_eeprom(0x02,RxD_Buff[4]);
02A88:  MOVFF  FF2,00
02A8C:  BCF    FF2.7
02A8E:  CLRF   FAA
02A90:  MOVLW  02
02A92:  MOVWF  FA9
02A94:  MOVFF  177,FA8
02A98:  BCF    FA6.6
02A9A:  BCF    FA6.7
02A9C:  BSF    FA6.2
02A9E:  MOVLW  55
02AA0:  MOVWF  FA7
02AA2:  MOVLW  AA
02AA4:  MOVWF  FA7
02AA6:  BSF    FA6.1
02AA8:  BTFSC  FA6.1
02AAA:  BRA    2AA8
02AAC:  BCF    FA6.2
02AAE:  MOVF   00,W
02AB0:  IORWF  FF2,F
....................             write_eeprom(0x03,RxD_Buff[5]);
02AB2:  MOVFF  FF2,00
02AB6:  BCF    FF2.7
02AB8:  CLRF   FAA
02ABA:  MOVLW  03
02ABC:  MOVWF  FA9
02ABE:  MOVFF  178,FA8
02AC2:  BCF    FA6.6
02AC4:  BCF    FA6.7
02AC6:  BSF    FA6.2
02AC8:  MOVLW  55
02ACA:  MOVWF  FA7
02ACC:  MOVLW  AA
02ACE:  MOVWF  FA7
02AD0:  BSF    FA6.1
02AD2:  BTFSC  FA6.1
02AD4:  BRA    2AD2
02AD6:  BCF    FA6.2
02AD8:  MOVF   00,W
02ADA:  IORWF  FF2,F
.................... 
....................             write_eeprom(0x04,RxD_Buff[6]);   //Fault Type
02ADC:  MOVFF  FF2,00
02AE0:  BCF    FF2.7
02AE2:  CLRF   FAA
02AE4:  MOVLW  04
02AE6:  MOVWF  FA9
02AE8:  MOVFF  179,FA8
02AEC:  BCF    FA6.6
02AEE:  BCF    FA6.7
02AF0:  BSF    FA6.2
02AF2:  MOVLW  55
02AF4:  MOVWF  FA7
02AF6:  MOVLW  AA
02AF8:  MOVWF  FA7
02AFA:  BSF    FA6.1
02AFC:  BTFSC  FA6.1
02AFE:  BRA    2AFC
02B00:  BCF    FA6.2
02B02:  MOVF   00,W
02B04:  IORWF  FF2,F
....................             write_eeprom(0x05,RxD_Buff[7]);
02B06:  MOVFF  FF2,00
02B0A:  BCF    FF2.7
02B0C:  CLRF   FAA
02B0E:  MOVLW  05
02B10:  MOVWF  FA9
02B12:  MOVFF  17A,FA8
02B16:  BCF    FA6.6
02B18:  BCF    FA6.7
02B1A:  BSF    FA6.2
02B1C:  MOVLW  55
02B1E:  MOVWF  FA7
02B20:  MOVLW  AA
02B22:  MOVWF  FA7
02B24:  BSF    FA6.1
02B26:  BTFSC  FA6.1
02B28:  BRA    2B26
02B2A:  BCF    FA6.2
02B2C:  MOVF   00,W
02B2E:  IORWF  FF2,F
....................             write_eeprom(0x06,RxD_Buff[8]);
02B30:  MOVFF  FF2,00
02B34:  BCF    FF2.7
02B36:  CLRF   FAA
02B38:  MOVLW  06
02B3A:  MOVWF  FA9
02B3C:  MOVFF  17B,FA8
02B40:  BCF    FA6.6
02B42:  BCF    FA6.7
02B44:  BSF    FA6.2
02B46:  MOVLW  55
02B48:  MOVWF  FA7
02B4A:  MOVLW  AA
02B4C:  MOVWF  FA7
02B4E:  BSF    FA6.1
02B50:  BTFSC  FA6.1
02B52:  BRA    2B50
02B54:  BCF    FA6.2
02B56:  MOVF   00,W
02B58:  IORWF  FF2,F
.................... 
....................             write_eeprom(0x07,RxD_Buff[9]);   //Output Type
02B5A:  MOVFF  FF2,00
02B5E:  BCF    FF2.7
02B60:  CLRF   FAA
02B62:  MOVLW  07
02B64:  MOVWF  FA9
02B66:  MOVFF  17C,FA8
02B6A:  BCF    FA6.6
02B6C:  BCF    FA6.7
02B6E:  BSF    FA6.2
02B70:  MOVLW  55
02B72:  MOVWF  FA7
02B74:  MOVLW  AA
02B76:  MOVWF  FA7
02B78:  BSF    FA6.1
02B7A:  BTFSC  FA6.1
02B7C:  BRA    2B7A
02B7E:  BCF    FA6.2
02B80:  MOVF   00,W
02B82:  IORWF  FF2,F
....................             write_eeprom(0x08,RxD_Buff[10]);
02B84:  MOVFF  FF2,00
02B88:  BCF    FF2.7
02B8A:  CLRF   FAA
02B8C:  MOVLW  08
02B8E:  MOVWF  FA9
02B90:  MOVFF  17D,FA8
02B94:  BCF    FA6.6
02B96:  BCF    FA6.7
02B98:  BSF    FA6.2
02B9A:  MOVLW  55
02B9C:  MOVWF  FA7
02B9E:  MOVLW  AA
02BA0:  MOVWF  FA7
02BA2:  BSF    FA6.1
02BA4:  BTFSC  FA6.1
02BA6:  BRA    2BA4
02BA8:  BCF    FA6.2
02BAA:  MOVF   00,W
02BAC:  IORWF  FF2,F
....................             write_eeprom(0x09,RxD_Buff[11]);
02BAE:  MOVFF  FF2,00
02BB2:  BCF    FF2.7
02BB4:  CLRF   FAA
02BB6:  MOVLW  09
02BB8:  MOVWF  FA9
02BBA:  MOVFF  17E,FA8
02BBE:  BCF    FA6.6
02BC0:  BCF    FA6.7
02BC2:  BSF    FA6.2
02BC4:  MOVLW  55
02BC6:  MOVWF  FA7
02BC8:  MOVLW  AA
02BCA:  MOVWF  FA7
02BCC:  BSF    FA6.1
02BCE:  BTFSC  FA6.1
02BD0:  BRA    2BCE
02BD2:  BCF    FA6.2
02BD4:  MOVF   00,W
02BD6:  IORWF  FF2,F
.................... 
....................             write_eeprom(0x0A,RxD_Buff[12]);   //Output Both
02BD8:  MOVFF  FF2,00
02BDC:  BCF    FF2.7
02BDE:  CLRF   FAA
02BE0:  MOVLW  0A
02BE2:  MOVWF  FA9
02BE4:  MOVFF  17F,FA8
02BE8:  BCF    FA6.6
02BEA:  BCF    FA6.7
02BEC:  BSF    FA6.2
02BEE:  MOVLW  55
02BF0:  MOVWF  FA7
02BF2:  MOVLW  AA
02BF4:  MOVWF  FA7
02BF6:  BSF    FA6.1
02BF8:  BTFSC  FA6.1
02BFA:  BRA    2BF8
02BFC:  BCF    FA6.2
02BFE:  MOVF   00,W
02C00:  IORWF  FF2,F
....................             write_eeprom(0x0B,RxD_Buff[13]);
02C02:  MOVFF  FF2,00
02C06:  BCF    FF2.7
02C08:  CLRF   FAA
02C0A:  MOVLW  0B
02C0C:  MOVWF  FA9
02C0E:  MOVFF  180,FA8
02C12:  BCF    FA6.6
02C14:  BCF    FA6.7
02C16:  BSF    FA6.2
02C18:  MOVLW  55
02C1A:  MOVWF  FA7
02C1C:  MOVLW  AA
02C1E:  MOVWF  FA7
02C20:  BSF    FA6.1
02C22:  BTFSC  FA6.1
02C24:  BRA    2C22
02C26:  BCF    FA6.2
02C28:  MOVF   00,W
02C2A:  IORWF  FF2,F
....................             write_eeprom(0x0C,RxD_Buff[14]);
02C2C:  MOVFF  FF2,00
02C30:  BCF    FF2.7
02C32:  CLRF   FAA
02C34:  MOVLW  0C
02C36:  MOVWF  FA9
02C38:  MOVFF  181,FA8
02C3C:  BCF    FA6.6
02C3E:  BCF    FA6.7
02C40:  BSF    FA6.2
02C42:  MOVLW  55
02C44:  MOVWF  FA7
02C46:  MOVLW  AA
02C48:  MOVWF  FA7
02C4A:  BSF    FA6.1
02C4C:  BTFSC  FA6.1
02C4E:  BRA    2C4C
02C50:  BCF    FA6.2
02C52:  MOVF   00,W
02C54:  IORWF  FF2,F
.................... 
....................             write_eeprom(0x0D,RxD_Buff[15]);   //Alarm / Indicator
02C56:  MOVFF  FF2,00
02C5A:  BCF    FF2.7
02C5C:  CLRF   FAA
02C5E:  MOVLW  0D
02C60:  MOVWF  FA9
02C62:  MOVFF  182,FA8
02C66:  BCF    FA6.6
02C68:  BCF    FA6.7
02C6A:  BSF    FA6.2
02C6C:  MOVLW  55
02C6E:  MOVWF  FA7
02C70:  MOVLW  AA
02C72:  MOVWF  FA7
02C74:  BSF    FA6.1
02C76:  BTFSC  FA6.1
02C78:  BRA    2C76
02C7A:  BCF    FA6.2
02C7C:  MOVF   00,W
02C7E:  IORWF  FF2,F
....................             write_eeprom(0x0E,RxD_Buff[16]);
02C80:  MOVFF  FF2,00
02C84:  BCF    FF2.7
02C86:  CLRF   FAA
02C88:  MOVLW  0E
02C8A:  MOVWF  FA9
02C8C:  MOVFF  183,FA8
02C90:  BCF    FA6.6
02C92:  BCF    FA6.7
02C94:  BSF    FA6.2
02C96:  MOVLW  55
02C98:  MOVWF  FA7
02C9A:  MOVLW  AA
02C9C:  MOVWF  FA7
02C9E:  BSF    FA6.1
02CA0:  BTFSC  FA6.1
02CA2:  BRA    2CA0
02CA4:  BCF    FA6.2
02CA6:  MOVF   00,W
02CA8:  IORWF  FF2,F
....................             write_eeprom(0x0F,RxD_Buff[17]);
02CAA:  MOVFF  FF2,00
02CAE:  BCF    FF2.7
02CB0:  CLRF   FAA
02CB2:  MOVLW  0F
02CB4:  MOVWF  FA9
02CB6:  MOVFF  184,FA8
02CBA:  BCF    FA6.6
02CBC:  BCF    FA6.7
02CBE:  BSF    FA6.2
02CC0:  MOVLW  55
02CC2:  MOVWF  FA7
02CC4:  MOVLW  AA
02CC6:  MOVWF  FA7
02CC8:  BSF    FA6.1
02CCA:  BTFSC  FA6.1
02CCC:  BRA    2CCA
02CCE:  BCF    FA6.2
02CD0:  MOVF   00,W
02CD2:  IORWF  FF2,F
....................          
....................             // LED Colour Config
....................             write_eeprom(0x10,RxD_Buff[18]); //Red1_8
02CD4:  MOVFF  FF2,00
02CD8:  BCF    FF2.7
02CDA:  CLRF   FAA
02CDC:  MOVLW  10
02CDE:  MOVWF  FA9
02CE0:  MOVFF  185,FA8
02CE4:  BCF    FA6.6
02CE6:  BCF    FA6.7
02CE8:  BSF    FA6.2
02CEA:  MOVLW  55
02CEC:  MOVWF  FA7
02CEE:  MOVLW  AA
02CF0:  MOVWF  FA7
02CF2:  BSF    FA6.1
02CF4:  BTFSC  FA6.1
02CF6:  BRA    2CF4
02CF8:  BCF    FA6.2
02CFA:  MOVF   00,W
02CFC:  IORWF  FF2,F
....................             write_eeprom(0x11,RxD_Buff[19]); //Red9_10
02CFE:  MOVFF  FF2,00
02D02:  BCF    FF2.7
02D04:  CLRF   FAA
02D06:  MOVLW  11
02D08:  MOVWF  FA9
02D0A:  MOVFF  186,FA8
02D0E:  BCF    FA6.6
02D10:  BCF    FA6.7
02D12:  BSF    FA6.2
02D14:  MOVLW  55
02D16:  MOVWF  FA7
02D18:  MOVLW  AA
02D1A:  MOVWF  FA7
02D1C:  BSF    FA6.1
02D1E:  BTFSC  FA6.1
02D20:  BRA    2D1E
02D22:  BCF    FA6.2
02D24:  MOVF   00,W
02D26:  IORWF  FF2,F
....................             write_eeprom(0x12,RxD_Buff[20]); //Red11_18
02D28:  MOVFF  FF2,00
02D2C:  BCF    FF2.7
02D2E:  CLRF   FAA
02D30:  MOVLW  12
02D32:  MOVWF  FA9
02D34:  MOVFF  187,FA8
02D38:  BCF    FA6.6
02D3A:  BCF    FA6.7
02D3C:  BSF    FA6.2
02D3E:  MOVLW  55
02D40:  MOVWF  FA7
02D42:  MOVLW  AA
02D44:  MOVWF  FA7
02D46:  BSF    FA6.1
02D48:  BTFSC  FA6.1
02D4A:  BRA    2D48
02D4C:  BCF    FA6.2
02D4E:  MOVF   00,W
02D50:  IORWF  FF2,F
....................             write_eeprom(0x13,RxD_Buff[21]); //Red19_20
02D52:  MOVFF  FF2,00
02D56:  BCF    FF2.7
02D58:  CLRF   FAA
02D5A:  MOVLW  13
02D5C:  MOVWF  FA9
02D5E:  MOVFF  188,FA8
02D62:  BCF    FA6.6
02D64:  BCF    FA6.7
02D66:  BSF    FA6.2
02D68:  MOVLW  55
02D6A:  MOVWF  FA7
02D6C:  MOVLW  AA
02D6E:  MOVWF  FA7
02D70:  BSF    FA6.1
02D72:  BTFSC  FA6.1
02D74:  BRA    2D72
02D76:  BCF    FA6.2
02D78:  MOVF   00,W
02D7A:  IORWF  FF2,F
....................             write_eeprom(0x14,RxD_Buff[22]); //Green1_8
02D7C:  MOVFF  FF2,00
02D80:  BCF    FF2.7
02D82:  CLRF   FAA
02D84:  MOVLW  14
02D86:  MOVWF  FA9
02D88:  MOVFF  189,FA8
02D8C:  BCF    FA6.6
02D8E:  BCF    FA6.7
02D90:  BSF    FA6.2
02D92:  MOVLW  55
02D94:  MOVWF  FA7
02D96:  MOVLW  AA
02D98:  MOVWF  FA7
02D9A:  BSF    FA6.1
02D9C:  BTFSC  FA6.1
02D9E:  BRA    2D9C
02DA0:  BCF    FA6.2
02DA2:  MOVF   00,W
02DA4:  IORWF  FF2,F
....................             write_eeprom(0x15,RxD_Buff[23]); //Green9_10
02DA6:  MOVFF  FF2,00
02DAA:  BCF    FF2.7
02DAC:  CLRF   FAA
02DAE:  MOVLW  15
02DB0:  MOVWF  FA9
02DB2:  MOVFF  18A,FA8
02DB6:  BCF    FA6.6
02DB8:  BCF    FA6.7
02DBA:  BSF    FA6.2
02DBC:  MOVLW  55
02DBE:  MOVWF  FA7
02DC0:  MOVLW  AA
02DC2:  MOVWF  FA7
02DC4:  BSF    FA6.1
02DC6:  BTFSC  FA6.1
02DC8:  BRA    2DC6
02DCA:  BCF    FA6.2
02DCC:  MOVF   00,W
02DCE:  IORWF  FF2,F
....................             write_eeprom(0x16,RxD_Buff[24]); //Green11_18
02DD0:  MOVFF  FF2,00
02DD4:  BCF    FF2.7
02DD6:  CLRF   FAA
02DD8:  MOVLW  16
02DDA:  MOVWF  FA9
02DDC:  MOVFF  18B,FA8
02DE0:  BCF    FA6.6
02DE2:  BCF    FA6.7
02DE4:  BSF    FA6.2
02DE6:  MOVLW  55
02DE8:  MOVWF  FA7
02DEA:  MOVLW  AA
02DEC:  MOVWF  FA7
02DEE:  BSF    FA6.1
02DF0:  BTFSC  FA6.1
02DF2:  BRA    2DF0
02DF4:  BCF    FA6.2
02DF6:  MOVF   00,W
02DF8:  IORWF  FF2,F
....................             write_eeprom(0x17,RxD_Buff[25]); //Green19_20
02DFA:  MOVFF  FF2,00
02DFE:  BCF    FF2.7
02E00:  CLRF   FAA
02E02:  MOVLW  17
02E04:  MOVWF  FA9
02E06:  MOVFF  18C,FA8
02E0A:  BCF    FA6.6
02E0C:  BCF    FA6.7
02E0E:  BSF    FA6.2
02E10:  MOVLW  55
02E12:  MOVWF  FA7
02E14:  MOVLW  AA
02E16:  MOVWF  FA7
02E18:  BSF    FA6.1
02E1A:  BTFSC  FA6.1
02E1C:  BRA    2E1A
02E1E:  BCF    FA6.2
02E20:  MOVF   00,W
02E22:  IORWF  FF2,F
....................                
....................             write_eeprom(0x18,RxD_Buff[26]);   //Auto acknowledge
02E24:  MOVFF  FF2,00
02E28:  BCF    FF2.7
02E2A:  CLRF   FAA
02E2C:  MOVLW  18
02E2E:  MOVWF  FA9
02E30:  MOVFF  18D,FA8
02E34:  BCF    FA6.6
02E36:  BCF    FA6.7
02E38:  BSF    FA6.2
02E3A:  MOVLW  55
02E3C:  MOVWF  FA7
02E3E:  MOVLW  AA
02E40:  MOVWF  FA7
02E42:  BSF    FA6.1
02E44:  BTFSC  FA6.1
02E46:  BRA    2E44
02E48:  BCF    FA6.2
02E4A:  MOVF   00,W
02E4C:  IORWF  FF2,F
....................             write_eeprom(0x19,RxD_Buff[27]);   //Auto acknowledge Time
02E4E:  MOVFF  FF2,00
02E52:  BCF    FF2.7
02E54:  CLRF   FAA
02E56:  MOVLW  19
02E58:  MOVWF  FA9
02E5A:  MOVFF  18E,FA8
02E5E:  BCF    FA6.6
02E60:  BCF    FA6.7
02E62:  BSF    FA6.2
02E64:  MOVLW  55
02E66:  MOVWF  FA7
02E68:  MOVLW  AA
02E6A:  MOVWF  FA7
02E6C:  BSF    FA6.1
02E6E:  BTFSC  FA6.1
02E70:  BRA    2E6E
02E72:  BCF    FA6.2
02E74:  MOVF   00,W
02E76:  IORWF  FF2,F
....................             write_eeprom(0x1A,RxD_Buff[28]);   //Flashing Rate
02E78:  MOVFF  FF2,00
02E7C:  BCF    FF2.7
02E7E:  CLRF   FAA
02E80:  MOVLW  1A
02E82:  MOVWF  FA9
02E84:  MOVFF  18F,FA8
02E88:  BCF    FA6.6
02E8A:  BCF    FA6.7
02E8C:  BSF    FA6.2
02E8E:  MOVLW  55
02E90:  MOVWF  FA7
02E92:  MOVLW  AA
02E94:  MOVWF  FA7
02E96:  BSF    FA6.1
02E98:  BTFSC  FA6.1
02E9A:  BRA    2E98
02E9C:  BCF    FA6.2
02E9E:  MOVF   00,W
02EA0:  IORWF  FF2,F
....................             write_eeprom(0x1B,RxD_Buff[29]);   //No of point
02EA2:  MOVFF  FF2,00
02EA6:  BCF    FF2.7
02EA8:  CLRF   FAA
02EAA:  MOVLW  1B
02EAC:  MOVWF  FA9
02EAE:  MOVFF  190,FA8
02EB2:  BCF    FA6.6
02EB4:  BCF    FA6.7
02EB6:  BSF    FA6.2
02EB8:  MOVLW  55
02EBA:  MOVWF  FA7
02EBC:  MOVLW  AA
02EBE:  MOVWF  FA7
02EC0:  BSF    FA6.1
02EC2:  BTFSC  FA6.1
02EC4:  BRA    2EC2
02EC6:  BCF    FA6.2
02EC8:  MOVF   00,W
02ECA:  IORWF  FF2,F
....................             write_eeprom(0x1C,RxD_Buff[30]);   //FaultDelayTime
02ECC:  MOVFF  FF2,00
02ED0:  BCF    FF2.7
02ED2:  CLRF   FAA
02ED4:  MOVLW  1C
02ED6:  MOVWF  FA9
02ED8:  MOVFF  191,FA8
02EDC:  BCF    FA6.6
02EDE:  BCF    FA6.7
02EE0:  BSF    FA6.2
02EE2:  MOVLW  55
02EE4:  MOVWF  FA7
02EE6:  MOVLW  AA
02EE8:  MOVWF  FA7
02EEA:  BSF    FA6.1
02EEC:  BTFSC  FA6.1
02EEE:  BRA    2EEC
02EF0:  BCF    FA6.2
02EF2:  MOVF   00,W
02EF4:  IORWF  FF2,F
....................             write_eeprom(0x1D,RxD_Buff[31]);   //Communication Address
02EF6:  MOVFF  FF2,00
02EFA:  BCF    FF2.7
02EFC:  CLRF   FAA
02EFE:  MOVLW  1D
02F00:  MOVWF  FA9
02F02:  MOVFF  192,FA8
02F06:  BCF    FA6.6
02F08:  BCF    FA6.7
02F0A:  BSF    FA6.2
02F0C:  MOVLW  55
02F0E:  MOVWF  FA7
02F10:  MOVLW  AA
02F12:  MOVWF  FA7
02F14:  BSF    FA6.1
02F16:  BTFSC  FA6.1
02F18:  BRA    2F16
02F1A:  BCF    FA6.2
02F1C:  MOVF   00,W
02F1E:  IORWF  FF2,F
....................    
....................             write_eeprom(0x1E,RxD_Buff[32]);   //Fault Delay Time 1
02F20:  MOVFF  FF2,00
02F24:  BCF    FF2.7
02F26:  CLRF   FAA
02F28:  MOVLW  1E
02F2A:  MOVWF  FA9
02F2C:  MOVFF  193,FA8
02F30:  BCF    FA6.6
02F32:  BCF    FA6.7
02F34:  BSF    FA6.2
02F36:  MOVLW  55
02F38:  MOVWF  FA7
02F3A:  MOVLW  AA
02F3C:  MOVWF  FA7
02F3E:  BSF    FA6.1
02F40:  BTFSC  FA6.1
02F42:  BRA    2F40
02F44:  BCF    FA6.2
02F46:  MOVF   00,W
02F48:  IORWF  FF2,F
....................             write_eeprom(0x1F,RxD_Buff[33]);   //Fault Delay Time 2
02F4A:  MOVFF  FF2,00
02F4E:  BCF    FF2.7
02F50:  CLRF   FAA
02F52:  MOVLW  1F
02F54:  MOVWF  FA9
02F56:  MOVFF  194,FA8
02F5A:  BCF    FA6.6
02F5C:  BCF    FA6.7
02F5E:  BSF    FA6.2
02F60:  MOVLW  55
02F62:  MOVWF  FA7
02F64:  MOVLW  AA
02F66:  MOVWF  FA7
02F68:  BSF    FA6.1
02F6A:  BTFSC  FA6.1
02F6C:  BRA    2F6A
02F6E:  BCF    FA6.2
02F70:  MOVF   00,W
02F72:  IORWF  FF2,F
....................             write_eeprom(0x20,RxD_Buff[34]);   //Fault Delay Time 3
02F74:  MOVFF  FF2,00
02F78:  BCF    FF2.7
02F7A:  CLRF   FAA
02F7C:  MOVLW  20
02F7E:  MOVWF  FA9
02F80:  MOVFF  195,FA8
02F84:  BCF    FA6.6
02F86:  BCF    FA6.7
02F88:  BSF    FA6.2
02F8A:  MOVLW  55
02F8C:  MOVWF  FA7
02F8E:  MOVLW  AA
02F90:  MOVWF  FA7
02F92:  BSF    FA6.1
02F94:  BTFSC  FA6.1
02F96:  BRA    2F94
02F98:  BCF    FA6.2
02F9A:  MOVF   00,W
02F9C:  IORWF  FF2,F
....................             write_eeprom(0x21,RxD_Buff[35]);   //Fault Delay Time 4
02F9E:  MOVFF  FF2,00
02FA2:  BCF    FF2.7
02FA4:  CLRF   FAA
02FA6:  MOVLW  21
02FA8:  MOVWF  FA9
02FAA:  MOVFF  196,FA8
02FAE:  BCF    FA6.6
02FB0:  BCF    FA6.7
02FB2:  BSF    FA6.2
02FB4:  MOVLW  55
02FB6:  MOVWF  FA7
02FB8:  MOVLW  AA
02FBA:  MOVWF  FA7
02FBC:  BSF    FA6.1
02FBE:  BTFSC  FA6.1
02FC0:  BRA    2FBE
02FC2:  BCF    FA6.2
02FC4:  MOVF   00,W
02FC6:  IORWF  FF2,F
....................             write_eeprom(0x22,RxD_Buff[36]);   //Fault Delay Time 5
02FC8:  MOVFF  FF2,00
02FCC:  BCF    FF2.7
02FCE:  CLRF   FAA
02FD0:  MOVLW  22
02FD2:  MOVWF  FA9
02FD4:  MOVFF  197,FA8
02FD8:  BCF    FA6.6
02FDA:  BCF    FA6.7
02FDC:  BSF    FA6.2
02FDE:  MOVLW  55
02FE0:  MOVWF  FA7
02FE2:  MOVLW  AA
02FE4:  MOVWF  FA7
02FE6:  BSF    FA6.1
02FE8:  BTFSC  FA6.1
02FEA:  BRA    2FE8
02FEC:  BCF    FA6.2
02FEE:  MOVF   00,W
02FF0:  IORWF  FF2,F
....................             write_eeprom(0x23,RxD_Buff[37]);   //Fault Delay Time6
02FF2:  MOVFF  FF2,00
02FF6:  BCF    FF2.7
02FF8:  CLRF   FAA
02FFA:  MOVLW  23
02FFC:  MOVWF  FA9
02FFE:  MOVFF  198,FA8
03002:  BCF    FA6.6
03004:  BCF    FA6.7
03006:  BSF    FA6.2
03008:  MOVLW  55
0300A:  MOVWF  FA7
0300C:  MOVLW  AA
0300E:  MOVWF  FA7
03010:  BSF    FA6.1
03012:  BTFSC  FA6.1
03014:  BRA    3012
03016:  BCF    FA6.2
03018:  MOVF   00,W
0301A:  IORWF  FF2,F
....................             write_eeprom(0x24,RxD_Buff[38]);   //Fault Delay Time7
0301C:  MOVFF  FF2,00
03020:  BCF    FF2.7
03022:  CLRF   FAA
03024:  MOVLW  24
03026:  MOVWF  FA9
03028:  MOVFF  199,FA8
0302C:  BCF    FA6.6
0302E:  BCF    FA6.7
03030:  BSF    FA6.2
03032:  MOVLW  55
03034:  MOVWF  FA7
03036:  MOVLW  AA
03038:  MOVWF  FA7
0303A:  BSF    FA6.1
0303C:  BTFSC  FA6.1
0303E:  BRA    303C
03040:  BCF    FA6.2
03042:  MOVF   00,W
03044:  IORWF  FF2,F
....................             write_eeprom(0x25,RxD_Buff[39]);   //Fault Delay Time8
03046:  MOVFF  FF2,00
0304A:  BCF    FF2.7
0304C:  CLRF   FAA
0304E:  MOVLW  25
03050:  MOVWF  FA9
03052:  MOVFF  19A,FA8
03056:  BCF    FA6.6
03058:  BCF    FA6.7
0305A:  BSF    FA6.2
0305C:  MOVLW  55
0305E:  MOVWF  FA7
03060:  MOVLW  AA
03062:  MOVWF  FA7
03064:  BSF    FA6.1
03066:  BTFSC  FA6.1
03068:  BRA    3066
0306A:  BCF    FA6.2
0306C:  MOVF   00,W
0306E:  IORWF  FF2,F
....................             write_eeprom(0x26,RxD_Buff[40]);   //Fault Delay Time9
03070:  MOVFF  FF2,00
03074:  BCF    FF2.7
03076:  CLRF   FAA
03078:  MOVLW  26
0307A:  MOVWF  FA9
0307C:  MOVFF  19B,FA8
03080:  BCF    FA6.6
03082:  BCF    FA6.7
03084:  BSF    FA6.2
03086:  MOVLW  55
03088:  MOVWF  FA7
0308A:  MOVLW  AA
0308C:  MOVWF  FA7
0308E:  BSF    FA6.1
03090:  BTFSC  FA6.1
03092:  BRA    3090
03094:  BCF    FA6.2
03096:  MOVF   00,W
03098:  IORWF  FF2,F
....................             write_eeprom(0x27,RxD_Buff[41]);   //Fault Delay Time10
0309A:  MOVFF  FF2,00
0309E:  BCF    FF2.7
030A0:  CLRF   FAA
030A2:  MOVLW  27
030A4:  MOVWF  FA9
030A6:  MOVFF  19C,FA8
030AA:  BCF    FA6.6
030AC:  BCF    FA6.7
030AE:  BSF    FA6.2
030B0:  MOVLW  55
030B2:  MOVWF  FA7
030B4:  MOVLW  AA
030B6:  MOVWF  FA7
030B8:  BSF    FA6.1
030BA:  BTFSC  FA6.1
030BC:  BRA    30BA
030BE:  BCF    FA6.2
030C0:  MOVF   00,W
030C2:  IORWF  FF2,F
....................             write_eeprom(0x28,RxD_Buff[42]);   //Fault Delay Time11
030C4:  MOVFF  FF2,00
030C8:  BCF    FF2.7
030CA:  CLRF   FAA
030CC:  MOVLW  28
030CE:  MOVWF  FA9
030D0:  MOVFF  19D,FA8
030D4:  BCF    FA6.6
030D6:  BCF    FA6.7
030D8:  BSF    FA6.2
030DA:  MOVLW  55
030DC:  MOVWF  FA7
030DE:  MOVLW  AA
030E0:  MOVWF  FA7
030E2:  BSF    FA6.1
030E4:  BTFSC  FA6.1
030E6:  BRA    30E4
030E8:  BCF    FA6.2
030EA:  MOVF   00,W
030EC:  IORWF  FF2,F
....................             write_eeprom(0x29,RxD_Buff[43]);   //Fault Delay Time12
030EE:  MOVFF  FF2,00
030F2:  BCF    FF2.7
030F4:  CLRF   FAA
030F6:  MOVLW  29
030F8:  MOVWF  FA9
030FA:  MOVFF  19E,FA8
030FE:  BCF    FA6.6
03100:  BCF    FA6.7
03102:  BSF    FA6.2
03104:  MOVLW  55
03106:  MOVWF  FA7
03108:  MOVLW  AA
0310A:  MOVWF  FA7
0310C:  BSF    FA6.1
0310E:  BTFSC  FA6.1
03110:  BRA    310E
03112:  BCF    FA6.2
03114:  MOVF   00,W
03116:  IORWF  FF2,F
....................             write_eeprom(0x2A,RxD_Buff[44]);   //Fault Delay Time13
03118:  MOVFF  FF2,00
0311C:  BCF    FF2.7
0311E:  CLRF   FAA
03120:  MOVLW  2A
03122:  MOVWF  FA9
03124:  MOVFF  19F,FA8
03128:  BCF    FA6.6
0312A:  BCF    FA6.7
0312C:  BSF    FA6.2
0312E:  MOVLW  55
03130:  MOVWF  FA7
03132:  MOVLW  AA
03134:  MOVWF  FA7
03136:  BSF    FA6.1
03138:  BTFSC  FA6.1
0313A:  BRA    3138
0313C:  BCF    FA6.2
0313E:  MOVF   00,W
03140:  IORWF  FF2,F
....................             write_eeprom(0x2B,RxD_Buff[45]);   //Fault Delay Time14
03142:  MOVFF  FF2,00
03146:  BCF    FF2.7
03148:  CLRF   FAA
0314A:  MOVLW  2B
0314C:  MOVWF  FA9
0314E:  MOVFF  1A0,FA8
03152:  BCF    FA6.6
03154:  BCF    FA6.7
03156:  BSF    FA6.2
03158:  MOVLW  55
0315A:  MOVWF  FA7
0315C:  MOVLW  AA
0315E:  MOVWF  FA7
03160:  BSF    FA6.1
03162:  BTFSC  FA6.1
03164:  BRA    3162
03166:  BCF    FA6.2
03168:  MOVF   00,W
0316A:  IORWF  FF2,F
....................             write_eeprom(0x2C,RxD_Buff[46]);   //Fault Delay Time15
0316C:  MOVFF  FF2,00
03170:  BCF    FF2.7
03172:  CLRF   FAA
03174:  MOVLW  2C
03176:  MOVWF  FA9
03178:  MOVFF  1A1,FA8
0317C:  BCF    FA6.6
0317E:  BCF    FA6.7
03180:  BSF    FA6.2
03182:  MOVLW  55
03184:  MOVWF  FA7
03186:  MOVLW  AA
03188:  MOVWF  FA7
0318A:  BSF    FA6.1
0318C:  BTFSC  FA6.1
0318E:  BRA    318C
03190:  BCF    FA6.2
03192:  MOVF   00,W
03194:  IORWF  FF2,F
....................             write_eeprom(0x2D,RxD_Buff[47]);   //Fault Delay Time16
03196:  MOVFF  FF2,00
0319A:  BCF    FF2.7
0319C:  CLRF   FAA
0319E:  MOVLW  2D
031A0:  MOVWF  FA9
031A2:  MOVFF  1A2,FA8
031A6:  BCF    FA6.6
031A8:  BCF    FA6.7
031AA:  BSF    FA6.2
031AC:  MOVLW  55
031AE:  MOVWF  FA7
031B0:  MOVLW  AA
031B2:  MOVWF  FA7
031B4:  BSF    FA6.1
031B6:  BTFSC  FA6.1
031B8:  BRA    31B6
031BA:  BCF    FA6.2
031BC:  MOVF   00,W
031BE:  IORWF  FF2,F
....................             write_eeprom(0x2E,RxD_Buff[48]);   //Fault Delay Time17
031C0:  MOVFF  FF2,00
031C4:  BCF    FF2.7
031C6:  CLRF   FAA
031C8:  MOVLW  2E
031CA:  MOVWF  FA9
031CC:  MOVFF  1A3,FA8
031D0:  BCF    FA6.6
031D2:  BCF    FA6.7
031D4:  BSF    FA6.2
031D6:  MOVLW  55
031D8:  MOVWF  FA7
031DA:  MOVLW  AA
031DC:  MOVWF  FA7
031DE:  BSF    FA6.1
031E0:  BTFSC  FA6.1
031E2:  BRA    31E0
031E4:  BCF    FA6.2
031E6:  MOVF   00,W
031E8:  IORWF  FF2,F
....................             write_eeprom(0x2F,RxD_Buff[49]);   //Fault Delay Time18
031EA:  MOVFF  FF2,00
031EE:  BCF    FF2.7
031F0:  CLRF   FAA
031F2:  MOVLW  2F
031F4:  MOVWF  FA9
031F6:  MOVFF  1A4,FA8
031FA:  BCF    FA6.6
031FC:  BCF    FA6.7
031FE:  BSF    FA6.2
03200:  MOVLW  55
03202:  MOVWF  FA7
03204:  MOVLW  AA
03206:  MOVWF  FA7
03208:  BSF    FA6.1
0320A:  BTFSC  FA6.1
0320C:  BRA    320A
0320E:  BCF    FA6.2
03210:  MOVF   00,W
03212:  IORWF  FF2,F
....................             write_eeprom(0x30,RxD_Buff[50]);   //Fault Delay Time19
03214:  MOVFF  FF2,00
03218:  BCF    FF2.7
0321A:  CLRF   FAA
0321C:  MOVLW  30
0321E:  MOVWF  FA9
03220:  MOVFF  1A5,FA8
03224:  BCF    FA6.6
03226:  BCF    FA6.7
03228:  BSF    FA6.2
0322A:  MOVLW  55
0322C:  MOVWF  FA7
0322E:  MOVLW  AA
03230:  MOVWF  FA7
03232:  BSF    FA6.1
03234:  BTFSC  FA6.1
03236:  BRA    3234
03238:  BCF    FA6.2
0323A:  MOVF   00,W
0323C:  IORWF  FF2,F
....................             write_eeprom(0x31,RxD_Buff[51]);   //Fault Delay Time20
0323E:  MOVFF  FF2,00
03242:  BCF    FF2.7
03244:  CLRF   FAA
03246:  MOVLW  31
03248:  MOVWF  FA9
0324A:  MOVFF  1A6,FA8
0324E:  BCF    FA6.6
03250:  BCF    FA6.7
03252:  BSF    FA6.2
03254:  MOVLW  55
03256:  MOVWF  FA7
03258:  MOVLW  AA
0325A:  MOVWF  FA7
0325C:  BSF    FA6.1
0325E:  BTFSC  FA6.1
03260:  BRA    325E
03262:  BCF    FA6.2
03264:  MOVF   00,W
03266:  IORWF  FF2,F
....................             
....................             int16  a = 0; 
....................             unsigned char  phonenum;
03268:  MOVLB  7
0326A:  CLRF   xD0
0326C:  CLRF   xCF
....................             for(; ; a++)
....................             {
....................                restart_wdt();
0326E:  CLRWDT
....................                phonenum = RxD_Buff[52 + a];
03270:  MOVLW  A7
03272:  ADDWF  xCF,W
03274:  MOVWF  FE9
03276:  MOVLW  01
03278:  ADDWFC xD0,W
0327A:  MOVWF  FEA
0327C:  MOVFF  FEF,7D1
....................                if((phonenum == 0x0D) || (a > 15))
03280:  MOVF   xD1,W
03282:  SUBLW  0D
03284:  BZ    3290
03286:  MOVF   xD0,F
03288:  BNZ   3290
0328A:  MOVF   xCF,W
0328C:  SUBLW  0F
0328E:  BC    32DE
....................                {
....................                   sms_phonenumber[a] =  '\0' ;
03290:  MOVLW  82
03292:  ADDWF  xCF,W
03294:  MOVWF  FE9
03296:  MOVLW  05
03298:  ADDWFC xD0,W
0329A:  MOVWF  FEA
0329C:  CLRF   FEF
....................                   write_eeprom(0x32+a,phonenum);
0329E:  MOVLW  32
032A0:  ADDWF  xCF,W
032A2:  MOVWF  xD8
032A4:  MOVLW  00
032A6:  ADDWFC xD0,W
032A8:  MOVWF  xD9
032AA:  MOVF   FF2,W
032AC:  MOVWF  00
032AE:  BCF    FF2.7
032B0:  MOVFF  7D9,FAA
032B4:  MOVFF  7D8,FA9
032B8:  MOVFF  7D1,FA8
032BC:  BCF    FA6.6
032BE:  BCF    FA6.7
032C0:  BSF    FA6.2
032C2:  MOVLB  F
032C4:  MOVLW  55
032C6:  MOVWF  FA7
032C8:  MOVLW  AA
032CA:  MOVWF  FA7
032CC:  BSF    FA6.1
032CE:  BTFSC  FA6.1
032D0:  BRA    32CE
032D2:  BCF    FA6.2
032D4:  MOVF   00,W
032D6:  IORWF  FF2,F
....................                   break;
032D8:  BRA    3334
....................                }
032DA:  BRA    3328
032DC:  MOVLB  7
....................                else
....................                {
....................                   sms_phonenumber[a] = phonenum;
032DE:  MOVLW  82
032E0:  ADDWF  xCF,W
032E2:  MOVWF  FE9
032E4:  MOVLW  05
032E6:  ADDWFC xD0,W
032E8:  MOVWF  FEA
032EA:  MOVFF  7D1,FEF
....................                   write_eeprom(0x32+a,phonenum);
032EE:  MOVLW  32
032F0:  ADDWF  xCF,W
032F2:  MOVWF  xD8
032F4:  MOVLW  00
032F6:  ADDWFC xD0,W
032F8:  MOVWF  xD9
032FA:  MOVF   FF2,W
032FC:  MOVWF  00
032FE:  BCF    FF2.7
03300:  MOVFF  7D9,FAA
03304:  MOVFF  7D8,FA9
03308:  MOVFF  7D1,FA8
0330C:  BCF    FA6.6
0330E:  BCF    FA6.7
03310:  BSF    FA6.2
03312:  MOVLB  F
03314:  MOVLW  55
03316:  MOVWF  FA7
03318:  MOVLW  AA
0331A:  MOVWF  FA7
0331C:  BSF    FA6.1
0331E:  BTFSC  FA6.1
03320:  BRA    331E
03322:  BCF    FA6.2
03324:  MOVF   00,W
03326:  IORWF  FF2,F
....................                }
03328:  MOVLB  7
0332A:  INCF   xCF,F
0332C:  BTFSC  FD8.2
0332E:  INCF   xD0,F
03330:  BRA    326E
03332:  MOVLB  F
....................             }
....................          
....................             TxD_Buff[0] = Address ;         //Address
03334:  MOVFF  70,73
....................             TxD_Buff[1] = 0x21 ;            //return function code
03338:  MOVLW  21
0333A:  MOVLB  0
0333C:  MOVWF  x74
....................    
....................             CRC(TxD_Buff,2)   ;            //Cal CRC 2 byte
0333E:  MOVLB  7
03340:  CLRF   xDB
03342:  MOVLW  73
03344:  MOVWF  xDA
03346:  MOVLW  02
03348:  MOVWF  xDC
0334A:  MOVLB  0
0334C:  CALL   1F50
....................    
....................             TxD_Buff[2] = CRC_Hi ;
03350:  MOVFF  374,75
....................             TxD_Buff[3] = CRC_Lo ;
03354:  MOVFF  373,76
....................    
....................             output_bit(P485ctrl,1);
03358:  BSF    F8A.3
0335A:  BCF    F93.3
....................             delay_ms(10);
0335C:  MOVLW  0A
0335E:  MOVLB  7
03360:  MOVWF  xD8
03362:  MOVLB  0
03364:  CALL   068A
....................    
....................             putc(Txd_Buff[0]);
03368:  MOVF   x73,W
0336A:  CALL   1FA6
....................             putc(Txd_Buff[1]);
0336E:  MOVF   x74,W
03370:  CALL   1FA6
....................             putc(Txd_Buff[2]);
03374:  MOVF   x75,W
03376:  CALL   1FA6
....................             putc(Txd_Buff[3]);
0337A:  MOVF   x76,W
0337C:  CALL   1FA6
....................    
....................             delay_ms(3);
03380:  MOVLW  03
03382:  MOVLB  7
03384:  MOVWF  xD8
03386:  MOVLB  0
03388:  CALL   068A
....................             output_bit(P485ctrl,0);           
0338C:  BCF    F8A.3
0338E:  BCF    F93.3
....................             
....................             reset_cpu();
03390:  RESET
....................             //Read_Config(); //jj
....................          }
03392:  GOTO   3EBC
03396:  MOVLB  1
....................          
....................          else if(RxD_Buff[1] == 0x22)///////////// WRITE Faultname /////////////////////
03398:  MOVF   x74,W
0339A:  SUBLW  22
0339C:  BTFSS  FD8.2
0339E:  GOTO   3EBE
....................          {
....................             //SMS_Massage
....................             int16  i =4,j=0,k=0; //i =4 are first data from RxD_Buff[]
033A2:  MOVLB  7
033A4:  CLRF   xD3
033A6:  MOVLW  04
033A8:  MOVWF  xD2
033AA:  CLRF   xD5
033AC:  CLRF   xD4
033AE:  CLRF   xD7
033B0:  CLRF   xD6
....................             for(; ; i++,j++)
....................             {
....................                restart_wdt();
033B2:  CLRWDT
....................                if((RxD_Buff[i] == 0x0D) || (j > 30))
033B4:  MOVLW  73
033B6:  ADDWF  xD2,W
033B8:  MOVWF  FE9
033BA:  MOVLW  01
033BC:  ADDWFC xD3,W
033BE:  MOVWF  FEA
033C0:  MOVF   FEF,W
033C2:  SUBLW  0D
033C4:  BZ    33D0
033C6:  MOVF   xD5,F
033C8:  BNZ   33D0
033CA:  MOVF   xD4,W
033CC:  SUBLW  1E
033CE:  BC    3420
....................                {
....................                   write_eeprom(0x5D+i,RxD_Buff[i]);
033D0:  MOVLW  5D
033D2:  ADDWF  xD2,W
033D4:  MOVWF  xD8
033D6:  MOVLW  00
033D8:  ADDWFC xD3,W
033DA:  MOVWF  xD9
033DC:  MOVLW  73
033DE:  ADDWF  xD2,W
033E0:  MOVWF  FE9
033E2:  MOVLW  01
033E4:  ADDWFC xD3,W
033E6:  MOVWF  FEA
033E8:  MOVFF  FEF,7DA
033EC:  MOVF   FF2,W
033EE:  MOVWF  00
033F0:  BCF    FF2.7
033F2:  MOVFF  7D9,FAA
033F6:  MOVFF  7D8,FA9
033FA:  MOVFF  7DA,FA8
033FE:  BCF    FA6.6
03400:  BCF    FA6.7
03402:  BSF    FA6.2
03404:  MOVLB  F
03406:  MOVLW  55
03408:  MOVWF  FA7
0340A:  MOVLW  AA
0340C:  MOVWF  FA7
0340E:  BSF    FA6.1
03410:  BTFSC  FA6.1
03412:  BRA    3410
03414:  BCF    FA6.2
03416:  MOVF   00,W
03418:  IORWF  FF2,F
....................                   break;
0341A:  BRA    34AA
....................                }
0341C:  BRA    3492
0341E:  MOVLB  7
....................                else
....................                {
....................                   SMS_Massage1[j] = RxD_Buff[i];
03420:  MOVLW  91
03422:  ADDWF  xD4,W
03424:  MOVWF  01
03426:  MOVLW  05
03428:  ADDWFC xD5,W
0342A:  MOVWF  03
0342C:  MOVLW  73
0342E:  ADDWF  xD2,W
03430:  MOVWF  FE9
03432:  MOVLW  01
03434:  ADDWFC xD3,W
03436:  MOVWF  FEA
03438:  MOVFF  FEF,7DA
0343C:  MOVFF  03,FEA
03440:  MOVFF  01,FE9
03444:  MOVFF  7DA,FEF
....................                   
....................                   write_eeprom(0x5D+i,RxD_Buff[i]);
03448:  MOVLW  5D
0344A:  ADDWF  xD2,W
0344C:  MOVWF  xD8
0344E:  MOVLW  00
03450:  ADDWFC xD3,W
03452:  MOVWF  xD9
03454:  MOVLW  73
03456:  ADDWF  xD2,W
03458:  MOVWF  FE9
0345A:  MOVLW  01
0345C:  ADDWFC xD3,W
0345E:  MOVWF  FEA
03460:  MOVFF  FEF,7DA
03464:  MOVF   FF2,W
03466:  MOVWF  00
03468:  BCF    FF2.7
0346A:  MOVFF  7D9,FAA
0346E:  MOVFF  7D8,FA9
03472:  MOVFF  7DA,FA8
03476:  BCF    FA6.6
03478:  BCF    FA6.7
0347A:  BSF    FA6.2
0347C:  MOVLB  F
0347E:  MOVLW  55
03480:  MOVWF  FA7
03482:  MOVLW  AA
03484:  MOVWF  FA7
03486:  BSF    FA6.1
03488:  BTFSC  FA6.1
0348A:  BRA    3488
0348C:  BCF    FA6.2
0348E:  MOVF   00,W
03490:  IORWF  FF2,F
....................                }
03492:  MOVLB  7
03494:  MOVFF  7D3,03
03498:  MOVF   xD2,W
0349A:  INCF   xD2,F
0349C:  BTFSC  FD8.2
0349E:  INCF   xD3,F
034A0:  INCF   xD4,F
034A2:  BTFSC  FD8.2
034A4:  INCF   xD5,F
034A6:  BRA    33B2
034A8:  MOVLB  F
....................             }
....................             SMS_Massage1[j] = '\0' ; // end string
034AA:  MOVLW  91
034AC:  MOVLB  7
034AE:  ADDWF  xD4,W
034B0:  MOVWF  FE9
034B2:  MOVLW  05
034B4:  ADDWFC xD5,W
034B6:  MOVWF  FEA
034B8:  CLRF   FEF
....................             
....................             j=0;
034BA:  CLRF   xD5
034BC:  CLRF   xD4
....................             i++;
034BE:  INCF   xD2,F
034C0:  BTFSC  FD8.2
034C2:  INCF   xD3,F
....................             
....................             for(; ; i++,j++)
....................             {
....................                restart_wdt();
034C4:  CLRWDT
....................                if((RxD_Buff[i] == 0x0D) || (j > 30))
034C6:  MOVLW  73
034C8:  ADDWF  xD2,W
034CA:  MOVWF  FE9
034CC:  MOVLW  01
034CE:  ADDWFC xD3,W
034D0:  MOVWF  FEA
034D2:  MOVF   FEF,W
034D4:  SUBLW  0D
034D6:  BZ    34E2
034D8:  MOVF   xD5,F
034DA:  BNZ   34E2
034DC:  MOVF   xD4,W
034DE:  SUBLW  1E
034E0:  BC    3532
....................                {  
....................                   write_eeprom(0x5D+i,RxD_Buff[i]);
034E2:  MOVLW  5D
034E4:  ADDWF  xD2,W
034E6:  MOVWF  xD8
034E8:  MOVLW  00
034EA:  ADDWFC xD3,W
034EC:  MOVWF  xD9
034EE:  MOVLW  73
034F0:  ADDWF  xD2,W
034F2:  MOVWF  FE9
034F4:  MOVLW  01
034F6:  ADDWFC xD3,W
034F8:  MOVWF  FEA
034FA:  MOVFF  FEF,7DA
034FE:  MOVF   FF2,W
03500:  MOVWF  00
03502:  BCF    FF2.7
03504:  MOVFF  7D9,FAA
03508:  MOVFF  7D8,FA9
0350C:  MOVFF  7DA,FA8
03510:  BCF    FA6.6
03512:  BCF    FA6.7
03514:  BSF    FA6.2
03516:  MOVLB  F
03518:  MOVLW  55
0351A:  MOVWF  FA7
0351C:  MOVLW  AA
0351E:  MOVWF  FA7
03520:  BSF    FA6.1
03522:  BTFSC  FA6.1
03524:  BRA    3522
03526:  BCF    FA6.2
03528:  MOVF   00,W
0352A:  IORWF  FF2,F
....................                   break;
0352C:  BRA    35BC
....................                }
0352E:  BRA    35A4
03530:  MOVLB  7
....................                else
....................                {
....................                   SMS_Massage2[j] = RxD_Buff[i];
03532:  MOVLW  B1
03534:  ADDWF  xD4,W
03536:  MOVWF  01
03538:  MOVLW  05
0353A:  ADDWFC xD5,W
0353C:  MOVWF  03
0353E:  MOVLW  73
03540:  ADDWF  xD2,W
03542:  MOVWF  FE9
03544:  MOVLW  01
03546:  ADDWFC xD3,W
03548:  MOVWF  FEA
0354A:  MOVFF  FEF,7DA
0354E:  MOVFF  03,FEA
03552:  MOVFF  01,FE9
03556:  MOVFF  7DA,FEF
....................                   write_eeprom(0x5D+i,RxD_Buff[i]);
0355A:  MOVLW  5D
0355C:  ADDWF  xD2,W
0355E:  MOVWF  xD8
03560:  MOVLW  00
03562:  ADDWFC xD3,W
03564:  MOVWF  xD9
03566:  MOVLW  73
03568:  ADDWF  xD2,W
0356A:  MOVWF  FE9
0356C:  MOVLW  01
0356E:  ADDWFC xD3,W
03570:  MOVWF  FEA
03572:  MOVFF  FEF,7DA
03576:  MOVF   FF2,W
03578:  MOVWF  00
0357A:  BCF    FF2.7
0357C:  MOVFF  7D9,FAA
03580:  MOVFF  7D8,FA9
03584:  MOVFF  7DA,FA8
03588:  BCF    FA6.6
0358A:  BCF    FA6.7
0358C:  BSF    FA6.2
0358E:  MOVLB  F
03590:  MOVLW  55
03592:  MOVWF  FA7
03594:  MOVLW  AA
03596:  MOVWF  FA7
03598:  BSF    FA6.1
0359A:  BTFSC  FA6.1
0359C:  BRA    359A
0359E:  BCF    FA6.2
035A0:  MOVF   00,W
035A2:  IORWF  FF2,F
....................                }
035A4:  MOVLB  7
035A6:  MOVFF  7D3,03
035AA:  MOVF   xD2,W
035AC:  INCF   xD2,F
035AE:  BTFSC  FD8.2
035B0:  INCF   xD3,F
035B2:  INCF   xD4,F
035B4:  BTFSC  FD8.2
035B6:  INCF   xD5,F
035B8:  BRA    34C4
035BA:  MOVLB  F
....................             }
....................             SMS_Massage2[j] = '\0' ; // end string
035BC:  MOVLW  B1
035BE:  MOVLB  7
035C0:  ADDWF  xD4,W
035C2:  MOVWF  FE9
035C4:  MOVLW  05
035C6:  ADDWFC xD5,W
035C8:  MOVWF  FEA
035CA:  CLRF   FEF
....................             
....................             j=0;
035CC:  CLRF   xD5
035CE:  CLRF   xD4
....................             i++;
035D0:  INCF   xD2,F
035D2:  BTFSC  FD8.2
035D4:  INCF   xD3,F
....................             
....................             for(; ; i++,j++)
....................             {
....................                restart_wdt();
035D6:  CLRWDT
....................                if((RxD_Buff[i] == 0x0D) || (j > 30))
035D8:  MOVLW  73
035DA:  ADDWF  xD2,W
035DC:  MOVWF  FE9
035DE:  MOVLW  01
035E0:  ADDWFC xD3,W
035E2:  MOVWF  FEA
035E4:  MOVF   FEF,W
035E6:  SUBLW  0D
035E8:  BZ    35F4
035EA:  MOVF   xD5,F
035EC:  BNZ   35F4
035EE:  MOVF   xD4,W
035F0:  SUBLW  1E
035F2:  BC    3644
....................                {
....................                   write_eeprom(0x5D+i,RxD_Buff[i]);
035F4:  MOVLW  5D
035F6:  ADDWF  xD2,W
035F8:  MOVWF  xD8
035FA:  MOVLW  00
035FC:  ADDWFC xD3,W
035FE:  MOVWF  xD9
03600:  MOVLW  73
03602:  ADDWF  xD2,W
03604:  MOVWF  FE9
03606:  MOVLW  01
03608:  ADDWFC xD3,W
0360A:  MOVWF  FEA
0360C:  MOVFF  FEF,7DA
03610:  MOVF   FF2,W
03612:  MOVWF  00
03614:  BCF    FF2.7
03616:  MOVFF  7D9,FAA
0361A:  MOVFF  7D8,FA9
0361E:  MOVFF  7DA,FA8
03622:  BCF    FA6.6
03624:  BCF    FA6.7
03626:  BSF    FA6.2
03628:  MOVLB  F
0362A:  MOVLW  55
0362C:  MOVWF  FA7
0362E:  MOVLW  AA
03630:  MOVWF  FA7
03632:  BSF    FA6.1
03634:  BTFSC  FA6.1
03636:  BRA    3634
03638:  BCF    FA6.2
0363A:  MOVF   00,W
0363C:  IORWF  FF2,F
....................                   break;
0363E:  BRA    36CE
....................                }
03640:  BRA    36B6
03642:  MOVLB  7
....................                else
....................                {
....................                   SMS_Massage3[j] = RxD_Buff[i];
03644:  MOVLW  D1
03646:  ADDWF  xD4,W
03648:  MOVWF  01
0364A:  MOVLW  05
0364C:  ADDWFC xD5,W
0364E:  MOVWF  03
03650:  MOVLW  73
03652:  ADDWF  xD2,W
03654:  MOVWF  FE9
03656:  MOVLW  01
03658:  ADDWFC xD3,W
0365A:  MOVWF  FEA
0365C:  MOVFF  FEF,7DA
03660:  MOVFF  03,FEA
03664:  MOVFF  01,FE9
03668:  MOVFF  7DA,FEF
....................                   write_eeprom(0x5D+i,RxD_Buff[i]);
0366C:  MOVLW  5D
0366E:  ADDWF  xD2,W
03670:  MOVWF  xD8
03672:  MOVLW  00
03674:  ADDWFC xD3,W
03676:  MOVWF  xD9
03678:  MOVLW  73
0367A:  ADDWF  xD2,W
0367C:  MOVWF  FE9
0367E:  MOVLW  01
03680:  ADDWFC xD3,W
03682:  MOVWF  FEA
03684:  MOVFF  FEF,7DA
03688:  MOVF   FF2,W
0368A:  MOVWF  00
0368C:  BCF    FF2.7
0368E:  MOVFF  7D9,FAA
03692:  MOVFF  7D8,FA9
03696:  MOVFF  7DA,FA8
0369A:  BCF    FA6.6
0369C:  BCF    FA6.7
0369E:  BSF    FA6.2
036A0:  MOVLB  F
036A2:  MOVLW  55
036A4:  MOVWF  FA7
036A6:  MOVLW  AA
036A8:  MOVWF  FA7
036AA:  BSF    FA6.1
036AC:  BTFSC  FA6.1
036AE:  BRA    36AC
036B0:  BCF    FA6.2
036B2:  MOVF   00,W
036B4:  IORWF  FF2,F
....................                }
036B6:  MOVLB  7
036B8:  MOVFF  7D3,03
036BC:  MOVF   xD2,W
036BE:  INCF   xD2,F
036C0:  BTFSC  FD8.2
036C2:  INCF   xD3,F
036C4:  INCF   xD4,F
036C6:  BTFSC  FD8.2
036C8:  INCF   xD5,F
036CA:  BRA    35D6
036CC:  MOVLB  F
....................             }
....................             SMS_Massage3[j] = '\0' ; // end string
036CE:  MOVLW  D1
036D0:  MOVLB  7
036D2:  ADDWF  xD4,W
036D4:  MOVWF  FE9
036D6:  MOVLW  05
036D8:  ADDWFC xD5,W
036DA:  MOVWF  FEA
036DC:  CLRF   FEF
....................             
....................             j=0;
036DE:  CLRF   xD5
036E0:  CLRF   xD4
....................             i++;
036E2:  INCF   xD2,F
036E4:  BTFSC  FD8.2
036E6:  INCF   xD3,F
....................             
....................             for(; ; i++,j++)
....................             {
....................                restart_wdt();
036E8:  CLRWDT
....................                if((RxD_Buff[i] == 0x0D) || (j > 30))
036EA:  MOVLW  73
036EC:  ADDWF  xD2,W
036EE:  MOVWF  FE9
036F0:  MOVLW  01
036F2:  ADDWFC xD3,W
036F4:  MOVWF  FEA
036F6:  MOVF   FEF,W
036F8:  SUBLW  0D
036FA:  BZ    3706
036FC:  MOVF   xD5,F
036FE:  BNZ   3706
03700:  MOVF   xD4,W
03702:  SUBLW  1E
03704:  BC    3756
....................                {
....................                   write_eeprom(0x5D+i,RxD_Buff[i]);
03706:  MOVLW  5D
03708:  ADDWF  xD2,W
0370A:  MOVWF  xD8
0370C:  MOVLW  00
0370E:  ADDWFC xD3,W
03710:  MOVWF  xD9
03712:  MOVLW  73
03714:  ADDWF  xD2,W
03716:  MOVWF  FE9
03718:  MOVLW  01
0371A:  ADDWFC xD3,W
0371C:  MOVWF  FEA
0371E:  MOVFF  FEF,7DA
03722:  MOVF   FF2,W
03724:  MOVWF  00
03726:  BCF    FF2.7
03728:  MOVFF  7D9,FAA
0372C:  MOVFF  7D8,FA9
03730:  MOVFF  7DA,FA8
03734:  BCF    FA6.6
03736:  BCF    FA6.7
03738:  BSF    FA6.2
0373A:  MOVLB  F
0373C:  MOVLW  55
0373E:  MOVWF  FA7
03740:  MOVLW  AA
03742:  MOVWF  FA7
03744:  BSF    FA6.1
03746:  BTFSC  FA6.1
03748:  BRA    3746
0374A:  BCF    FA6.2
0374C:  MOVF   00,W
0374E:  IORWF  FF2,F
....................                   break;
03750:  BRA    37E0
....................                }
03752:  BRA    37C8
03754:  MOVLB  7
....................                else
....................                {
....................                   SMS_Massage4[j] = RxD_Buff[i];
03756:  MOVLW  F1
03758:  ADDWF  xD4,W
0375A:  MOVWF  01
0375C:  MOVLW  05
0375E:  ADDWFC xD5,W
03760:  MOVWF  03
03762:  MOVLW  73
03764:  ADDWF  xD2,W
03766:  MOVWF  FE9
03768:  MOVLW  01
0376A:  ADDWFC xD3,W
0376C:  MOVWF  FEA
0376E:  MOVFF  FEF,7DA
03772:  MOVFF  03,FEA
03776:  MOVFF  01,FE9
0377A:  MOVFF  7DA,FEF
....................                   write_eeprom(0x5D+i,RxD_Buff[i]);
0377E:  MOVLW  5D
03780:  ADDWF  xD2,W
03782:  MOVWF  xD8
03784:  MOVLW  00
03786:  ADDWFC xD3,W
03788:  MOVWF  xD9
0378A:  MOVLW  73
0378C:  ADDWF  xD2,W
0378E:  MOVWF  FE9
03790:  MOVLW  01
03792:  ADDWFC xD3,W
03794:  MOVWF  FEA
03796:  MOVFF  FEF,7DA
0379A:  MOVF   FF2,W
0379C:  MOVWF  00
0379E:  BCF    FF2.7
037A0:  MOVFF  7D9,FAA
037A4:  MOVFF  7D8,FA9
037A8:  MOVFF  7DA,FA8
037AC:  BCF    FA6.6
037AE:  BCF    FA6.7
037B0:  BSF    FA6.2
037B2:  MOVLB  F
037B4:  MOVLW  55
037B6:  MOVWF  FA7
037B8:  MOVLW  AA
037BA:  MOVWF  FA7
037BC:  BSF    FA6.1
037BE:  BTFSC  FA6.1
037C0:  BRA    37BE
037C2:  BCF    FA6.2
037C4:  MOVF   00,W
037C6:  IORWF  FF2,F
....................                }
037C8:  MOVLB  7
037CA:  MOVFF  7D3,03
037CE:  MOVF   xD2,W
037D0:  INCF   xD2,F
037D2:  BTFSC  FD8.2
037D4:  INCF   xD3,F
037D6:  INCF   xD4,F
037D8:  BTFSC  FD8.2
037DA:  INCF   xD5,F
037DC:  BRA    36E8
037DE:  MOVLB  F
....................             }
....................             SMS_Massage4[j] = '\0' ; // end string
037E0:  MOVLW  F1
037E2:  MOVLB  7
037E4:  ADDWF  xD4,W
037E6:  MOVWF  FE9
037E8:  MOVLW  05
037EA:  ADDWFC xD5,W
037EC:  MOVWF  FEA
037EE:  CLRF   FEF
....................             
....................             j=0;
037F0:  CLRF   xD5
037F2:  CLRF   xD4
....................             i++;
037F4:  INCF   xD2,F
037F6:  BTFSC  FD8.2
037F8:  INCF   xD3,F
....................             
....................             for(; ; i++,j++)
....................             {
....................                restart_wdt();
037FA:  CLRWDT
....................                if((RxD_Buff[i] == 0x0D) || (j > 30))
037FC:  MOVLW  73
037FE:  ADDWF  xD2,W
03800:  MOVWF  FE9
03802:  MOVLW  01
03804:  ADDWFC xD3,W
03806:  MOVWF  FEA
03808:  MOVF   FEF,W
0380A:  SUBLW  0D
0380C:  BZ    3818
0380E:  MOVF   xD5,F
03810:  BNZ   3818
03812:  MOVF   xD4,W
03814:  SUBLW  1E
03816:  BC    3868
....................                {
....................                   write_eeprom(0x5D+i,RxD_Buff[i]);
03818:  MOVLW  5D
0381A:  ADDWF  xD2,W
0381C:  MOVWF  xD8
0381E:  MOVLW  00
03820:  ADDWFC xD3,W
03822:  MOVWF  xD9
03824:  MOVLW  73
03826:  ADDWF  xD2,W
03828:  MOVWF  FE9
0382A:  MOVLW  01
0382C:  ADDWFC xD3,W
0382E:  MOVWF  FEA
03830:  MOVFF  FEF,7DA
03834:  MOVF   FF2,W
03836:  MOVWF  00
03838:  BCF    FF2.7
0383A:  MOVFF  7D9,FAA
0383E:  MOVFF  7D8,FA9
03842:  MOVFF  7DA,FA8
03846:  BCF    FA6.6
03848:  BCF    FA6.7
0384A:  BSF    FA6.2
0384C:  MOVLB  F
0384E:  MOVLW  55
03850:  MOVWF  FA7
03852:  MOVLW  AA
03854:  MOVWF  FA7
03856:  BSF    FA6.1
03858:  BTFSC  FA6.1
0385A:  BRA    3858
0385C:  BCF    FA6.2
0385E:  MOVF   00,W
03860:  IORWF  FF2,F
....................                   break;
03862:  BRA    38F2
....................                }
03864:  BRA    38DA
03866:  MOVLB  7
....................                else
....................                {
....................                   SMS_Massage5[j] = RxD_Buff[i];
03868:  MOVLW  11
0386A:  ADDWF  xD4,W
0386C:  MOVWF  01
0386E:  MOVLW  06
03870:  ADDWFC xD5,W
03872:  MOVWF  03
03874:  MOVLW  73
03876:  ADDWF  xD2,W
03878:  MOVWF  FE9
0387A:  MOVLW  01
0387C:  ADDWFC xD3,W
0387E:  MOVWF  FEA
03880:  MOVFF  FEF,7DA
03884:  MOVFF  03,FEA
03888:  MOVFF  01,FE9
0388C:  MOVFF  7DA,FEF
....................                   write_eeprom(0x5D+i,RxD_Buff[i]);
03890:  MOVLW  5D
03892:  ADDWF  xD2,W
03894:  MOVWF  xD8
03896:  MOVLW  00
03898:  ADDWFC xD3,W
0389A:  MOVWF  xD9
0389C:  MOVLW  73
0389E:  ADDWF  xD2,W
038A0:  MOVWF  FE9
038A2:  MOVLW  01
038A4:  ADDWFC xD3,W
038A6:  MOVWF  FEA
038A8:  MOVFF  FEF,7DA
038AC:  MOVF   FF2,W
038AE:  MOVWF  00
038B0:  BCF    FF2.7
038B2:  MOVFF  7D9,FAA
038B6:  MOVFF  7D8,FA9
038BA:  MOVFF  7DA,FA8
038BE:  BCF    FA6.6
038C0:  BCF    FA6.7
038C2:  BSF    FA6.2
038C4:  MOVLB  F
038C6:  MOVLW  55
038C8:  MOVWF  FA7
038CA:  MOVLW  AA
038CC:  MOVWF  FA7
038CE:  BSF    FA6.1
038D0:  BTFSC  FA6.1
038D2:  BRA    38D0
038D4:  BCF    FA6.2
038D6:  MOVF   00,W
038D8:  IORWF  FF2,F
....................                }
038DA:  MOVLB  7
038DC:  MOVFF  7D3,03
038E0:  MOVF   xD2,W
038E2:  INCF   xD2,F
038E4:  BTFSC  FD8.2
038E6:  INCF   xD3,F
038E8:  INCF   xD4,F
038EA:  BTFSC  FD8.2
038EC:  INCF   xD5,F
038EE:  BRA    37FA
038F0:  MOVLB  F
....................             }
....................             SMS_Massage5[j] = '\0' ; // end string
038F2:  MOVLW  11
038F4:  MOVLB  7
038F6:  ADDWF  xD4,W
038F8:  MOVWF  FE9
038FA:  MOVLW  06
038FC:  ADDWFC xD5,W
038FE:  MOVWF  FEA
03900:  CLRF   FEF
....................             
....................             j=0;
03902:  CLRF   xD5
03904:  CLRF   xD4
....................             i++;
03906:  INCF   xD2,F
03908:  BTFSC  FD8.2
0390A:  INCF   xD3,F
....................             
....................             for(; ; i++,j++)
....................             {
....................                restart_wdt();
0390C:  CLRWDT
....................                if((RxD_Buff[i] == 0x0D) || (j > 30))
0390E:  MOVLW  73
03910:  ADDWF  xD2,W
03912:  MOVWF  FE9
03914:  MOVLW  01
03916:  ADDWFC xD3,W
03918:  MOVWF  FEA
0391A:  MOVF   FEF,W
0391C:  SUBLW  0D
0391E:  BZ    392A
03920:  MOVF   xD5,F
03922:  BNZ   392A
03924:  MOVF   xD4,W
03926:  SUBLW  1E
03928:  BC    397A
....................                {
....................                   write_eeprom(0x5D+i,RxD_Buff[i]);
0392A:  MOVLW  5D
0392C:  ADDWF  xD2,W
0392E:  MOVWF  xD8
03930:  MOVLW  00
03932:  ADDWFC xD3,W
03934:  MOVWF  xD9
03936:  MOVLW  73
03938:  ADDWF  xD2,W
0393A:  MOVWF  FE9
0393C:  MOVLW  01
0393E:  ADDWFC xD3,W
03940:  MOVWF  FEA
03942:  MOVFF  FEF,7DA
03946:  MOVF   FF2,W
03948:  MOVWF  00
0394A:  BCF    FF2.7
0394C:  MOVFF  7D9,FAA
03950:  MOVFF  7D8,FA9
03954:  MOVFF  7DA,FA8
03958:  BCF    FA6.6
0395A:  BCF    FA6.7
0395C:  BSF    FA6.2
0395E:  MOVLB  F
03960:  MOVLW  55
03962:  MOVWF  FA7
03964:  MOVLW  AA
03966:  MOVWF  FA7
03968:  BSF    FA6.1
0396A:  BTFSC  FA6.1
0396C:  BRA    396A
0396E:  BCF    FA6.2
03970:  MOVF   00,W
03972:  IORWF  FF2,F
....................                   break;
03974:  BRA    3A08
....................                }
03976:  BRA    39F0
03978:  MOVLB  7
....................                else
....................                {
....................                   write_eeprom(0x5D+i,RxD_Buff[i]);
0397A:  MOVLW  5D
0397C:  ADDWF  xD2,W
0397E:  MOVWF  xD8
03980:  MOVLW  00
03982:  ADDWFC xD3,W
03984:  MOVWF  xD9
03986:  MOVLW  73
03988:  ADDWF  xD2,W
0398A:  MOVWF  FE9
0398C:  MOVLW  01
0398E:  ADDWFC xD3,W
03990:  MOVWF  FEA
03992:  MOVFF  FEF,7DA
03996:  MOVF   FF2,W
03998:  MOVWF  00
0399A:  BCF    FF2.7
0399C:  MOVFF  7D9,FAA
039A0:  MOVFF  7D8,FA9
039A4:  MOVFF  7DA,FA8
039A8:  BCF    FA6.6
039AA:  BCF    FA6.7
039AC:  BSF    FA6.2
039AE:  MOVLB  F
039B0:  MOVLW  55
039B2:  MOVWF  FA7
039B4:  MOVLW  AA
039B6:  MOVWF  FA7
039B8:  BSF    FA6.1
039BA:  BTFSC  FA6.1
039BC:  BRA    39BA
039BE:  BCF    FA6.2
039C0:  MOVF   00,W
039C2:  IORWF  FF2,F
....................                   SMS_Massage6[j] = RxD_Buff[i];
039C4:  MOVLW  31
039C6:  MOVLB  7
039C8:  ADDWF  xD4,W
039CA:  MOVWF  01
039CC:  MOVLW  06
039CE:  ADDWFC xD5,W
039D0:  MOVWF  03
039D2:  MOVLW  73
039D4:  ADDWF  xD2,W
039D6:  MOVWF  FE9
039D8:  MOVLW  01
039DA:  ADDWFC xD3,W
039DC:  MOVWF  FEA
039DE:  MOVFF  FEF,7DA
039E2:  MOVFF  03,FEA
039E6:  MOVFF  01,FE9
039EA:  MOVFF  7DA,FEF
039EE:  MOVLB  F
....................                }
039F0:  MOVLB  7
039F2:  MOVFF  7D3,03
039F6:  MOVF   xD2,W
039F8:  INCF   xD2,F
039FA:  BTFSC  FD8.2
039FC:  INCF   xD3,F
039FE:  INCF   xD4,F
03A00:  BTFSC  FD8.2
03A02:  INCF   xD5,F
03A04:  BRA    390C
03A06:  MOVLB  F
....................             }
....................             SMS_Massage6[j] = '\0' ; // end string
03A08:  MOVLW  31
03A0A:  MOVLB  7
03A0C:  ADDWF  xD4,W
03A0E:  MOVWF  FE9
03A10:  MOVLW  06
03A12:  ADDWFC xD5,W
03A14:  MOVWF  FEA
03A16:  CLRF   FEF
....................             
....................             j=0;
03A18:  CLRF   xD5
03A1A:  CLRF   xD4
....................             i++;
03A1C:  INCF   xD2,F
03A1E:  BTFSC  FD8.2
03A20:  INCF   xD3,F
....................             
....................             for(; ; i++,j++)
....................             {
....................                restart_wdt();
03A22:  CLRWDT
....................                if((RxD_Buff[i] == 0x0D) || (j > 30))
03A24:  MOVLW  73
03A26:  ADDWF  xD2,W
03A28:  MOVWF  FE9
03A2A:  MOVLW  01
03A2C:  ADDWFC xD3,W
03A2E:  MOVWF  FEA
03A30:  MOVF   FEF,W
03A32:  SUBLW  0D
03A34:  BZ    3A40
03A36:  MOVF   xD5,F
03A38:  BNZ   3A40
03A3A:  MOVF   xD4,W
03A3C:  SUBLW  1E
03A3E:  BC    3A90
....................                {
....................                   write_eeprom(0x5D+i,RxD_Buff[i]);
03A40:  MOVLW  5D
03A42:  ADDWF  xD2,W
03A44:  MOVWF  xD8
03A46:  MOVLW  00
03A48:  ADDWFC xD3,W
03A4A:  MOVWF  xD9
03A4C:  MOVLW  73
03A4E:  ADDWF  xD2,W
03A50:  MOVWF  FE9
03A52:  MOVLW  01
03A54:  ADDWFC xD3,W
03A56:  MOVWF  FEA
03A58:  MOVFF  FEF,7DA
03A5C:  MOVF   FF2,W
03A5E:  MOVWF  00
03A60:  BCF    FF2.7
03A62:  MOVFF  7D9,FAA
03A66:  MOVFF  7D8,FA9
03A6A:  MOVFF  7DA,FA8
03A6E:  BCF    FA6.6
03A70:  BCF    FA6.7
03A72:  BSF    FA6.2
03A74:  MOVLB  F
03A76:  MOVLW  55
03A78:  MOVWF  FA7
03A7A:  MOVLW  AA
03A7C:  MOVWF  FA7
03A7E:  BSF    FA6.1
03A80:  BTFSC  FA6.1
03A82:  BRA    3A80
03A84:  BCF    FA6.2
03A86:  MOVF   00,W
03A88:  IORWF  FF2,F
....................                   break;
03A8A:  BRA    3B1A
....................                }
03A8C:  BRA    3B02
03A8E:  MOVLB  7
....................                else
....................                {
....................                   SMS_Massage7[j] = RxD_Buff[i];
03A90:  MOVLW  51
03A92:  ADDWF  xD4,W
03A94:  MOVWF  01
03A96:  MOVLW  06
03A98:  ADDWFC xD5,W
03A9A:  MOVWF  03
03A9C:  MOVLW  73
03A9E:  ADDWF  xD2,W
03AA0:  MOVWF  FE9
03AA2:  MOVLW  01
03AA4:  ADDWFC xD3,W
03AA6:  MOVWF  FEA
03AA8:  MOVFF  FEF,7DA
03AAC:  MOVFF  03,FEA
03AB0:  MOVFF  01,FE9
03AB4:  MOVFF  7DA,FEF
....................                   write_eeprom(0x5D+i,RxD_Buff[i]);
03AB8:  MOVLW  5D
03ABA:  ADDWF  xD2,W
03ABC:  MOVWF  xD8
03ABE:  MOVLW  00
03AC0:  ADDWFC xD3,W
03AC2:  MOVWF  xD9
03AC4:  MOVLW  73
03AC6:  ADDWF  xD2,W
03AC8:  MOVWF  FE9
03ACA:  MOVLW  01
03ACC:  ADDWFC xD3,W
03ACE:  MOVWF  FEA
03AD0:  MOVFF  FEF,7DA
03AD4:  MOVF   FF2,W
03AD6:  MOVWF  00
03AD8:  BCF    FF2.7
03ADA:  MOVFF  7D9,FAA
03ADE:  MOVFF  7D8,FA9
03AE2:  MOVFF  7DA,FA8
03AE6:  BCF    FA6.6
03AE8:  BCF    FA6.7
03AEA:  BSF    FA6.2
03AEC:  MOVLB  F
03AEE:  MOVLW  55
03AF0:  MOVWF  FA7
03AF2:  MOVLW  AA
03AF4:  MOVWF  FA7
03AF6:  BSF    FA6.1
03AF8:  BTFSC  FA6.1
03AFA:  BRA    3AF8
03AFC:  BCF    FA6.2
03AFE:  MOVF   00,W
03B00:  IORWF  FF2,F
....................                }
03B02:  MOVLB  7
03B04:  MOVFF  7D3,03
03B08:  MOVF   xD2,W
03B0A:  INCF   xD2,F
03B0C:  BTFSC  FD8.2
03B0E:  INCF   xD3,F
03B10:  INCF   xD4,F
03B12:  BTFSC  FD8.2
03B14:  INCF   xD5,F
03B16:  BRA    3A22
03B18:  MOVLB  F
....................             }
....................             SMS_Massage7[j] = '\0' ; // end string
03B1A:  MOVLW  51
03B1C:  MOVLB  7
03B1E:  ADDWF  xD4,W
03B20:  MOVWF  FE9
03B22:  MOVLW  06
03B24:  ADDWFC xD5,W
03B26:  MOVWF  FEA
03B28:  CLRF   FEF
....................             
....................             j=0;
03B2A:  CLRF   xD5
03B2C:  CLRF   xD4
....................             i++;
03B2E:  INCF   xD2,F
03B30:  BTFSC  FD8.2
03B32:  INCF   xD3,F
....................             
....................             for(; ; i++,j++)
....................             {
....................                restart_wdt();
03B34:  CLRWDT
....................                if((RxD_Buff[i] == 0x0D) || (j > 30))
03B36:  MOVLW  73
03B38:  ADDWF  xD2,W
03B3A:  MOVWF  FE9
03B3C:  MOVLW  01
03B3E:  ADDWFC xD3,W
03B40:  MOVWF  FEA
03B42:  MOVF   FEF,W
03B44:  SUBLW  0D
03B46:  BZ    3B52
03B48:  MOVF   xD5,F
03B4A:  BNZ   3B52
03B4C:  MOVF   xD4,W
03B4E:  SUBLW  1E
03B50:  BC    3BA2
....................                {
....................                   write_eeprom(0x5D+i,RxD_Buff[i]);
03B52:  MOVLW  5D
03B54:  ADDWF  xD2,W
03B56:  MOVWF  xD8
03B58:  MOVLW  00
03B5A:  ADDWFC xD3,W
03B5C:  MOVWF  xD9
03B5E:  MOVLW  73
03B60:  ADDWF  xD2,W
03B62:  MOVWF  FE9
03B64:  MOVLW  01
03B66:  ADDWFC xD3,W
03B68:  MOVWF  FEA
03B6A:  MOVFF  FEF,7DA
03B6E:  MOVF   FF2,W
03B70:  MOVWF  00
03B72:  BCF    FF2.7
03B74:  MOVFF  7D9,FAA
03B78:  MOVFF  7D8,FA9
03B7C:  MOVFF  7DA,FA8
03B80:  BCF    FA6.6
03B82:  BCF    FA6.7
03B84:  BSF    FA6.2
03B86:  MOVLB  F
03B88:  MOVLW  55
03B8A:  MOVWF  FA7
03B8C:  MOVLW  AA
03B8E:  MOVWF  FA7
03B90:  BSF    FA6.1
03B92:  BTFSC  FA6.1
03B94:  BRA    3B92
03B96:  BCF    FA6.2
03B98:  MOVF   00,W
03B9A:  IORWF  FF2,F
....................                   break;
03B9C:  BRA    3C2C
....................                }
03B9E:  BRA    3C14
03BA0:  MOVLB  7
....................                else
....................                {
....................                   SMS_Massage8[j] = RxD_Buff[i];
03BA2:  MOVLW  71
03BA4:  ADDWF  xD4,W
03BA6:  MOVWF  01
03BA8:  MOVLW  06
03BAA:  ADDWFC xD5,W
03BAC:  MOVWF  03
03BAE:  MOVLW  73
03BB0:  ADDWF  xD2,W
03BB2:  MOVWF  FE9
03BB4:  MOVLW  01
03BB6:  ADDWFC xD3,W
03BB8:  MOVWF  FEA
03BBA:  MOVFF  FEF,7DA
03BBE:  MOVFF  03,FEA
03BC2:  MOVFF  01,FE9
03BC6:  MOVFF  7DA,FEF
....................                   write_eeprom(0x5D+i,RxD_Buff[i]);
03BCA:  MOVLW  5D
03BCC:  ADDWF  xD2,W
03BCE:  MOVWF  xD8
03BD0:  MOVLW  00
03BD2:  ADDWFC xD3,W
03BD4:  MOVWF  xD9
03BD6:  MOVLW  73
03BD8:  ADDWF  xD2,W
03BDA:  MOVWF  FE9
03BDC:  MOVLW  01
03BDE:  ADDWFC xD3,W
03BE0:  MOVWF  FEA
03BE2:  MOVFF  FEF,7DA
03BE6:  MOVF   FF2,W
03BE8:  MOVWF  00
03BEA:  BCF    FF2.7
03BEC:  MOVFF  7D9,FAA
03BF0:  MOVFF  7D8,FA9
03BF4:  MOVFF  7DA,FA8
03BF8:  BCF    FA6.6
03BFA:  BCF    FA6.7
03BFC:  BSF    FA6.2
03BFE:  MOVLB  F
03C00:  MOVLW  55
03C02:  MOVWF  FA7
03C04:  MOVLW  AA
03C06:  MOVWF  FA7
03C08:  BSF    FA6.1
03C0A:  BTFSC  FA6.1
03C0C:  BRA    3C0A
03C0E:  BCF    FA6.2
03C10:  MOVF   00,W
03C12:  IORWF  FF2,F
....................                }
03C14:  MOVLB  7
03C16:  MOVFF  7D3,03
03C1A:  MOVF   xD2,W
03C1C:  INCF   xD2,F
03C1E:  BTFSC  FD8.2
03C20:  INCF   xD3,F
03C22:  INCF   xD4,F
03C24:  BTFSC  FD8.2
03C26:  INCF   xD5,F
03C28:  BRA    3B34
03C2A:  MOVLB  F
....................             }
....................             SMS_Massage8[j] = '\0' ; // end string
03C2C:  MOVLW  71
03C2E:  MOVLB  7
03C30:  ADDWF  xD4,W
03C32:  MOVWF  FE9
03C34:  MOVLW  06
03C36:  ADDWFC xD5,W
03C38:  MOVWF  FEA
03C3A:  CLRF   FEF
....................             
....................             /////////////////////////////////////////////
....................             j=0;
03C3C:  CLRF   xD5
03C3E:  CLRF   xD4
....................             i++;
03C40:  INCF   xD2,F
03C42:  BTFSC  FD8.2
03C44:  INCF   xD3,F
....................             
....................             for(; ; i++,j++)
....................             {
....................                restart_wdt();
03C46:  CLRWDT
....................                if((RxD_Buff[i] == 0x0D) || (j > 30))
03C48:  MOVLW  73
03C4A:  ADDWF  xD2,W
03C4C:  MOVWF  FE9
03C4E:  MOVLW  01
03C50:  ADDWFC xD3,W
03C52:  MOVWF  FEA
03C54:  MOVF   FEF,W
03C56:  SUBLW  0D
03C58:  BZ    3C64
03C5A:  MOVF   xD5,F
03C5C:  BNZ   3C64
03C5E:  MOVF   xD4,W
03C60:  SUBLW  1E
03C62:  BC    3CB4
....................                {
....................                   write_eeprom(0x5D+i,RxD_Buff[i]);
03C64:  MOVLW  5D
03C66:  ADDWF  xD2,W
03C68:  MOVWF  xD8
03C6A:  MOVLW  00
03C6C:  ADDWFC xD3,W
03C6E:  MOVWF  xD9
03C70:  MOVLW  73
03C72:  ADDWF  xD2,W
03C74:  MOVWF  FE9
03C76:  MOVLW  01
03C78:  ADDWFC xD3,W
03C7A:  MOVWF  FEA
03C7C:  MOVFF  FEF,7DA
03C80:  MOVF   FF2,W
03C82:  MOVWF  00
03C84:  BCF    FF2.7
03C86:  MOVFF  7D9,FAA
03C8A:  MOVFF  7D8,FA9
03C8E:  MOVFF  7DA,FA8
03C92:  BCF    FA6.6
03C94:  BCF    FA6.7
03C96:  BSF    FA6.2
03C98:  MOVLB  F
03C9A:  MOVLW  55
03C9C:  MOVWF  FA7
03C9E:  MOVLW  AA
03CA0:  MOVWF  FA7
03CA2:  BSF    FA6.1
03CA4:  BTFSC  FA6.1
03CA6:  BRA    3CA4
03CA8:  BCF    FA6.2
03CAA:  MOVF   00,W
03CAC:  IORWF  FF2,F
....................                   break;
03CAE:  BRA    3D3E
....................                }
03CB0:  BRA    3D26
03CB2:  MOVLB  7
....................                else
....................                {
....................                   SMS_Massage9[j] = RxD_Buff[i];
03CB4:  MOVLW  91
03CB6:  ADDWF  xD4,W
03CB8:  MOVWF  01
03CBA:  MOVLW  06
03CBC:  ADDWFC xD5,W
03CBE:  MOVWF  03
03CC0:  MOVLW  73
03CC2:  ADDWF  xD2,W
03CC4:  MOVWF  FE9
03CC6:  MOVLW  01
03CC8:  ADDWFC xD3,W
03CCA:  MOVWF  FEA
03CCC:  MOVFF  FEF,7DA
03CD0:  MOVFF  03,FEA
03CD4:  MOVFF  01,FE9
03CD8:  MOVFF  7DA,FEF
....................                   write_eeprom(0x5D+i,RxD_Buff[i]);
03CDC:  MOVLW  5D
03CDE:  ADDWF  xD2,W
03CE0:  MOVWF  xD8
03CE2:  MOVLW  00
03CE4:  ADDWFC xD3,W
03CE6:  MOVWF  xD9
03CE8:  MOVLW  73
03CEA:  ADDWF  xD2,W
03CEC:  MOVWF  FE9
03CEE:  MOVLW  01
03CF0:  ADDWFC xD3,W
03CF2:  MOVWF  FEA
03CF4:  MOVFF  FEF,7DA
03CF8:  MOVF   FF2,W
03CFA:  MOVWF  00
03CFC:  BCF    FF2.7
03CFE:  MOVFF  7D9,FAA
03D02:  MOVFF  7D8,FA9
03D06:  MOVFF  7DA,FA8
03D0A:  BCF    FA6.6
03D0C:  BCF    FA6.7
03D0E:  BSF    FA6.2
03D10:  MOVLB  F
03D12:  MOVLW  55
03D14:  MOVWF  FA7
03D16:  MOVLW  AA
03D18:  MOVWF  FA7
03D1A:  BSF    FA6.1
03D1C:  BTFSC  FA6.1
03D1E:  BRA    3D1C
03D20:  BCF    FA6.2
03D22:  MOVF   00,W
03D24:  IORWF  FF2,F
....................                }
03D26:  MOVLB  7
03D28:  MOVFF  7D3,03
03D2C:  MOVF   xD2,W
03D2E:  INCF   xD2,F
03D30:  BTFSC  FD8.2
03D32:  INCF   xD3,F
03D34:  INCF   xD4,F
03D36:  BTFSC  FD8.2
03D38:  INCF   xD5,F
03D3A:  BRA    3C46
03D3C:  MOVLB  F
....................             }
....................             SMS_Massage9[j] = '\0' ; // end string
03D3E:  MOVLW  91
03D40:  MOVLB  7
03D42:  ADDWF  xD4,W
03D44:  MOVWF  FE9
03D46:  MOVLW  06
03D48:  ADDWFC xD5,W
03D4A:  MOVWF  FEA
03D4C:  CLRF   FEF
....................             j=0;
03D4E:  CLRF   xD5
03D50:  CLRF   xD4
....................             i++;
03D52:  INCF   xD2,F
03D54:  BTFSC  FD8.2
03D56:  INCF   xD3,F
....................             
....................             for(; ; i++,j++)
....................             {
....................                restart_wdt();
03D58:  CLRWDT
....................                if((RxD_Buff[i] == 0x0D) || (j > 30))
03D5A:  MOVLW  73
03D5C:  ADDWF  xD2,W
03D5E:  MOVWF  FE9
03D60:  MOVLW  01
03D62:  ADDWFC xD3,W
03D64:  MOVWF  FEA
03D66:  MOVF   FEF,W
03D68:  SUBLW  0D
03D6A:  BZ    3D76
03D6C:  MOVF   xD5,F
03D6E:  BNZ   3D76
03D70:  MOVF   xD4,W
03D72:  SUBLW  1E
03D74:  BC    3DC6
....................                {
....................                   write_eeprom(0x5D+i,RxD_Buff[i]);
03D76:  MOVLW  5D
03D78:  ADDWF  xD2,W
03D7A:  MOVWF  xD8
03D7C:  MOVLW  00
03D7E:  ADDWFC xD3,W
03D80:  MOVWF  xD9
03D82:  MOVLW  73
03D84:  ADDWF  xD2,W
03D86:  MOVWF  FE9
03D88:  MOVLW  01
03D8A:  ADDWFC xD3,W
03D8C:  MOVWF  FEA
03D8E:  MOVFF  FEF,7DA
03D92:  MOVF   FF2,W
03D94:  MOVWF  00
03D96:  BCF    FF2.7
03D98:  MOVFF  7D9,FAA
03D9C:  MOVFF  7D8,FA9
03DA0:  MOVFF  7DA,FA8
03DA4:  BCF    FA6.6
03DA6:  BCF    FA6.7
03DA8:  BSF    FA6.2
03DAA:  MOVLB  F
03DAC:  MOVLW  55
03DAE:  MOVWF  FA7
03DB0:  MOVLW  AA
03DB2:  MOVWF  FA7
03DB4:  BSF    FA6.1
03DB6:  BTFSC  FA6.1
03DB8:  BRA    3DB6
03DBA:  BCF    FA6.2
03DBC:  MOVF   00,W
03DBE:  IORWF  FF2,F
....................                   break;
03DC0:  BRA    3E50
....................                }
03DC2:  BRA    3E38
03DC4:  MOVLB  7
....................                else
....................                {
....................                   SMS_Massage10[j] = RxD_Buff[i];
03DC6:  MOVLW  B1
03DC8:  ADDWF  xD4,W
03DCA:  MOVWF  01
03DCC:  MOVLW  06
03DCE:  ADDWFC xD5,W
03DD0:  MOVWF  03
03DD2:  MOVLW  73
03DD4:  ADDWF  xD2,W
03DD6:  MOVWF  FE9
03DD8:  MOVLW  01
03DDA:  ADDWFC xD3,W
03DDC:  MOVWF  FEA
03DDE:  MOVFF  FEF,7DA
03DE2:  MOVFF  03,FEA
03DE6:  MOVFF  01,FE9
03DEA:  MOVFF  7DA,FEF
....................                   write_eeprom(0x5D+i,RxD_Buff[i]);
03DEE:  MOVLW  5D
03DF0:  ADDWF  xD2,W
03DF2:  MOVWF  xD8
03DF4:  MOVLW  00
03DF6:  ADDWFC xD3,W
03DF8:  MOVWF  xD9
03DFA:  MOVLW  73
03DFC:  ADDWF  xD2,W
03DFE:  MOVWF  FE9
03E00:  MOVLW  01
03E02:  ADDWFC xD3,W
03E04:  MOVWF  FEA
03E06:  MOVFF  FEF,7DA
03E0A:  MOVF   FF2,W
03E0C:  MOVWF  00
03E0E:  BCF    FF2.7
03E10:  MOVFF  7D9,FAA
03E14:  MOVFF  7D8,FA9
03E18:  MOVFF  7DA,FA8
03E1C:  BCF    FA6.6
03E1E:  BCF    FA6.7
03E20:  BSF    FA6.2
03E22:  MOVLB  F
03E24:  MOVLW  55
03E26:  MOVWF  FA7
03E28:  MOVLW  AA
03E2A:  MOVWF  FA7
03E2C:  BSF    FA6.1
03E2E:  BTFSC  FA6.1
03E30:  BRA    3E2E
03E32:  BCF    FA6.2
03E34:  MOVF   00,W
03E36:  IORWF  FF2,F
....................                }
03E38:  MOVLB  7
03E3A:  MOVFF  7D3,03
03E3E:  MOVF   xD2,W
03E40:  INCF   xD2,F
03E42:  BTFSC  FD8.2
03E44:  INCF   xD3,F
03E46:  INCF   xD4,F
03E48:  BTFSC  FD8.2
03E4A:  INCF   xD5,F
03E4C:  BRA    3D58
03E4E:  MOVLB  F
....................             }
....................             SMS_Massage10[j] = '\0' ; // end string
03E50:  MOVLW  B1
03E52:  MOVLB  7
03E54:  ADDWF  xD4,W
03E56:  MOVWF  FE9
03E58:  MOVLW  06
03E5A:  ADDWFC xD5,W
03E5C:  MOVWF  FEA
03E5E:  CLRF   FEF
....................             
....................          
....................             TxD_Buff[0] = Address ;         //Address
03E60:  MOVFF  70,73
....................             TxD_Buff[1] = 0x22 ;            //return function code
03E64:  MOVLW  22
03E66:  MOVLB  0
03E68:  MOVWF  x74
.................... 
....................             CRC(TxD_Buff,2)   ;            //Cal CRC 2 byte
03E6A:  MOVLB  7
03E6C:  CLRF   xDB
03E6E:  MOVLW  73
03E70:  MOVWF  xDA
03E72:  MOVLW  02
03E74:  MOVWF  xDC
03E76:  MOVLB  0
03E78:  CALL   1F50
.................... 
....................             TxD_Buff[2] = CRC_Hi ;
03E7C:  MOVFF  374,75
....................             TxD_Buff[3] = CRC_Lo ;
03E80:  MOVFF  373,76
.................... 
....................             output_bit(P485ctrl,1);
03E84:  BSF    F8A.3
03E86:  BCF    F93.3
....................             delay_ms(10);
03E88:  MOVLW  0A
03E8A:  MOVLB  7
03E8C:  MOVWF  xD8
03E8E:  MOVLB  0
03E90:  CALL   068A
.................... 
....................             putc(Txd_Buff[0]);
03E94:  MOVF   x73,W
03E96:  CALL   1FA6
....................             putc(Txd_Buff[1]);
03E9A:  MOVF   x74,W
03E9C:  CALL   1FA6
....................             putc(Txd_Buff[2]);
03EA0:  MOVF   x75,W
03EA2:  CALL   1FA6
....................             putc(Txd_Buff[3]);
03EA6:  MOVF   x76,W
03EA8:  CALL   1FA6
.................... 
....................             delay_ms(3);
03EAC:  MOVLW  03
03EAE:  MOVLB  7
03EB0:  MOVWF  xD8
03EB2:  MOVLB  0
03EB4:  CALL   068A
....................             output_bit(P485ctrl,0);
03EB8:  BCF    F8A.3
03EBA:  BCF    F93.3
03EBC:  MOVLB  1
....................          }
....................          /////////////////////////////////////////////////////////////////////////////////////
....................          
....................          if(RxD_Buff[1] == 0x03)///////////// READ HOLDING REGGISTER /////////////////////
03EBE:  MOVF   x74,W
03EC0:  SUBLW  03
03EC2:  BNZ   3F50
....................          {
.................... 
....................             Data_Buff[0] = Input9_10;// dummy data
03EC4:  MOVFF  4D,37C
....................             Data_Buff[1] = Input1_8;
03EC8:  MOVFF  4C,37D
....................             
....................             
....................             TxD_Buff[0] = Address ;         //Address
03ECC:  MOVFF  70,73
....................             TxD_Buff[1] = 0x03 ;           //Function Code
03ED0:  MOVLW  03
03ED2:  MOVLB  0
03ED4:  MOVWF  x74
....................             TxD_Buff[2] = 0x02 ;          //Byte Count
03ED6:  MOVLW  02
03ED8:  MOVWF  x75
....................             TxD_Buff[3] = Data_Buff[0];   //first byte Data
03EDA:  MOVFF  37C,76
....................             TxD_Buff[4] = Data_Buff[1];   //first byte Data
03EDE:  MOVFF  37D,77
.................... 
....................             CRC(TxD_Buff,5)   ;            //Cal CRC 5 Byte
03EE2:  MOVLB  7
03EE4:  CLRF   xDB
03EE6:  MOVLW  73
03EE8:  MOVWF  xDA
03EEA:  MOVLW  05
03EEC:  MOVWF  xDC
03EEE:  MOVLB  0
03EF0:  CALL   1F50
.................... 
....................             TxD_Buff[5] = CRC_Hi ;
03EF4:  MOVFF  374,78
....................             TxD_Buff[6] = CRC_Lo ;
03EF8:  MOVFF  373,79
.................... 
....................             output_bit(P485ctrl,1);
03EFC:  BSF    F8A.3
03EFE:  BCF    F93.3
....................             restart_wdt();
03F00:  CLRWDT
....................             delay_ms(4);
03F02:  MOVLW  04
03F04:  MOVLB  7
03F06:  MOVWF  xD8
03F08:  MOVLB  0
03F0A:  CALL   068A
....................             restart_wdt();
03F0E:  CLRWDT
.................... 
....................             putc(TxD_Buff[0]) ;               //Address
03F10:  MOVF   x73,W
03F12:  CALL   1FA6
....................             putc(TxD_Buff[1]) ;               //Function Code
03F16:  MOVF   x74,W
03F18:  CALL   1FA6
....................             putc(TxD_Buff[2]) ;               //Byte Count
03F1C:  MOVF   x75,W
03F1E:  CALL   1FA6
....................             putc(TxD_Buff[3]) ;
03F22:  MOVF   x76,W
03F24:  CALL   1FA6
....................             putc(TxD_Buff[4]) ;
03F28:  MOVF   x77,W
03F2A:  CALL   1FA6
....................             putc(TxD_Buff[5]) ;
03F2E:  MOVF   x78,W
03F30:  CALL   1FA6
....................             putc(TxD_Buff[6]) ;
03F34:  MOVF   x79,W
03F36:  CALL   1FA6
....................             
....................             restart_wdt();
03F3A:  CLRWDT
....................             delay_ms(3);
03F3C:  MOVLW  03
03F3E:  MOVLB  7
03F40:  MOVWF  xD8
03F42:  MOVLB  0
03F44:  CALL   068A
....................             restart_wdt();
03F48:  CLRWDT
....................             output_bit(P485ctrl,0);
03F4A:  BCF    F8A.3
03F4C:  BCF    F93.3
03F4E:  MOVLB  1
....................          }
....................       }  
.................... 
....................       Send_check_Time = 500; //5 Second
03F50:  MOVLW  01
03F52:  MOVLB  3
03F54:  MOVWF  x76
03F56:  MOVLW  F4
03F58:  MOVWF  x75
....................    }
.................... 
....................    recieve_completed = 0 ;
03F5A:  BCF    32.6
....................    sequence = end_sq ;
03F5C:  MOVFF  66,6F
....................    T_timeout = 0x00;
03F60:  MOVLB  5
03F62:  CLRF   x7E
....................    RxD_DataLen = 0x00 ;
03F64:  MOVLB  0
03F66:  CLRF   x72
03F68:  CLRF   x71
....................    output_bit(P485ctrl,0);
03F6A:  BCF    F8A.3
03F6C:  BCF    F93.3
03F6E:  GOTO   68E6 (RETURN)
.................... }
.................... 
.................... 
.................... ////////////////////////////////////////////////////////////////////
.................... 
.................... void Read_Input(void)
.................... {
.................... 
....................     ///////////////////////--Edit--///////////////////
....................        MCP23s17_Ip_dat = IO_INPUT_A(IO_DEVICE_0);
*
016D2:  MOVLB  7
016D4:  CLRF   xD0
016D6:  MOVLB  0
016D8:  RCALL  15A4
016DA:  MOVFF  01,57C
....................           
....................       if (AutoTestFlag)  // TEST FROM MODBUS
016DE:  BTFSS  1C.4
016E0:  BRA    16E8
....................       {
....................          MCP23s17_Ip_dat = ~MCP23s17_Ip_dat;         
016E2:  MOVLB  5
016E4:  COMF   x7C,F
016E6:  MOVLB  0
....................       }
....................       
....................       FaultNow[11] = MCP23s17_Ip_dat;
016E8:  MOVLB  7
016EA:  BCF    x96.3
016EC:  MOVLB  5
016EE:  BTFSS  x7C.0
016F0:  BRA    16F8
016F2:  MOVLB  7
016F4:  BSF    x96.3
016F6:  MOVLB  5
....................       FaultNow[12] = MCP23s17_Ip_dat >> 1;
016F8:  BCF    FD8.0
016FA:  RRCF   x7C,W
016FC:  MOVLB  7
016FE:  BCF    x96.4
01700:  BTFSC  FE8.0
01702:  BSF    x96.4
....................       FaultNow[13] = MCP23s17_Ip_dat >> 2;
01704:  MOVLB  5
01706:  RRCF   x7C,W
01708:  MOVWF  00
0170A:  RRCF   00,F
0170C:  MOVLW  3F
0170E:  ANDWF  00,F
01710:  MOVLB  7
01712:  BCF    x96.5
01714:  BTFSC  00.0
01716:  BSF    x96.5
....................       FaultNow[14] = MCP23s17_Ip_dat >> 3;
01718:  MOVLB  5
0171A:  RRCF   x7C,W
0171C:  MOVWF  00
0171E:  RRCF   00,F
01720:  RRCF   00,F
01722:  MOVLW  1F
01724:  ANDWF  00,F
01726:  MOVLB  7
01728:  BCF    x96.6
0172A:  BTFSC  00.0
0172C:  BSF    x96.6
....................       FaultNow[15] = MCP23s17_Ip_dat >> 4;
0172E:  MOVLB  5
01730:  SWAPF  x7C,W
01732:  MOVWF  00
01734:  MOVLW  0F
01736:  ANDWF  00,F
01738:  MOVLB  7
0173A:  BCF    x96.7
0173C:  BTFSC  00.0
0173E:  BSF    x96.7
....................       FaultNow[16] = MCP23s17_Ip_dat >> 5;
01740:  MOVLB  5
01742:  SWAPF  x7C,W
01744:  MOVWF  00
01746:  RRCF   00,F
01748:  MOVLW  07
0174A:  ANDWF  00,F
0174C:  MOVLB  7
0174E:  BCF    x97.0
01750:  BTFSC  00.0
01752:  BSF    x97.0
....................       FaultNow[17] = MCP23s17_Ip_dat >> 6;
01754:  MOVLB  5
01756:  SWAPF  x7C,W
01758:  MOVWF  00
0175A:  RRCF   00,F
0175C:  RRCF   00,F
0175E:  MOVLW  03
01760:  ANDWF  00,F
01762:  MOVLB  7
01764:  BCF    x97.1
01766:  BTFSC  00.0
01768:  BSF    x97.1
....................       FaultNow[18] = MCP23s17_Ip_dat >> 7;
0176A:  CLRF   00
0176C:  MOVLB  5
0176E:  BTFSC  x7C.7
01770:  BSF    00.0
01772:  MOVLB  7
01774:  BCF    x97.2
01776:  BTFSC  00.0
01778:  BSF    x97.2
....................       
....................        MCP23s17_Ip_dat = IO_INPUT_B(IO_DEVICE_0);
0177A:  CLRF   xD0
0177C:  MOVLB  0
0177E:  RCALL  15C0
01780:  MOVFF  01,57C
....................       
....................       if (AutoTestFlag)  // TEST FROM MODBUS
01784:  BTFSS  1C.4
01786:  BRA    178E
....................       {
....................          MCP23s17_Ip_dat = ~MCP23s17_Ip_dat;
01788:  MOVLB  5
0178A:  COMF   x7C,F
0178C:  MOVLB  0
....................       }
....................       
....................       FaultNow[19] = MCP23s17_Ip_dat;
0178E:  MOVLB  7
01790:  BCF    x97.3
01792:  MOVLB  5
01794:  BTFSS  x7C.0
01796:  BRA    179E
01798:  MOVLB  7
0179A:  BSF    x97.3
0179C:  MOVLB  5
....................       FaultNow[20] = MCP23s17_Ip_dat >> 1;
0179E:  BCF    FD8.0
017A0:  RRCF   x7C,W
017A2:  MOVLB  7
017A4:  BCF    x97.4
017A6:  BTFSC  FE8.0
017A8:  BSF    x97.4
....................       
....................       
....................       MCP23s17_Ip_dat = IO_INPUT_A(IO_DEVICE_1);
017AA:  MOVLW  02
017AC:  MOVWF  xD0
017AE:  MOVLB  0
017B0:  RCALL  15A4
017B2:  MOVFF  01,57C
....................           
....................       if (AutoTestFlag)  // TEST FROM MODBUS
017B6:  BTFSS  1C.4
017B8:  BRA    17C0
....................       {
....................          MCP23s17_Ip_dat = ~MCP23s17_Ip_dat;
017BA:  MOVLB  5
017BC:  COMF   x7C,F
017BE:  MOVLB  0
....................          
....................       }
....................       
....................       FaultNow[1] = MCP23s17_Ip_dat;
017C0:  MOVLB  7
017C2:  BCF    x95.1
017C4:  MOVLB  5
017C6:  BTFSS  x7C.0
017C8:  BRA    17D0
017CA:  MOVLB  7
017CC:  BSF    x95.1
017CE:  MOVLB  5
....................       FaultNow[2] = MCP23s17_Ip_dat >> 1;
017D0:  BCF    FD8.0
017D2:  RRCF   x7C,W
017D4:  MOVLB  7
017D6:  BCF    x95.2
017D8:  BTFSC  FE8.0
017DA:  BSF    x95.2
....................       FaultNow[3] = MCP23s17_Ip_dat >> 2;
017DC:  MOVLB  5
017DE:  RRCF   x7C,W
017E0:  MOVWF  00
017E2:  RRCF   00,F
017E4:  MOVLW  3F
017E6:  ANDWF  00,F
017E8:  MOVLB  7
017EA:  BCF    x95.3
017EC:  BTFSC  00.0
017EE:  BSF    x95.3
....................       FaultNow[4] = MCP23s17_Ip_dat >> 3;
017F0:  MOVLB  5
017F2:  RRCF   x7C,W
017F4:  MOVWF  00
017F6:  RRCF   00,F
017F8:  RRCF   00,F
017FA:  MOVLW  1F
017FC:  ANDWF  00,F
017FE:  MOVLB  7
01800:  BCF    x95.4
01802:  BTFSC  00.0
01804:  BSF    x95.4
....................       FaultNow[5] = MCP23s17_Ip_dat >> 4;
01806:  MOVLB  5
01808:  SWAPF  x7C,W
0180A:  MOVWF  00
0180C:  MOVLW  0F
0180E:  ANDWF  00,F
01810:  MOVLB  7
01812:  BCF    x95.5
01814:  BTFSC  00.0
01816:  BSF    x95.5
....................       FaultNow[6] = MCP23s17_Ip_dat >> 5;
01818:  MOVLB  5
0181A:  SWAPF  x7C,W
0181C:  MOVWF  00
0181E:  RRCF   00,F
01820:  MOVLW  07
01822:  ANDWF  00,F
01824:  MOVLB  7
01826:  BCF    x95.6
01828:  BTFSC  00.0
0182A:  BSF    x95.6
....................       FaultNow[7] = MCP23s17_Ip_dat >> 6;
0182C:  MOVLB  5
0182E:  SWAPF  x7C,W
01830:  MOVWF  00
01832:  RRCF   00,F
01834:  RRCF   00,F
01836:  MOVLW  03
01838:  ANDWF  00,F
0183A:  MOVLB  7
0183C:  BCF    x95.7
0183E:  BTFSC  00.0
01840:  BSF    x95.7
....................       FaultNow[8] = MCP23s17_Ip_dat >> 7;
01842:  CLRF   00
01844:  MOVLB  5
01846:  BTFSC  x7C.7
01848:  BSF    00.0
0184A:  MOVLB  7
0184C:  BCF    x96.0
0184E:  BTFSC  00.0
01850:  BSF    x96.0
....................       
....................       MCP23s17_Ip_dat = IO_INPUT_B(IO_DEVICE_1);
01852:  MOVLW  02
01854:  MOVWF  xD0
01856:  MOVLB  0
01858:  RCALL  15C0
0185A:  MOVFF  01,57C
....................       
....................       if (AutoTestFlag)  // TEST FROM MODBUS
0185E:  BTFSS  1C.4
01860:  BRA    1868
....................       {
....................          MCP23s17_Ip_dat = ~MCP23s17_Ip_dat;
01862:  MOVLB  5
01864:  COMF   x7C,F
01866:  MOVLB  0
....................       }
....................       
....................       FaultNow[9] = MCP23s17_Ip_dat;
01868:  MOVLB  7
0186A:  BCF    x96.1
0186C:  MOVLB  5
0186E:  BTFSS  x7C.0
01870:  BRA    1878
01872:  MOVLB  7
01874:  BSF    x96.1
01876:  MOVLB  5
....................       FaultNow[10] = MCP23s17_Ip_dat >> 1;
01878:  BCF    FD8.0
0187A:  RRCF   x7C,W
0187C:  MOVLB  7
0187E:  BCF    x96.2
01880:  BTFSC  FE8.0
01882:  BSF    x96.2
....................       
....................       ///////////////---Anal Fault---//////////////////
....................       unsigned char i;
....................       for( i=1; i<=10; i++)
01884:  MOVLW  01
01886:  MOVWF  xCF
01888:  MOVF   xCF,W
0188A:  SUBLW  0A
0188C:  BTFSS  FD8.0
0188E:  BRA    1D68
....................       {
....................          if(FaultNCNO[i] ==NO)
01890:  MOVFF  7CF,7D3
01894:  MOVLW  07
01896:  MOVWF  xD5
01898:  MOVLW  C3
0189A:  MOVWF  xD4
0189C:  MOVLB  0
0189E:  RCALL  15DC
018A0:  MOVF   01,W
018A2:  ANDLW  01
018A4:  SUBLW  01
018A6:  BTFSS  FD8.2
018A8:  BRA    1AF8
....................          {
....................              if(FaultNow[i]==0)
018AA:  MOVFF  7CF,7D3
018AE:  MOVLW  07
018B0:  MOVLB  7
018B2:  MOVWF  xD5
018B4:  MOVLW  95
018B6:  MOVWF  xD4
018B8:  MOVLB  0
018BA:  RCALL  15DC
018BC:  MOVF   01,W
018BE:  ANDLW  01
018C0:  BTFSS  FD8.2
018C2:  BRA    19DE
....................              {   
....................                if(FaultAgo[i]==0)
018C4:  MOVFF  7CF,7D3
018C8:  MOVLW  07
018CA:  MOVLB  7
018CC:  MOVWF  xD5
018CE:  MOVLW  93
018D0:  MOVWF  xD4
018D2:  MOVLB  0
018D4:  RCALL  15DC
018D6:  MOVF   01,W
018D8:  ANDLW  01
018DA:  BTFSS  FD8.2
018DC:  BRA    19C2
....................                {
....................                    ReleaseTime[i]++;
018DE:  BCF    FD8.0
018E0:  MOVLB  7
018E2:  RLCF   xCF,W
018E4:  CLRF   03
018E6:  ADDLW  97
018E8:  MOVWF  FE9
018EA:  MOVLW  07
018EC:  ADDWFC 03,W
018EE:  MOVWF  FEA
018F0:  MOVLW  01
018F2:  ADDWF  FEE,F
018F4:  BNC   18F8
018F6:  INCF   FEF,F
....................                   
....................                    if(ReleaseTime[i]>=((FaultDelayTime[i]*75)+15)) //time per loop are 368 microSec. (1.89*10=200ms)
018F8:  BCF    FD8.0
018FA:  RLCF   xCF,W
018FC:  CLRF   03
018FE:  ADDLW  97
01900:  MOVWF  FE9
01902:  MOVLW  07
01904:  ADDWFC 03,W
01906:  MOVWF  FEA
01908:  MOVFF  FEC,7D1
0190C:  MOVF   FED,F
0190E:  MOVFF  FEF,7D0
01912:  BCF    FD8.0
01914:  RLCF   xCF,W
01916:  CLRF   03
01918:  ADDLW  AD
0191A:  MOVWF  FE9
0191C:  MOVLW  07
0191E:  ADDWFC 03,W
01920:  MOVWF  FEA
01922:  MOVFF  FEC,7D5
01926:  MOVF   FED,F
01928:  MOVFF  FEF,7D4
0192C:  CLRF   xD7
0192E:  MOVLW  4B
01930:  MOVWF  xD6
01932:  MOVLB  0
01934:  RCALL  1612
01936:  MOVFF  02,7D3
0193A:  MOVFF  01,7D2
0193E:  MOVLW  0F
01940:  MOVLB  7
01942:  ADDWF  01,W
01944:  MOVWF  01
01946:  MOVLW  00
01948:  ADDWFC 02,W
0194A:  MOVWF  03
0194C:  MOVF   03,W
0194E:  SUBWF  xD1,W
01950:  BNC   19BE
01952:  BNZ   195A
01954:  MOVF   01,W
01956:  SUBWF  xD0,W
01958:  BNC   19BE
....................                    {   
....................                      ReleaseTime[i] = 0;
0195A:  BCF    FD8.0
0195C:  RLCF   xCF,W
0195E:  CLRF   03
01960:  ADDLW  97
01962:  MOVWF  FE9
01964:  MOVLW  07
01966:  ADDWFC 03,W
01968:  MOVWF  FEA
0196A:  CLRF   FEC
0196C:  MOVF   FED,F
0196E:  CLRF   FEF
....................                      switch(i)
01970:  MOVLW  01
01972:  SUBWF  xCF,W
01974:  ADDLW  F6
01976:  BC    19BE
01978:  ADDLW  0A
0197A:  MOVLB  0
0197C:  GOTO   1E06
....................                      {
....................                         case 1:
....................                            Inputt.B1 = 0; 
01980:  MOVLB  7
01982:  BCF    x75.0
....................                         break;
01984:  BRA    19BE
....................                         case 2:
....................                            Inputt.B2 = 0; 
01986:  MOVLB  7
01988:  BCF    x75.1
....................                         break;
0198A:  BRA    19BE
....................                         case 3:
....................                            Inputt.B3 = 0; 
0198C:  MOVLB  7
0198E:  BCF    x75.2
....................                         break;
01990:  BRA    19BE
....................                         case 4:
....................                            Inputt.B4 = 0; 
01992:  MOVLB  7
01994:  BCF    x75.3
....................                         break;
01996:  BRA    19BE
....................                         case 5:
....................                            Inputt.B5 = 0; 
01998:  MOVLB  7
0199A:  BCF    x75.4
....................                         break;
0199C:  BRA    19BE
....................                         case 6:
....................                            Inputt.B6 = 0; 
0199E:  MOVLB  7
019A0:  BCF    x75.5
....................                         break;
019A2:  BRA    19BE
....................                         case 7:
....................                            Inputt.B7 = 0; 
019A4:  MOVLB  7
019A6:  BCF    x75.6
....................                          break;
019A8:  BRA    19BE
....................                          case 8:
....................                            Inputt.B8 = 0; 
019AA:  MOVLB  7
019AC:  BCF    x75.7
....................                         break;
019AE:  BRA    19BE
....................                         case 9:
....................                            Inputt.B9 = 0; 
019B0:  MOVLB  7
019B2:  BCF    x76.0
....................                         break;
019B4:  BRA    19BE
....................                         case 10:
....................                            Inputt.B10 = 0; 
019B6:  MOVLB  7
019B8:  BCF    x76.1
....................                         break;
019BA:  BRA    19BE
019BC:  MOVLB  7
....................         
....................                      }                 
....................                    }
....................                }
019BE:  BRA    19DA
019C0:  MOVLB  0
....................                else
....................                {
....................                   ReleaseTime[i] = 0;
019C2:  BCF    FD8.0
019C4:  MOVLB  7
019C6:  RLCF   xCF,W
019C8:  CLRF   03
019CA:  ADDLW  97
019CC:  MOVWF  FE9
019CE:  MOVLW  07
019D0:  ADDWFC 03,W
019D2:  MOVWF  FEA
019D4:  CLRF   FEC
019D6:  MOVF   FED,F
019D8:  CLRF   FEF
....................                }
....................              }
019DA:  BRA    1AF6
019DC:  MOVLB  0
....................              else //if(FaultNow[i]==1
....................              {
....................                if(FaultAgo[i]==1)
019DE:  MOVFF  7CF,7D3
019E2:  MOVLW  07
019E4:  MOVLB  7
019E6:  MOVWF  xD5
019E8:  MOVLW  93
019EA:  MOVWF  xD4
019EC:  MOVLB  0
019EE:  RCALL  15DC
019F0:  MOVF   01,W
019F2:  ANDLW  01
019F4:  SUBLW  01
019F6:  BTFSS  FD8.2
019F8:  BRA    1ADE
....................                {
....................                    ReleaseTime[i]++;
019FA:  BCF    FD8.0
019FC:  MOVLB  7
019FE:  RLCF   xCF,W
01A00:  CLRF   03
01A02:  ADDLW  97
01A04:  MOVWF  FE9
01A06:  MOVLW  07
01A08:  ADDWFC 03,W
01A0A:  MOVWF  FEA
01A0C:  MOVLW  01
01A0E:  ADDWF  FEE,F
01A10:  BNC   1A14
01A12:  INCF   FEF,F
....................                   
....................                    if(ReleaseTime[i]>=((FaultDelayTime[i]*75)+15)) //time per loop are 368 microSec. (1.89*10=200ms)
01A14:  BCF    FD8.0
01A16:  RLCF   xCF,W
01A18:  CLRF   03
01A1A:  ADDLW  97
01A1C:  MOVWF  FE9
01A1E:  MOVLW  07
01A20:  ADDWFC 03,W
01A22:  MOVWF  FEA
01A24:  MOVFF  FEC,7D1
01A28:  MOVF   FED,F
01A2A:  MOVFF  FEF,7D0
01A2E:  BCF    FD8.0
01A30:  RLCF   xCF,W
01A32:  CLRF   03
01A34:  ADDLW  AD
01A36:  MOVWF  FE9
01A38:  MOVLW  07
01A3A:  ADDWFC 03,W
01A3C:  MOVWF  FEA
01A3E:  MOVFF  FEC,7D5
01A42:  MOVF   FED,F
01A44:  MOVFF  FEF,7D4
01A48:  CLRF   xD7
01A4A:  MOVLW  4B
01A4C:  MOVWF  xD6
01A4E:  MOVLB  0
01A50:  RCALL  1612
01A52:  MOVFF  02,7D3
01A56:  MOVFF  01,7D2
01A5A:  MOVLW  0F
01A5C:  MOVLB  7
01A5E:  ADDWF  01,W
01A60:  MOVWF  01
01A62:  MOVLW  00
01A64:  ADDWFC 02,W
01A66:  MOVWF  03
01A68:  MOVF   03,W
01A6A:  SUBWF  xD1,W
01A6C:  BNC   1ADA
01A6E:  BNZ   1A76
01A70:  MOVF   01,W
01A72:  SUBWF  xD0,W
01A74:  BNC   1ADA
....................                    {   
....................                      ReleaseTime[i] = 1;
01A76:  BCF    FD8.0
01A78:  RLCF   xCF,W
01A7A:  CLRF   03
01A7C:  ADDLW  97
01A7E:  MOVWF  FE9
01A80:  MOVLW  07
01A82:  ADDWFC 03,W
01A84:  MOVWF  FEA
01A86:  CLRF   FEC
01A88:  MOVF   FED,F
01A8A:  MOVLW  01
01A8C:  MOVWF  FEF
....................                      switch(i)
01A8E:  SUBWF  xCF,W
01A90:  ADDLW  F6
01A92:  BC    1ADA
01A94:  ADDLW  0A
01A96:  MOVLB  0
01A98:  GOTO   1E34
....................                      {
....................                         case 1:
....................                            Inputt.B1 = 1; 
01A9C:  MOVLB  7
01A9E:  BSF    x75.0
....................                         break;
01AA0:  BRA    1ADA
....................                         case 2:
....................                            Inputt.B2 = 1; 
01AA2:  MOVLB  7
01AA4:  BSF    x75.1
....................                         break;
01AA6:  BRA    1ADA
....................                         case 3:
....................                            Inputt.B3 = 1; 
01AA8:  MOVLB  7
01AAA:  BSF    x75.2
....................                         break;
01AAC:  BRA    1ADA
....................                         case 4:
....................                            Inputt.B4 = 1; 
01AAE:  MOVLB  7
01AB0:  BSF    x75.3
....................                         break;
01AB2:  BRA    1ADA
....................                         case 5:
....................                            Inputt.B5 = 1; 
01AB4:  MOVLB  7
01AB6:  BSF    x75.4
....................                         break;
01AB8:  BRA    1ADA
....................                         case 6:
....................                            Inputt.B6 = 1; 
01ABA:  MOVLB  7
01ABC:  BSF    x75.5
....................                         break;
01ABE:  BRA    1ADA
....................                         case 7:
....................                            Inputt.B7 = 1; 
01AC0:  MOVLB  7
01AC2:  BSF    x75.6
....................                          break;
01AC4:  BRA    1ADA
....................                          case 8:
....................                            Inputt.B8 = 1; 
01AC6:  MOVLB  7
01AC8:  BSF    x75.7
....................                         break;
01ACA:  BRA    1ADA
....................                         case 9:
....................                            Inputt.B9 = 1; 
01ACC:  MOVLB  7
01ACE:  BSF    x76.0
....................                         break;
01AD0:  BRA    1ADA
....................                         case 10:
....................                            Inputt.B10 = 1; 
01AD2:  MOVLB  7
01AD4:  BSF    x76.1
....................                         break;
01AD6:  BRA    1ADA
01AD8:  MOVLB  7
....................          
....................                      }                 
....................                    }
....................                }
01ADA:  BRA    1AF6
01ADC:  MOVLB  0
....................                else
....................                {
....................                   ReleaseTime[i] = 0;
01ADE:  BCF    FD8.0
01AE0:  MOVLB  7
01AE2:  RLCF   xCF,W
01AE4:  CLRF   03
01AE6:  ADDLW  97
01AE8:  MOVWF  FE9
01AEA:  MOVLW  07
01AEC:  ADDWFC 03,W
01AEE:  MOVWF  FEA
01AF0:  CLRF   FEC
01AF2:  MOVF   FED,F
01AF4:  CLRF   FEF
....................                }
.................... 
....................              }
....................           }
01AF6:  BRA    1D60
....................           else if(FaultNCNO[i] ==NC)
01AF8:  MOVFF  7CF,7D3
01AFC:  MOVLW  07
01AFE:  MOVLB  7
01B00:  MOVWF  xD5
01B02:  MOVLW  C3
01B04:  MOVWF  xD4
01B06:  MOVLB  0
01B08:  RCALL  15DC
01B0A:  MOVF   01,W
01B0C:  ANDLW  01
01B0E:  BTFSS  FD8.2
01B10:  BRA    1D62
....................           {
....................              if(FaultNow[i]==1)
01B12:  MOVFF  7CF,7D3
01B16:  MOVLW  07
01B18:  MOVLB  7
01B1A:  MOVWF  xD5
01B1C:  MOVLW  95
01B1E:  MOVWF  xD4
01B20:  MOVLB  0
01B22:  RCALL  15DC
01B24:  MOVF   01,W
01B26:  ANDLW  01
01B28:  SUBLW  01
01B2A:  BTFSS  FD8.2
01B2C:  BRA    1C4A
....................              {
....................                if(FaultAgo[i]==1)
01B2E:  MOVFF  7CF,7D3
01B32:  MOVLW  07
01B34:  MOVLB  7
01B36:  MOVWF  xD5
01B38:  MOVLW  93
01B3A:  MOVWF  xD4
01B3C:  MOVLB  0
01B3E:  RCALL  15DC
01B40:  MOVF   01,W
01B42:  ANDLW  01
01B44:  SUBLW  01
01B46:  BTFSS  FD8.2
01B48:  BRA    1C2E
....................                {
....................                    ReleaseTime[i]++;
01B4A:  BCF    FD8.0
01B4C:  MOVLB  7
01B4E:  RLCF   xCF,W
01B50:  CLRF   03
01B52:  ADDLW  97
01B54:  MOVWF  FE9
01B56:  MOVLW  07
01B58:  ADDWFC 03,W
01B5A:  MOVWF  FEA
01B5C:  MOVLW  01
01B5E:  ADDWF  FEE,F
01B60:  BNC   1B64
01B62:  INCF   FEF,F
....................                    if(ReleaseTime[i]>=((FaultDelayTime[i]*75)+15)) //time per loop are 368 microSec. (1.89*10=200ms)
01B64:  BCF    FD8.0
01B66:  RLCF   xCF,W
01B68:  CLRF   03
01B6A:  ADDLW  97
01B6C:  MOVWF  FE9
01B6E:  MOVLW  07
01B70:  ADDWFC 03,W
01B72:  MOVWF  FEA
01B74:  MOVFF  FEC,7D1
01B78:  MOVF   FED,F
01B7A:  MOVFF  FEF,7D0
01B7E:  BCF    FD8.0
01B80:  RLCF   xCF,W
01B82:  CLRF   03
01B84:  ADDLW  AD
01B86:  MOVWF  FE9
01B88:  MOVLW  07
01B8A:  ADDWFC 03,W
01B8C:  MOVWF  FEA
01B8E:  MOVFF  FEC,7D5
01B92:  MOVF   FED,F
01B94:  MOVFF  FEF,7D4
01B98:  CLRF   xD7
01B9A:  MOVLW  4B
01B9C:  MOVWF  xD6
01B9E:  MOVLB  0
01BA0:  RCALL  1612
01BA2:  MOVFF  02,7D3
01BA6:  MOVFF  01,7D2
01BAA:  MOVLW  0F
01BAC:  MOVLB  7
01BAE:  ADDWF  01,W
01BB0:  MOVWF  01
01BB2:  MOVLW  00
01BB4:  ADDWFC 02,W
01BB6:  MOVWF  03
01BB8:  MOVF   03,W
01BBA:  SUBWF  xD1,W
01BBC:  BNC   1C2A
01BBE:  BNZ   1BC6
01BC0:  MOVF   01,W
01BC2:  SUBWF  xD0,W
01BC4:  BNC   1C2A
....................                    {   
....................                      ReleaseTime[i] = 0;
01BC6:  BCF    FD8.0
01BC8:  RLCF   xCF,W
01BCA:  CLRF   03
01BCC:  ADDLW  97
01BCE:  MOVWF  FE9
01BD0:  MOVLW  07
01BD2:  ADDWFC 03,W
01BD4:  MOVWF  FEA
01BD6:  CLRF   FEC
01BD8:  MOVF   FED,F
01BDA:  CLRF   FEF
....................                      switch(i)
01BDC:  MOVLW  01
01BDE:  SUBWF  xCF,W
01BE0:  ADDLW  F6
01BE2:  BC    1C2A
01BE4:  ADDLW  0A
01BE6:  MOVLB  0
01BE8:  GOTO   1E62
....................                      {
....................                         case 1:
....................                            Inputt.B1 = 1; 
01BEC:  MOVLB  7
01BEE:  BSF    x75.0
....................                         break;
01BF0:  BRA    1C2A
....................                         case 2:
....................                            Inputt.B2 = 1; 
01BF2:  MOVLB  7
01BF4:  BSF    x75.1
....................                         break;
01BF6:  BRA    1C2A
....................                         case 3:
....................                            Inputt.B3 = 1; 
01BF8:  MOVLB  7
01BFA:  BSF    x75.2
....................                         break;
01BFC:  BRA    1C2A
....................                         case 4:
....................                            Inputt.B4 = 1; 
01BFE:  MOVLB  7
01C00:  BSF    x75.3
....................                         break;
01C02:  BRA    1C2A
....................                         case 5:
....................                            Inputt.B5 = 1; 
01C04:  MOVLB  7
01C06:  BSF    x75.4
....................                         break;
01C08:  BRA    1C2A
....................                         case 6:
....................                            Inputt.B6 = 1; 
01C0A:  MOVLB  7
01C0C:  BSF    x75.5
....................                         break;
01C0E:  BRA    1C2A
....................                         case 7:
....................                            Inputt.B7 = 1; 
01C10:  MOVLB  7
01C12:  BSF    x75.6
....................                          break;
01C14:  BRA    1C2A
....................                          case 8:
....................                            Inputt.B8 = 1; 
01C16:  MOVLB  7
01C18:  BSF    x75.7
....................                         break;
01C1A:  BRA    1C2A
....................                         case 9:
....................                            Inputt.B9 = 1; 
01C1C:  MOVLB  7
01C1E:  BSF    x76.0
....................                         break;
01C20:  BRA    1C2A
....................                         case 10:
....................                            Inputt.B10 = 1; 
01C22:  MOVLB  7
01C24:  BSF    x76.1
....................                         break;
01C26:  BRA    1C2A
01C28:  MOVLB  7
....................                                          
....................                      }                 
....................                   }
....................                }
01C2A:  BRA    1C46
01C2C:  MOVLB  0
....................                else
....................                {
....................                   ReleaseTime[i] = 0;
01C2E:  BCF    FD8.0
01C30:  MOVLB  7
01C32:  RLCF   xCF,W
01C34:  CLRF   03
01C36:  ADDLW  97
01C38:  MOVWF  FE9
01C3A:  MOVLW  07
01C3C:  ADDWFC 03,W
01C3E:  MOVWF  FEA
01C40:  CLRF   FEC
01C42:  MOVF   FED,F
01C44:  CLRF   FEF
....................                }
....................              }
01C46:  BRA    1D60
01C48:  MOVLB  0
....................              else //if(FaultNow[i]==0
....................              {
....................                if(FaultAgo[i]==0)
01C4A:  MOVFF  7CF,7D3
01C4E:  MOVLW  07
01C50:  MOVLB  7
01C52:  MOVWF  xD5
01C54:  MOVLW  93
01C56:  MOVWF  xD4
01C58:  MOVLB  0
01C5A:  RCALL  15DC
01C5C:  MOVF   01,W
01C5E:  ANDLW  01
01C60:  BTFSS  FD8.2
01C62:  BRA    1D48
....................                {
....................                    ReleaseTime[i]++;
01C64:  BCF    FD8.0
01C66:  MOVLB  7
01C68:  RLCF   xCF,W
01C6A:  CLRF   03
01C6C:  ADDLW  97
01C6E:  MOVWF  FE9
01C70:  MOVLW  07
01C72:  ADDWFC 03,W
01C74:  MOVWF  FEA
01C76:  MOVLW  01
01C78:  ADDWF  FEE,F
01C7A:  BNC   1C7E
01C7C:  INCF   FEF,F
....................                   
....................                    if(ReleaseTime[i]>=((FaultDelayTime[i]*75)+15)) //time per loop are 368 microSec. (1.89*10=200ms)
01C7E:  BCF    FD8.0
01C80:  RLCF   xCF,W
01C82:  CLRF   03
01C84:  ADDLW  97
01C86:  MOVWF  FE9
01C88:  MOVLW  07
01C8A:  ADDWFC 03,W
01C8C:  MOVWF  FEA
01C8E:  MOVFF  FEC,7D1
01C92:  MOVF   FED,F
01C94:  MOVFF  FEF,7D0
01C98:  BCF    FD8.0
01C9A:  RLCF   xCF,W
01C9C:  CLRF   03
01C9E:  ADDLW  AD
01CA0:  MOVWF  FE9
01CA2:  MOVLW  07
01CA4:  ADDWFC 03,W
01CA6:  MOVWF  FEA
01CA8:  MOVFF  FEC,7D5
01CAC:  MOVF   FED,F
01CAE:  MOVFF  FEF,7D4
01CB2:  CLRF   xD7
01CB4:  MOVLW  4B
01CB6:  MOVWF  xD6
01CB8:  MOVLB  0
01CBA:  RCALL  1612
01CBC:  MOVFF  02,7D3
01CC0:  MOVFF  01,7D2
01CC4:  MOVLW  0F
01CC6:  MOVLB  7
01CC8:  ADDWF  01,W
01CCA:  MOVWF  01
01CCC:  MOVLW  00
01CCE:  ADDWFC 02,W
01CD0:  MOVWF  03
01CD2:  MOVF   03,W
01CD4:  SUBWF  xD1,W
01CD6:  BNC   1D44
01CD8:  BNZ   1CE0
01CDA:  MOVF   01,W
01CDC:  SUBWF  xD0,W
01CDE:  BNC   1D44
....................                    {   
....................                      ReleaseTime[i] = 0;
01CE0:  BCF    FD8.0
01CE2:  RLCF   xCF,W
01CE4:  CLRF   03
01CE6:  ADDLW  97
01CE8:  MOVWF  FE9
01CEA:  MOVLW  07
01CEC:  ADDWFC 03,W
01CEE:  MOVWF  FEA
01CF0:  CLRF   FEC
01CF2:  MOVF   FED,F
01CF4:  CLRF   FEF
....................                      switch(i)
01CF6:  MOVLW  01
01CF8:  SUBWF  xCF,W
01CFA:  ADDLW  F6
01CFC:  BC    1D44
01CFE:  ADDLW  0A
01D00:  MOVLB  0
01D02:  GOTO   1E90
....................                      {
....................                         case 1:
....................                            Inputt.B1 = 0; 
01D06:  MOVLB  7
01D08:  BCF    x75.0
....................                         break;
01D0A:  BRA    1D44
....................                         case 2:
....................                            Inputt.B2 = 0; 
01D0C:  MOVLB  7
01D0E:  BCF    x75.1
....................                         break;
01D10:  BRA    1D44
....................                         case 3:
....................                            Inputt.B3 = 0; 
01D12:  MOVLB  7
01D14:  BCF    x75.2
....................                         break;
01D16:  BRA    1D44
....................                         case 4:
....................                            Inputt.B4 = 0; 
01D18:  MOVLB  7
01D1A:  BCF    x75.3
....................                         break;
01D1C:  BRA    1D44
....................                         case 5:
....................                            Inputt.B5 = 0; 
01D1E:  MOVLB  7
01D20:  BCF    x75.4
....................                         break;
01D22:  BRA    1D44
....................                         case 6:
....................                            Inputt.B6 = 0; 
01D24:  MOVLB  7
01D26:  BCF    x75.5
....................                         break;
01D28:  BRA    1D44
....................                         case 7:
....................                            Inputt.B7 = 0; 
01D2A:  MOVLB  7
01D2C:  BCF    x75.6
....................                          break;
01D2E:  BRA    1D44
....................                          case 8:
....................                            Inputt.B8 = 0; 
01D30:  MOVLB  7
01D32:  BCF    x75.7
....................                         break;
01D34:  BRA    1D44
....................                         case 9:
....................                            Inputt.B9 = 0; 
01D36:  MOVLB  7
01D38:  BCF    x76.0
....................                         break;
01D3A:  BRA    1D44
....................                         case 10:
....................                            Inputt.B10 = 0; 
01D3C:  MOVLB  7
01D3E:  BCF    x76.1
....................                         break;
01D40:  BRA    1D44
01D42:  MOVLB  7
....................          
....................                      }                 
....................                    }
....................                }
01D44:  BRA    1D60
01D46:  MOVLB  0
....................                else
....................                {
....................                   ReleaseTime[i] = 0;
01D48:  BCF    FD8.0
01D4A:  MOVLB  7
01D4C:  RLCF   xCF,W
01D4E:  CLRF   03
01D50:  ADDLW  97
01D52:  MOVWF  FE9
01D54:  MOVLW  07
01D56:  ADDWFC 03,W
01D58:  MOVWF  FEA
01D5A:  CLRF   FEC
01D5C:  MOVF   FED,F
01D5E:  CLRF   FEF
01D60:  MOVLB  0
....................                }
.................... 
....................              }
....................           }
01D62:  MOVLB  7
01D64:  INCF   xCF,F
01D66:  BRA    1888
....................       }
....................         
....................       StoreReleaseFault();
01D68:  MOVLB  0
01D6A:  BRA    1676
....................    
....................       Input1_8 = 0x00;
01D6C:  CLRF   4C
....................       Input1_8 = Input1_8 | ~Inputt.B8;
01D6E:  MOVLW  00
01D70:  MOVLB  7
01D72:  BTFSS  x75.7
01D74:  MOVLW  01
01D76:  IORWF  4C,F
....................       Input1_8 = (Input1_8 << 1) | ~Inputt.B7;
01D78:  BCF    FD8.0
01D7A:  RLCF   4C,W
01D7C:  MOVWF  xD0
01D7E:  MOVLW  00
01D80:  BTFSS  x75.6
01D82:  MOVLW  01
01D84:  IORWF  xD0,W
01D86:  MOVWF  4C
....................       Input1_8 = (Input1_8 << 1) | ~Inputt.B6;
01D88:  BCF    FD8.0
01D8A:  RLCF   4C,W
01D8C:  MOVWF  xD0
01D8E:  MOVLW  00
01D90:  BTFSS  x75.5
01D92:  MOVLW  01
01D94:  IORWF  xD0,W
01D96:  MOVWF  4C
....................       Input1_8 = (Input1_8 << 1) | ~Inputt.B5;
01D98:  BCF    FD8.0
01D9A:  RLCF   4C,W
01D9C:  MOVWF  xD0
01D9E:  MOVLW  00
01DA0:  BTFSS  x75.4
01DA2:  MOVLW  01
01DA4:  IORWF  xD0,W
01DA6:  MOVWF  4C
....................       Input1_8 = (Input1_8 << 1) | ~Inputt.B4;
01DA8:  BCF    FD8.0
01DAA:  RLCF   4C,W
01DAC:  MOVWF  xD0
01DAE:  MOVLW  00
01DB0:  BTFSS  x75.3
01DB2:  MOVLW  01
01DB4:  IORWF  xD0,W
01DB6:  MOVWF  4C
....................       Input1_8 = (Input1_8 << 1) | ~Inputt.B3;
01DB8:  BCF    FD8.0
01DBA:  RLCF   4C,W
01DBC:  MOVWF  xD0
01DBE:  MOVLW  00
01DC0:  BTFSS  x75.2
01DC2:  MOVLW  01
01DC4:  IORWF  xD0,W
01DC6:  MOVWF  4C
....................       Input1_8 = (Input1_8 << 1) | ~Inputt.B2;
01DC8:  BCF    FD8.0
01DCA:  RLCF   4C,W
01DCC:  MOVWF  xD0
01DCE:  MOVLW  00
01DD0:  BTFSS  x75.1
01DD2:  MOVLW  01
01DD4:  IORWF  xD0,W
01DD6:  MOVWF  4C
....................       Input1_8 = (Input1_8 << 1) | ~Inputt.B1;
01DD8:  BCF    FD8.0
01DDA:  RLCF   4C,W
01DDC:  MOVWF  xD0
01DDE:  MOVLW  00
01DE0:  BTFSS  x75.0
01DE2:  MOVLW  01
01DE4:  IORWF  xD0,W
01DE6:  MOVWF  4C
....................     
....................    
.................... 
....................       Input9_10 = 0x00;
01DE8:  CLRF   4D
....................       Input9_10 = Input9_10 | ~Inputt.B10;
01DEA:  MOVLW  00
01DEC:  BTFSS  x76.1
01DEE:  MOVLW  01
01DF0:  IORWF  4D,F
....................       Input9_10 = (Input9_10 << 1) | ~Inputt.B9;
01DF2:  BCF    FD8.0
01DF4:  RLCF   4D,W
01DF6:  MOVWF  xD0
01DF8:  MOVLW  00
01DFA:  BTFSS  x76.0
01DFC:  MOVLW  01
01DFE:  IORWF  xD0,W
01E00:  MOVWF  4D
01E02:  MOVLB  0
01E04:  RETURN 0
....................       
....................   
.................... }
.................... /*----------------------------------------------------------------------------*/
.................... 
.................... 
.................... void Read_Config(void)
.................... {
....................    
.................... 
....................    EEpDat = read_eeprom(0x01);   // Input type 1-8
*
007A8:  MOVFF  FF2,7D9
007AC:  BCF    FF2.7
007AE:  CLRF   FAA
007B0:  MOVLW  01
007B2:  MOVWF  FA9
007B4:  BCF    FA6.6
007B6:  BCF    FA6.7
007B8:  BSF    FA6.0
007BA:  MOVF   FA8,W
007BC:  MOVLB  7
007BE:  BTFSC  xD9.7
007C0:  BSF    FF2.7
007C2:  MOVWF  3C
....................    InputType1_8 = EEpDat;
007C4:  MOVFF  3C,3D
.................... 
....................    InputType.B1 = EEpDat;
007C8:  BCF    x79.0
007CA:  BTFSC  3C.0
007CC:  BSF    x79.0
....................    InputType.B2 = EEpDat >> 1;
007CE:  BCF    FD8.0
007D0:  RRCF   3C,W
007D2:  BCF    x79.1
007D4:  BTFSC  FE8.0
007D6:  BSF    x79.1
....................    InputType.B3 = EEpDat >> 2;
007D8:  RRCF   3C,W
007DA:  MOVWF  00
007DC:  RRCF   00,F
007DE:  MOVLW  3F
007E0:  ANDWF  00,F
007E2:  BCF    x79.2
007E4:  BTFSC  00.0
007E6:  BSF    x79.2
....................    InputType.B4 = EEpDat >> 3;
007E8:  RRCF   3C,W
007EA:  MOVWF  00
007EC:  RRCF   00,F
007EE:  RRCF   00,F
007F0:  MOVLW  1F
007F2:  ANDWF  00,F
007F4:  BCF    x79.3
007F6:  BTFSC  00.0
007F8:  BSF    x79.3
....................    InputType.B5 = EEpDat >> 4;
007FA:  SWAPF  3C,W
007FC:  MOVWF  00
007FE:  MOVLW  0F
00800:  ANDWF  00,F
00802:  BCF    x79.4
00804:  BTFSC  00.0
00806:  BSF    x79.4
....................    InputType.B6 = EEpDat >> 5;
00808:  SWAPF  3C,W
0080A:  MOVWF  00
0080C:  RRCF   00,F
0080E:  MOVLW  07
00810:  ANDWF  00,F
00812:  BCF    x79.5
00814:  BTFSC  00.0
00816:  BSF    x79.5
....................    InputType.B7 = EEpDat >> 6;
00818:  SWAPF  3C,W
0081A:  MOVWF  00
0081C:  RRCF   00,F
0081E:  RRCF   00,F
00820:  MOVLW  03
00822:  ANDWF  00,F
00824:  BCF    x79.6
00826:  BTFSC  00.0
00828:  BSF    x79.6
....................    InputType.B8 = EEpDat >> 7;
0082A:  CLRF   00
0082C:  BTFSC  3C.7
0082E:  BSF    00.0
00830:  BCF    x79.7
00832:  BTFSC  00.0
00834:  BSF    x79.7
.................... 
....................    EEpDat = read_eeprom(0x02);   // Input type 9-16
00836:  MOVFF  FF2,7D9
0083A:  BCF    FF2.7
0083C:  CLRF   FAA
0083E:  MOVLW  02
00840:  MOVWF  FA9
00842:  BCF    FA6.6
00844:  BCF    FA6.7
00846:  BSF    FA6.0
00848:  MOVF   FA8,W
0084A:  BTFSC  xD9.7
0084C:  BSF    FF2.7
0084E:  MOVWF  3C
....................    InputType9_16 = EEpDat;
00850:  MOVFF  3C,3E
.................... 
....................    InputType.B9 = EEpDat;
00854:  BCF    x7A.0
00856:  BTFSC  3C.0
00858:  BSF    x7A.0
....................    InputType.B10 = EEpDat >> 1;
0085A:  BCF    FD8.0
0085C:  RRCF   3C,W
0085E:  BCF    x7A.1
00860:  BTFSC  FE8.0
00862:  BSF    x7A.1
....................    
....................    FaultNCNO[1] = InputType.B1;
00864:  BCF    xC3.1
00866:  BTFSC  x79.0
00868:  BSF    xC3.1
....................    FaultNCNO[2] = InputType.B2;
0086A:  BCF    xC3.2
0086C:  BTFSC  x79.1
0086E:  BSF    xC3.2
....................    FaultNCNO[3] = InputType.B3;
00870:  BCF    xC3.3
00872:  BTFSC  x79.2
00874:  BSF    xC3.3
....................    FaultNCNO[4] = InputType.B4;
00876:  BCF    xC3.4
00878:  BTFSC  x79.3
0087A:  BSF    xC3.4
....................    FaultNCNO[5] = InputType.B5;
0087C:  BCF    xC3.5
0087E:  BTFSC  x79.4
00880:  BSF    xC3.5
....................    FaultNCNO[6] = InputType.B6;
00882:  BCF    xC3.6
00884:  BTFSC  x79.5
00886:  BSF    xC3.6
....................    FaultNCNO[7] = InputType.B7;
00888:  BCF    xC3.7
0088A:  BTFSC  x79.6
0088C:  BSF    xC3.7
....................    FaultNCNO[8] = InputType.B8;
0088E:  BCF    xC4.0
00890:  BTFSC  x79.7
00892:  BSF    xC4.0
....................    FaultNCNO[9] = InputType.B9;
00894:  BCF    xC4.1
00896:  BTFSC  x7A.0
00898:  BSF    xC4.1
....................    FaultNCNO[10] = InputType.B10;
0089A:  BCF    xC4.2
0089C:  BTFSC  x7A.1
0089E:  BSF    xC4.2
.................... 
....................    ////////////////////////////////////////
.................... 
....................    EEpDat = read_eeprom(0x04);   // Fault type 1-8
008A0:  MOVFF  FF2,7D9
008A4:  BCF    FF2.7
008A6:  CLRF   FAA
008A8:  MOVLW  04
008AA:  MOVWF  FA9
008AC:  BCF    FA6.6
008AE:  BCF    FA6.7
008B0:  BSF    FA6.0
008B2:  MOVF   FA8,W
008B4:  BTFSC  xD9.7
008B6:  BSF    FF2.7
008B8:  MOVWF  3C
....................    FaultType1_8 = EEpDat;
008BA:  MOVFF  3C,40
.................... 
....................    FaultType.B1 = EEpDat;
008BE:  BCF    x7B.0
008C0:  BTFSC  3C.0
008C2:  BSF    x7B.0
....................    FaultType.B2 = EEpDat >> 1;
008C4:  BCF    FD8.0
008C6:  RRCF   3C,W
008C8:  BCF    x7B.1
008CA:  BTFSC  FE8.0
008CC:  BSF    x7B.1
....................    FaultType.B3 = EEpDat >> 2;
008CE:  RRCF   3C,W
008D0:  MOVWF  00
008D2:  RRCF   00,F
008D4:  MOVLW  3F
008D6:  ANDWF  00,F
008D8:  BCF    x7B.2
008DA:  BTFSC  00.0
008DC:  BSF    x7B.2
....................    FaultType.B4 = EEpDat >> 3;
008DE:  RRCF   3C,W
008E0:  MOVWF  00
008E2:  RRCF   00,F
008E4:  RRCF   00,F
008E6:  MOVLW  1F
008E8:  ANDWF  00,F
008EA:  BCF    x7B.3
008EC:  BTFSC  00.0
008EE:  BSF    x7B.3
....................    FaultType.B5 = EEpDat >> 4;
008F0:  SWAPF  3C,W
008F2:  MOVWF  00
008F4:  MOVLW  0F
008F6:  ANDWF  00,F
008F8:  BCF    x7B.4
008FA:  BTFSC  00.0
008FC:  BSF    x7B.4
....................    FaultType.B6 = EEpDat >> 5;
008FE:  SWAPF  3C,W
00900:  MOVWF  00
00902:  RRCF   00,F
00904:  MOVLW  07
00906:  ANDWF  00,F
00908:  BCF    x7B.5
0090A:  BTFSC  00.0
0090C:  BSF    x7B.5
....................    FaultType.B7 = EEpDat >> 6;
0090E:  SWAPF  3C,W
00910:  MOVWF  00
00912:  RRCF   00,F
00914:  RRCF   00,F
00916:  MOVLW  03
00918:  ANDWF  00,F
0091A:  BCF    x7B.6
0091C:  BTFSC  00.0
0091E:  BSF    x7B.6
....................    FaultType.B8 = EEpDat >> 7;
00920:  CLRF   00
00922:  BTFSC  3C.7
00924:  BSF    00.0
00926:  BCF    x7B.7
00928:  BTFSC  00.0
0092A:  BSF    x7B.7
.................... 
....................    EEpDat = read_eeprom(0x05);   // Fault type 9-16
0092C:  MOVFF  FF2,7D9
00930:  BCF    FF2.7
00932:  CLRF   FAA
00934:  MOVLW  05
00936:  MOVWF  FA9
00938:  BCF    FA6.6
0093A:  BCF    FA6.7
0093C:  BSF    FA6.0
0093E:  MOVF   FA8,W
00940:  BTFSC  xD9.7
00942:  BSF    FF2.7
00944:  MOVWF  3C
....................    FaultType9_16 = EEpDat;
00946:  MOVFF  3C,41
.................... 
....................    FaultType.B9 = EEpDat;
0094A:  BCF    x7C.0
0094C:  BTFSC  3C.0
0094E:  BSF    x7C.0
....................    FaultType.B10 = EEpDat >> 1;
00950:  BCF    FD8.0
00952:  RRCF   3C,W
00954:  BCF    x7C.1
00956:  BTFSC  FE8.0
00958:  BSF    x7C.1
.................... 
....................    ////////////////////////////////////////////////
.................... 
....................    EEpDat = read_eeprom(0x07);   // Output type 1-8
0095A:  MOVFF  FF2,7D9
0095E:  BCF    FF2.7
00960:  CLRF   FAA
00962:  MOVLW  07
00964:  MOVWF  FA9
00966:  BCF    FA6.6
00968:  BCF    FA6.7
0096A:  BSF    FA6.0
0096C:  MOVF   FA8,W
0096E:  BTFSC  xD9.7
00970:  BSF    FF2.7
00972:  MOVWF  3C
....................    OutputType1_8 = EEpDat;
00974:  MOVFF  3C,43
.................... 
....................    OutputType.B1 = EEpDat;
00978:  BCF    x7D.0
0097A:  BTFSC  3C.0
0097C:  BSF    x7D.0
....................    OutputType.B2 = EEpDat >> 1;
0097E:  BCF    FD8.0
00980:  RRCF   3C,W
00982:  BCF    x7D.1
00984:  BTFSC  FE8.0
00986:  BSF    x7D.1
....................    OutputType.B3 = EEpDat >> 2;
00988:  RRCF   3C,W
0098A:  MOVWF  00
0098C:  RRCF   00,F
0098E:  MOVLW  3F
00990:  ANDWF  00,F
00992:  BCF    x7D.2
00994:  BTFSC  00.0
00996:  BSF    x7D.2
....................    OutputType.B4 = EEpDat >> 3;
00998:  RRCF   3C,W
0099A:  MOVWF  00
0099C:  RRCF   00,F
0099E:  RRCF   00,F
009A0:  MOVLW  1F
009A2:  ANDWF  00,F
009A4:  BCF    x7D.3
009A6:  BTFSC  00.0
009A8:  BSF    x7D.3
....................    OutputType.B5 = EEpDat >> 4;
009AA:  SWAPF  3C,W
009AC:  MOVWF  00
009AE:  MOVLW  0F
009B0:  ANDWF  00,F
009B2:  BCF    x7D.4
009B4:  BTFSC  00.0
009B6:  BSF    x7D.4
....................    OutputType.B6 = EEpDat >> 5;
009B8:  SWAPF  3C,W
009BA:  MOVWF  00
009BC:  RRCF   00,F
009BE:  MOVLW  07
009C0:  ANDWF  00,F
009C2:  BCF    x7D.5
009C4:  BTFSC  00.0
009C6:  BSF    x7D.5
....................    OutputType.B7 = EEpDat >> 6;
009C8:  SWAPF  3C,W
009CA:  MOVWF  00
009CC:  RRCF   00,F
009CE:  RRCF   00,F
009D0:  MOVLW  03
009D2:  ANDWF  00,F
009D4:  BCF    x7D.6
009D6:  BTFSC  00.0
009D8:  BSF    x7D.6
....................    OutputType.B8 = EEpDat >> 7;
009DA:  CLRF   00
009DC:  BTFSC  3C.7
009DE:  BSF    00.0
009E0:  BCF    x7D.7
009E2:  BTFSC  00.0
009E4:  BSF    x7D.7
.................... 
....................    EEpDat = read_eeprom(0x08);   // Output type 9-16
009E6:  MOVFF  FF2,7D9
009EA:  BCF    FF2.7
009EC:  CLRF   FAA
009EE:  MOVLW  08
009F0:  MOVWF  FA9
009F2:  BCF    FA6.6
009F4:  BCF    FA6.7
009F6:  BSF    FA6.0
009F8:  MOVF   FA8,W
009FA:  BTFSC  xD9.7
009FC:  BSF    FF2.7
009FE:  MOVWF  3C
....................    OutputType9_16 = EEpDat;
00A00:  MOVFF  3C,44
.................... 
....................    OutputType.B9 = EEpDat;
00A04:  BCF    x7E.0
00A06:  BTFSC  3C.0
00A08:  BSF    x7E.0
....................    OutputType.B10 = EEpDat >> 1;
00A0A:  BCF    FD8.0
00A0C:  RRCF   3C,W
00A0E:  BCF    x7E.1
00A10:  BTFSC  FE8.0
00A12:  BSF    x7E.1
.................... 
....................    ////////////////////////////////////////
.................... 
....................    EEpDat = read_eeprom(0x0A);   // Output Both 1-8
00A14:  MOVFF  FF2,7D9
00A18:  BCF    FF2.7
00A1A:  CLRF   FAA
00A1C:  MOVLW  0A
00A1E:  MOVWF  FA9
00A20:  BCF    FA6.6
00A22:  BCF    FA6.7
00A24:  BSF    FA6.0
00A26:  MOVF   FA8,W
00A28:  BTFSC  xD9.7
00A2A:  BSF    FF2.7
00A2C:  MOVWF  3C
....................    OutputBoth1_8 = EEpDat;
00A2E:  MOVFF  3C,46
.................... 
....................    OutputBoth.B1 = EEpDat;
00A32:  BCF    x7F.0
00A34:  BTFSC  3C.0
00A36:  BSF    x7F.0
....................    OutputBoth.B2 = EEpDat >> 1;
00A38:  BCF    FD8.0
00A3A:  RRCF   3C,W
00A3C:  BCF    x7F.1
00A3E:  BTFSC  FE8.0
00A40:  BSF    x7F.1
....................    OutputBoth.B3 = EEpDat >> 2;
00A42:  RRCF   3C,W
00A44:  MOVWF  00
00A46:  RRCF   00,F
00A48:  MOVLW  3F
00A4A:  ANDWF  00,F
00A4C:  BCF    x7F.2
00A4E:  BTFSC  00.0
00A50:  BSF    x7F.2
....................    OutputBoth.B4 = EEpDat >> 3;
00A52:  RRCF   3C,W
00A54:  MOVWF  00
00A56:  RRCF   00,F
00A58:  RRCF   00,F
00A5A:  MOVLW  1F
00A5C:  ANDWF  00,F
00A5E:  BCF    x7F.3
00A60:  BTFSC  00.0
00A62:  BSF    x7F.3
....................    OutputBoth.B5 = EEpDat >> 4;
00A64:  SWAPF  3C,W
00A66:  MOVWF  00
00A68:  MOVLW  0F
00A6A:  ANDWF  00,F
00A6C:  BCF    x7F.4
00A6E:  BTFSC  00.0
00A70:  BSF    x7F.4
....................    OutputBoth.B6 = EEpDat >> 5;
00A72:  SWAPF  3C,W
00A74:  MOVWF  00
00A76:  RRCF   00,F
00A78:  MOVLW  07
00A7A:  ANDWF  00,F
00A7C:  BCF    x7F.5
00A7E:  BTFSC  00.0
00A80:  BSF    x7F.5
....................    OutputBoth.B7 = EEpDat >> 6;
00A82:  SWAPF  3C,W
00A84:  MOVWF  00
00A86:  RRCF   00,F
00A88:  RRCF   00,F
00A8A:  MOVLW  03
00A8C:  ANDWF  00,F
00A8E:  BCF    x7F.6
00A90:  BTFSC  00.0
00A92:  BSF    x7F.6
....................    OutputBoth.B8 = EEpDat >> 7;
00A94:  CLRF   00
00A96:  BTFSC  3C.7
00A98:  BSF    00.0
00A9A:  BCF    x7F.7
00A9C:  BTFSC  00.0
00A9E:  BSF    x7F.7
.................... 
....................    EEpDat = read_eeprom(0x0B);   // Output Both 9-16
00AA0:  MOVFF  FF2,7D9
00AA4:  BCF    FF2.7
00AA6:  CLRF   FAA
00AA8:  MOVLW  0B
00AAA:  MOVWF  FA9
00AAC:  BCF    FA6.6
00AAE:  BCF    FA6.7
00AB0:  BSF    FA6.0
00AB2:  MOVF   FA8,W
00AB4:  BTFSC  xD9.7
00AB6:  BSF    FF2.7
00AB8:  MOVWF  3C
....................    OutputBoth9_16 = EEpDat;
00ABA:  MOVFF  3C,47
.................... 
....................    OutputBoth.B9 = EEpDat;
00ABE:  BCF    x80.0
00AC0:  BTFSC  3C.0
00AC2:  BSF    x80.0
....................    OutputBoth.B10 = EEpDat >> 1;
00AC4:  BCF    FD8.0
00AC6:  RRCF   3C,W
00AC8:  BCF    x80.1
00ACA:  BTFSC  FE8.0
00ACC:  BSF    x80.1
.................... 
....................    /////////////////////////////////////////////////
.................... 
....................    EEpDat = read_eeprom(0x0D);   // AlarmIndicator 1-8
00ACE:  MOVFF  FF2,7D9
00AD2:  BCF    FF2.7
00AD4:  CLRF   FAA
00AD6:  MOVLW  0D
00AD8:  MOVWF  FA9
00ADA:  BCF    FA6.6
00ADC:  BCF    FA6.7
00ADE:  BSF    FA6.0
00AE0:  MOVF   FA8,W
00AE2:  BTFSC  xD9.7
00AE4:  BSF    FF2.7
00AE6:  MOVWF  3C
....................    Alarm_Indicator1_8 = EEpDat;
00AE8:  MOVFF  3C,49
.................... 
....................    AlarmIndicator.B1 = EEpDat;
00AEC:  BCF    x81.0
00AEE:  BTFSC  3C.0
00AF0:  BSF    x81.0
....................    AlarmIndicator.B2 = EEpDat >> 1;
00AF2:  BCF    FD8.0
00AF4:  RRCF   3C,W
00AF6:  BCF    x81.1
00AF8:  BTFSC  FE8.0
00AFA:  BSF    x81.1
....................    AlarmIndicator.B3 = EEpDat >> 2;
00AFC:  RRCF   3C,W
00AFE:  MOVWF  00
00B00:  RRCF   00,F
00B02:  MOVLW  3F
00B04:  ANDWF  00,F
00B06:  BCF    x81.2
00B08:  BTFSC  00.0
00B0A:  BSF    x81.2
....................    AlarmIndicator.B4 = EEpDat >> 3;
00B0C:  RRCF   3C,W
00B0E:  MOVWF  00
00B10:  RRCF   00,F
00B12:  RRCF   00,F
00B14:  MOVLW  1F
00B16:  ANDWF  00,F
00B18:  BCF    x81.3
00B1A:  BTFSC  00.0
00B1C:  BSF    x81.3
....................    AlarmIndicator.B5 = EEpDat >> 4;
00B1E:  SWAPF  3C,W
00B20:  MOVWF  00
00B22:  MOVLW  0F
00B24:  ANDWF  00,F
00B26:  BCF    x81.4
00B28:  BTFSC  00.0
00B2A:  BSF    x81.4
....................    AlarmIndicator.B6 = EEpDat >> 5;
00B2C:  SWAPF  3C,W
00B2E:  MOVWF  00
00B30:  RRCF   00,F
00B32:  MOVLW  07
00B34:  ANDWF  00,F
00B36:  BCF    x81.5
00B38:  BTFSC  00.0
00B3A:  BSF    x81.5
....................    AlarmIndicator.B7 = EEpDat >> 6;
00B3C:  SWAPF  3C,W
00B3E:  MOVWF  00
00B40:  RRCF   00,F
00B42:  RRCF   00,F
00B44:  MOVLW  03
00B46:  ANDWF  00,F
00B48:  BCF    x81.6
00B4A:  BTFSC  00.0
00B4C:  BSF    x81.6
....................    AlarmIndicator.B8 = EEpDat >> 7;
00B4E:  CLRF   00
00B50:  BTFSC  3C.7
00B52:  BSF    00.0
00B54:  BCF    x81.7
00B56:  BTFSC  00.0
00B58:  BSF    x81.7
.................... 
....................    EEpDat = read_eeprom(0x0E);   // AlarmIndicator 9-16
00B5A:  MOVFF  FF2,7D9
00B5E:  BCF    FF2.7
00B60:  CLRF   FAA
00B62:  MOVLW  0E
00B64:  MOVWF  FA9
00B66:  BCF    FA6.6
00B68:  BCF    FA6.7
00B6A:  BSF    FA6.0
00B6C:  MOVF   FA8,W
00B6E:  BTFSC  xD9.7
00B70:  BSF    FF2.7
00B72:  MOVWF  3C
....................    Alarm_Indicator9_16 = EEpDat;
00B74:  MOVFF  3C,4A
.................... 
....................    AlarmIndicator.B9 = EEpDat;
00B78:  BCF    x82.0
00B7A:  BTFSC  3C.0
00B7C:  BSF    x82.0
....................    AlarmIndicator.B10 = EEpDat >> 1;
00B7E:  BCF    FD8.0
00B80:  RRCF   3C,W
00B82:  BCF    x82.1
00B84:  BTFSC  FE8.0
00B86:  BSF    x82.1
.................... 
....................    //////////////////////////////////////////////////
....................    EEpDat = read_eeprom(0x10);
00B88:  MOVFF  FF2,7D9
00B8C:  BCF    FF2.7
00B8E:  CLRF   FAA
00B90:  MOVLW  10
00B92:  MOVWF  FA9
00B94:  BCF    FA6.6
00B96:  BCF    FA6.7
00B98:  BSF    FA6.0
00B9A:  MOVF   FA8,W
00B9C:  BTFSC  xD9.7
00B9E:  BSF    FF2.7
00BA0:  MOVWF  3C
....................    //Red1_8 = EEpDat;
....................    RED_Colour.B1 = EEpDat;
00BA2:  BCF    x8D.0
00BA4:  BTFSC  3C.0
00BA6:  BSF    x8D.0
....................    RED_Colour.B2 = EEpDat >> 1;
00BA8:  BCF    FD8.0
00BAA:  RRCF   3C,W
00BAC:  BCF    x8D.1
00BAE:  BTFSC  FE8.0
00BB0:  BSF    x8D.1
....................    RED_Colour.B3 = EEpDat >> 2;
00BB2:  RRCF   3C,W
00BB4:  MOVWF  00
00BB6:  RRCF   00,F
00BB8:  MOVLW  3F
00BBA:  ANDWF  00,F
00BBC:  BCF    x8D.2
00BBE:  BTFSC  00.0
00BC0:  BSF    x8D.2
....................    RED_Colour.B4 = EEpDat >> 3;
00BC2:  RRCF   3C,W
00BC4:  MOVWF  00
00BC6:  RRCF   00,F
00BC8:  RRCF   00,F
00BCA:  MOVLW  1F
00BCC:  ANDWF  00,F
00BCE:  BCF    x8D.3
00BD0:  BTFSC  00.0
00BD2:  BSF    x8D.3
....................    RED_Colour.B5 = EEpDat >> 4;
00BD4:  SWAPF  3C,W
00BD6:  MOVWF  00
00BD8:  MOVLW  0F
00BDA:  ANDWF  00,F
00BDC:  BCF    x8D.4
00BDE:  BTFSC  00.0
00BE0:  BSF    x8D.4
....................    RED_Colour.B6 = EEpDat >> 5;
00BE2:  SWAPF  3C,W
00BE4:  MOVWF  00
00BE6:  RRCF   00,F
00BE8:  MOVLW  07
00BEA:  ANDWF  00,F
00BEC:  BCF    x8D.5
00BEE:  BTFSC  00.0
00BF0:  BSF    x8D.5
....................    RED_Colour.B7 = EEpDat >> 6;
00BF2:  SWAPF  3C,W
00BF4:  MOVWF  00
00BF6:  RRCF   00,F
00BF8:  RRCF   00,F
00BFA:  MOVLW  03
00BFC:  ANDWF  00,F
00BFE:  BCF    x8D.6
00C00:  BTFSC  00.0
00C02:  BSF    x8D.6
....................    RED_Colour.B8 = EEpDat >> 7;
00C04:  CLRF   00
00C06:  BTFSC  3C.7
00C08:  BSF    00.0
00C0A:  BCF    x8D.7
00C0C:  BTFSC  00.0
00C0E:  BSF    x8D.7
....................    
....................    EEpDat = read_eeprom(0x11);
00C10:  MOVFF  FF2,7D9
00C14:  BCF    FF2.7
00C16:  CLRF   FAA
00C18:  MOVLW  11
00C1A:  MOVWF  FA9
00C1C:  BCF    FA6.6
00C1E:  BCF    FA6.7
00C20:  BSF    FA6.0
00C22:  MOVF   FA8,W
00C24:  BTFSC  xD9.7
00C26:  BSF    FF2.7
00C28:  MOVWF  3C
....................    //Green9_10 = EEpDat;
....................    RED_Colour.B9 = EEpDat;
00C2A:  BCF    x8E.0
00C2C:  BTFSC  3C.0
00C2E:  BSF    x8E.0
....................    RED_Colour.B10 = EEpDat >> 1;
00C30:  BCF    FD8.0
00C32:  RRCF   3C,W
00C34:  BCF    x8E.1
00C36:  BTFSC  FE8.0
00C38:  BSF    x8E.1
....................    
....................    EEpDat = read_eeprom(0x14);
00C3A:  MOVFF  FF2,7D9
00C3E:  BCF    FF2.7
00C40:  CLRF   FAA
00C42:  MOVLW  14
00C44:  MOVWF  FA9
00C46:  BCF    FA6.6
00C48:  BCF    FA6.7
00C4A:  BSF    FA6.0
00C4C:  MOVF   FA8,W
00C4E:  BTFSC  xD9.7
00C50:  BSF    FF2.7
00C52:  MOVWF  3C
....................    //Green1_8 = EEpDat;
....................    GREEN_Colour.B1 = EEpDat;
00C54:  BCF    x8F.0
00C56:  BTFSC  3C.0
00C58:  BSF    x8F.0
....................    GREEN_Colour.B2 = EEpDat >> 1;
00C5A:  BCF    FD8.0
00C5C:  RRCF   3C,W
00C5E:  BCF    x8F.1
00C60:  BTFSC  FE8.0
00C62:  BSF    x8F.1
....................    GREEN_Colour.B3 = EEpDat >> 2;
00C64:  RRCF   3C,W
00C66:  MOVWF  00
00C68:  RRCF   00,F
00C6A:  MOVLW  3F
00C6C:  ANDWF  00,F
00C6E:  BCF    x8F.2
00C70:  BTFSC  00.0
00C72:  BSF    x8F.2
....................    GREEN_Colour.B4 = EEpDat >> 3;
00C74:  RRCF   3C,W
00C76:  MOVWF  00
00C78:  RRCF   00,F
00C7A:  RRCF   00,F
00C7C:  MOVLW  1F
00C7E:  ANDWF  00,F
00C80:  BCF    x8F.3
00C82:  BTFSC  00.0
00C84:  BSF    x8F.3
....................    GREEN_Colour.B5 = EEpDat >> 4;
00C86:  SWAPF  3C,W
00C88:  MOVWF  00
00C8A:  MOVLW  0F
00C8C:  ANDWF  00,F
00C8E:  BCF    x8F.4
00C90:  BTFSC  00.0
00C92:  BSF    x8F.4
....................    GREEN_Colour.B6 = EEpDat >> 5;
00C94:  SWAPF  3C,W
00C96:  MOVWF  00
00C98:  RRCF   00,F
00C9A:  MOVLW  07
00C9C:  ANDWF  00,F
00C9E:  BCF    x8F.5
00CA0:  BTFSC  00.0
00CA2:  BSF    x8F.5
....................    GREEN_Colour.B7 = EEpDat >> 6;
00CA4:  SWAPF  3C,W
00CA6:  MOVWF  00
00CA8:  RRCF   00,F
00CAA:  RRCF   00,F
00CAC:  MOVLW  03
00CAE:  ANDWF  00,F
00CB0:  BCF    x8F.6
00CB2:  BTFSC  00.0
00CB4:  BSF    x8F.6
....................    GREEN_Colour.B8 = EEpDat >> 7;
00CB6:  CLRF   00
00CB8:  BTFSC  3C.7
00CBA:  BSF    00.0
00CBC:  BCF    x8F.7
00CBE:  BTFSC  00.0
00CC0:  BSF    x8F.7
....................    
....................    EEpDat = read_eeprom(0x15);
00CC2:  MOVFF  FF2,7D9
00CC6:  BCF    FF2.7
00CC8:  CLRF   FAA
00CCA:  MOVLW  15
00CCC:  MOVWF  FA9
00CCE:  BCF    FA6.6
00CD0:  BCF    FA6.7
00CD2:  BSF    FA6.0
00CD4:  MOVF   FA8,W
00CD6:  BTFSC  xD9.7
00CD8:  BSF    FF2.7
00CDA:  MOVWF  3C
....................    //Green9_10 = EEpDat;
....................    GREEN_Colour.B9 = EEpDat;
00CDC:  BCF    x90.0
00CDE:  BTFSC  3C.0
00CE0:  BSF    x90.0
....................    GREEN_Colour.B10 = EEpDat >> 1;
00CE2:  BCF    FD8.0
00CE4:  RRCF   3C,W
00CE6:  BCF    x90.1
00CE8:  BTFSC  FE8.0
00CEA:  BSF    x90.1
....................    //////////////////////////////////////////////////
.................... 
....................    AutoAck = read_eeprom(0x18);          // Auto Acknoeledge
00CEC:  MOVFF  FF2,7D9
00CF0:  BCF    FF2.7
00CF2:  CLRF   FAA
00CF4:  MOVLW  18
00CF6:  MOVWF  FA9
00CF8:  BCF    FA6.6
00CFA:  BCF    FA6.7
00CFC:  BSF    FA6.0
00CFE:  MOVF   FA8,W
00D00:  BTFSC  xD9.7
00D02:  BSF    FF2.7
00D04:  MOVLB  0
00D06:  MOVWF  x60
....................    AutoAckTime = read_eeprom(0x19);      // Auto Acknoeledge Time
00D08:  MOVFF  FF2,7D9
00D0C:  BCF    FF2.7
00D0E:  CLRF   FAA
00D10:  MOVLW  19
00D12:  MOVWF  FA9
00D14:  BCF    FA6.6
00D16:  BCF    FA6.7
00D18:  BSF    FA6.0
00D1A:  MOVF   FA8,W
00D1C:  MOVLB  7
00D1E:  BTFSC  xD9.7
00D20:  BSF    FF2.7
00D22:  MOVLB  0
00D24:  MOVWF  x61
....................    FlashingRate = read_eeprom(0x1A); // Flashing rate
00D26:  MOVFF  FF2,7D9
00D2A:  BCF    FF2.7
00D2C:  CLRF   FAA
00D2E:  MOVLW  1A
00D30:  MOVWF  FA9
00D32:  BCF    FA6.6
00D34:  BCF    FA6.7
00D36:  BSF    FA6.0
00D38:  MOVF   FA8,W
00D3A:  MOVLB  7
00D3C:  BTFSC  xD9.7
00D3E:  BSF    FF2.7
00D40:  MOVLB  0
00D42:  MOVWF  x62
....................    NoOfPoint = read_eeprom(0x1B);        // Number of total point
00D44:  MOVFF  FF2,7D9
00D48:  BCF    FF2.7
00D4A:  CLRF   FAA
00D4C:  MOVLW  1B
00D4E:  MOVWF  FA9
00D50:  BCF    FA6.6
00D52:  BCF    FA6.7
00D54:  BSF    FA6.0
00D56:  MOVF   FA8,W
00D58:  MOVLB  7
00D5A:  BTFSC  xD9.7
00D5C:  BSF    FF2.7
00D5E:  MOVLB  0
00D60:  MOVWF  x63
....................    FaultDelayTime[0] = read_eeprom(0x1C);  // Master or slave sync(flashing)
00D62:  MOVFF  FF2,7D9
00D66:  BCF    FF2.7
00D68:  CLRF   FAA
00D6A:  MOVLW  1C
00D6C:  MOVWF  FA9
00D6E:  BCF    FA6.6
00D70:  BCF    FA6.7
00D72:  BSF    FA6.0
00D74:  MOVF   FA8,W
00D76:  MOVLB  7
00D78:  BTFSC  xD9.7
00D7A:  BSF    FF2.7
00D7C:  CLRF   xAE
00D7E:  MOVWF  xAD
.................... 
....................    Address = read_eeprom(0x1D);          //Communication address
00D80:  MOVFF  FF2,7D9
00D84:  BCF    FF2.7
00D86:  CLRF   FAA
00D88:  MOVLW  1D
00D8A:  MOVWF  FA9
00D8C:  BCF    FA6.6
00D8E:  BCF    FA6.7
00D90:  BSF    FA6.0
00D92:  MOVF   FA8,W
00D94:  BTFSC  xD9.7
00D96:  BSF    FF2.7
00D98:  MOVLB  0
00D9A:  MOVWF  x70
....................    
....................    FaultDelayTime[1] = read_eeprom(0x1E);
00D9C:  MOVFF  FF2,7D9
00DA0:  BCF    FF2.7
00DA2:  CLRF   FAA
00DA4:  MOVLW  1E
00DA6:  MOVWF  FA9
00DA8:  BCF    FA6.6
00DAA:  BCF    FA6.7
00DAC:  BSF    FA6.0
00DAE:  MOVF   FA8,W
00DB0:  MOVLB  7
00DB2:  BTFSC  xD9.7
00DB4:  BSF    FF2.7
00DB6:  CLRF   xB0
00DB8:  MOVWF  xAF
....................    FaultDelayTime[2] = read_eeprom(0x1F);
00DBA:  MOVFF  FF2,7D9
00DBE:  BCF    FF2.7
00DC0:  CLRF   FAA
00DC2:  MOVLW  1F
00DC4:  MOVWF  FA9
00DC6:  BCF    FA6.6
00DC8:  BCF    FA6.7
00DCA:  BSF    FA6.0
00DCC:  MOVF   FA8,W
00DCE:  BTFSC  xD9.7
00DD0:  BSF    FF2.7
00DD2:  CLRF   xB2
00DD4:  MOVWF  xB1
....................    FaultDelayTime[3] = read_eeprom(0x20);
00DD6:  MOVFF  FF2,7D9
00DDA:  BCF    FF2.7
00DDC:  CLRF   FAA
00DDE:  MOVLW  20
00DE0:  MOVWF  FA9
00DE2:  BCF    FA6.6
00DE4:  BCF    FA6.7
00DE6:  BSF    FA6.0
00DE8:  MOVF   FA8,W
00DEA:  BTFSC  xD9.7
00DEC:  BSF    FF2.7
00DEE:  CLRF   xB4
00DF0:  MOVWF  xB3
....................    FaultDelayTime[4] = read_eeprom(0x21);
00DF2:  MOVFF  FF2,7D9
00DF6:  BCF    FF2.7
00DF8:  CLRF   FAA
00DFA:  MOVLW  21
00DFC:  MOVWF  FA9
00DFE:  BCF    FA6.6
00E00:  BCF    FA6.7
00E02:  BSF    FA6.0
00E04:  MOVF   FA8,W
00E06:  BTFSC  xD9.7
00E08:  BSF    FF2.7
00E0A:  CLRF   xB6
00E0C:  MOVWF  xB5
....................    FaultDelayTime[5] = read_eeprom(0x22);
00E0E:  MOVFF  FF2,7D9
00E12:  BCF    FF2.7
00E14:  CLRF   FAA
00E16:  MOVLW  22
00E18:  MOVWF  FA9
00E1A:  BCF    FA6.6
00E1C:  BCF    FA6.7
00E1E:  BSF    FA6.0
00E20:  MOVF   FA8,W
00E22:  BTFSC  xD9.7
00E24:  BSF    FF2.7
00E26:  CLRF   xB8
00E28:  MOVWF  xB7
....................    FaultDelayTime[6] = read_eeprom(0x23);
00E2A:  MOVFF  FF2,7D9
00E2E:  BCF    FF2.7
00E30:  CLRF   FAA
00E32:  MOVLW  23
00E34:  MOVWF  FA9
00E36:  BCF    FA6.6
00E38:  BCF    FA6.7
00E3A:  BSF    FA6.0
00E3C:  MOVF   FA8,W
00E3E:  BTFSC  xD9.7
00E40:  BSF    FF2.7
00E42:  CLRF   xBA
00E44:  MOVWF  xB9
....................    FaultDelayTime[7] = read_eeprom(0x24);
00E46:  MOVFF  FF2,7D9
00E4A:  BCF    FF2.7
00E4C:  CLRF   FAA
00E4E:  MOVLW  24
00E50:  MOVWF  FA9
00E52:  BCF    FA6.6
00E54:  BCF    FA6.7
00E56:  BSF    FA6.0
00E58:  MOVF   FA8,W
00E5A:  BTFSC  xD9.7
00E5C:  BSF    FF2.7
00E5E:  CLRF   xBC
00E60:  MOVWF  xBB
....................    FaultDelayTime[8] = read_eeprom(0x25);
00E62:  MOVFF  FF2,7D9
00E66:  BCF    FF2.7
00E68:  CLRF   FAA
00E6A:  MOVLW  25
00E6C:  MOVWF  FA9
00E6E:  BCF    FA6.6
00E70:  BCF    FA6.7
00E72:  BSF    FA6.0
00E74:  MOVF   FA8,W
00E76:  BTFSC  xD9.7
00E78:  BSF    FF2.7
00E7A:  CLRF   xBE
00E7C:  MOVWF  xBD
....................    FaultDelayTime[9] = read_eeprom(0x26);
00E7E:  MOVFF  FF2,7D9
00E82:  BCF    FF2.7
00E84:  CLRF   FAA
00E86:  MOVLW  26
00E88:  MOVWF  FA9
00E8A:  BCF    FA6.6
00E8C:  BCF    FA6.7
00E8E:  BSF    FA6.0
00E90:  MOVF   FA8,W
00E92:  BTFSC  xD9.7
00E94:  BSF    FF2.7
00E96:  CLRF   xC0
00E98:  MOVWF  xBF
....................    FaultDelayTime[10] = read_eeprom(0x27);
00E9A:  MOVFF  FF2,7D9
00E9E:  BCF    FF2.7
00EA0:  CLRF   FAA
00EA2:  MOVLW  27
00EA4:  MOVWF  FA9
00EA6:  BCF    FA6.6
00EA8:  BCF    FA6.7
00EAA:  BSF    FA6.0
00EAC:  MOVF   FA8,W
00EAE:  BTFSC  xD9.7
00EB0:  BSF    FF2.7
00EB2:  CLRF   xC2
00EB4:  MOVWF  xC1
....................    FaultDelayTime[11] = read_eeprom(0x28);
00EB6:  MOVFF  FF2,7D9
00EBA:  BCF    FF2.7
00EBC:  CLRF   FAA
00EBE:  MOVLW  28
00EC0:  MOVWF  FA9
00EC2:  BCF    FA6.6
00EC4:  BCF    FA6.7
00EC6:  BSF    FA6.0
00EC8:  MOVF   FA8,W
00ECA:  BTFSC  xD9.7
00ECC:  BSF    FF2.7
00ECE:  CLRF   xC4
00ED0:  MOVWF  xC3
....................    FaultDelayTime[12] = read_eeprom(0x29);
00ED2:  MOVFF  FF2,7D9
00ED6:  BCF    FF2.7
00ED8:  CLRF   FAA
00EDA:  MOVLW  29
00EDC:  MOVWF  FA9
00EDE:  BCF    FA6.6
00EE0:  BCF    FA6.7
00EE2:  BSF    FA6.0
00EE4:  MOVF   FA8,W
00EE6:  BTFSC  xD9.7
00EE8:  BSF    FF2.7
00EEA:  CLRF   xC6
00EEC:  MOVWF  xC5
....................    FaultDelayTime[13] = read_eeprom(0x2A);
00EEE:  MOVFF  FF2,7D9
00EF2:  BCF    FF2.7
00EF4:  CLRF   FAA
00EF6:  MOVLW  2A
00EF8:  MOVWF  FA9
00EFA:  BCF    FA6.6
00EFC:  BCF    FA6.7
00EFE:  BSF    FA6.0
00F00:  MOVF   FA8,W
00F02:  BTFSC  xD9.7
00F04:  BSF    FF2.7
00F06:  CLRF   xC8
00F08:  MOVWF  xC7
....................    FaultDelayTime[14] = read_eeprom(0x2B);
00F0A:  MOVFF  FF2,7D9
00F0E:  BCF    FF2.7
00F10:  CLRF   FAA
00F12:  MOVLW  2B
00F14:  MOVWF  FA9
00F16:  BCF    FA6.6
00F18:  BCF    FA6.7
00F1A:  BSF    FA6.0
00F1C:  MOVF   FA8,W
00F1E:  BTFSC  xD9.7
00F20:  BSF    FF2.7
00F22:  CLRF   xCA
00F24:  MOVWF  xC9
....................    FaultDelayTime[15] = read_eeprom(0x2C);
00F26:  MOVFF  FF2,7D9
00F2A:  BCF    FF2.7
00F2C:  CLRF   FAA
00F2E:  MOVLW  2C
00F30:  MOVWF  FA9
00F32:  BCF    FA6.6
00F34:  BCF    FA6.7
00F36:  BSF    FA6.0
00F38:  MOVF   FA8,W
00F3A:  BTFSC  xD9.7
00F3C:  BSF    FF2.7
00F3E:  CLRF   xCC
00F40:  MOVWF  xCB
....................    FaultDelayTime[16] = read_eeprom(0x2D);
00F42:  MOVFF  FF2,7D9
00F46:  BCF    FF2.7
00F48:  CLRF   FAA
00F4A:  MOVLW  2D
00F4C:  MOVWF  FA9
00F4E:  BCF    FA6.6
00F50:  BCF    FA6.7
00F52:  BSF    FA6.0
00F54:  MOVF   FA8,W
00F56:  BTFSC  xD9.7
00F58:  BSF    FF2.7
00F5A:  CLRF   xCE
00F5C:  MOVWF  xCD
....................    FaultDelayTime[17] = read_eeprom(0x2E);
00F5E:  MOVFF  FF2,7D9
00F62:  BCF    FF2.7
00F64:  CLRF   FAA
00F66:  MOVLW  2E
00F68:  MOVWF  FA9
00F6A:  BCF    FA6.6
00F6C:  BCF    FA6.7
00F6E:  BSF    FA6.0
00F70:  MOVF   FA8,W
00F72:  BTFSC  xD9.7
00F74:  BSF    FF2.7
00F76:  CLRF   xD0
00F78:  MOVWF  xCF
....................    FaultDelayTime[18] = read_eeprom(0x2F);
00F7A:  MOVFF  FF2,7D9
00F7E:  BCF    FF2.7
00F80:  CLRF   FAA
00F82:  MOVLW  2F
00F84:  MOVWF  FA9
00F86:  BCF    FA6.6
00F88:  BCF    FA6.7
00F8A:  BSF    FA6.0
00F8C:  MOVF   FA8,W
00F8E:  BTFSC  xD9.7
00F90:  BSF    FF2.7
00F92:  CLRF   xD2
00F94:  MOVWF  xD1
....................    FaultDelayTime[19] = read_eeprom(0x30);
00F96:  MOVFF  FF2,7D9
00F9A:  BCF    FF2.7
00F9C:  CLRF   FAA
00F9E:  MOVLW  30
00FA0:  MOVWF  FA9
00FA2:  BCF    FA6.6
00FA4:  BCF    FA6.7
00FA6:  BSF    FA6.0
00FA8:  MOVF   FA8,W
00FAA:  BTFSC  xD9.7
00FAC:  BSF    FF2.7
00FAE:  CLRF   xD4
00FB0:  MOVWF  xD3
....................    FaultDelayTime[20] = read_eeprom(0x31);
00FB2:  MOVFF  FF2,7D9
00FB6:  BCF    FF2.7
00FB8:  CLRF   FAA
00FBA:  MOVLW  31
00FBC:  MOVWF  FA9
00FBE:  BCF    FA6.6
00FC0:  BCF    FA6.7
00FC2:  BSF    FA6.0
00FC4:  MOVF   FA8,W
00FC6:  BTFSC  xD9.7
00FC8:  BSF    FF2.7
00FCA:  CLRF   xD6
00FCC:  MOVWF  xD5
....................    
....................    unsigned int  a = 0; 
....................    unsigned char  phonenum;
00FCE:  CLRF   xCF
....................    for(; ; a++)
....................    {
....................       restart_wdt();
00FD0:  CLRWDT
....................       phonenum = read_eeprom(0x32 + a);
00FD2:  MOVLW  32
00FD4:  ADDWF  xCF,W
00FD6:  MOVWF  xD9
00FD8:  MOVFF  FF2,7DA
00FDC:  BCF    FF2.7
00FDE:  CLRF   FAA
00FE0:  MOVFF  7D9,FA9
00FE4:  BCF    FA6.6
00FE6:  BCF    FA6.7
00FE8:  BSF    FA6.0
00FEA:  MOVF   FA8,W
00FEC:  BTFSC  xDA.7
00FEE:  BSF    FF2.7
00FF0:  MOVWF  xD0
....................       if((phonenum == 0x0D) || (a > 15))
00FF2:  MOVF   xD0,W
00FF4:  SUBLW  0D
00FF6:  BZ    0FFE
00FF8:  MOVF   xCF,W
00FFA:  SUBLW  0F
00FFC:  BC    1046
....................       {
....................          sms_phonenumber[a] =  '\0';
00FFE:  CLRF   03
01000:  MOVF   xCF,W
01002:  ADDLW  82
01004:  MOVWF  FE9
01006:  MOVLW  05
01008:  ADDWFC 03,W
0100A:  MOVWF  FEA
0100C:  CLRF   FEF
....................          write_eeprom(0x32+a,phonenum);
0100E:  MOVLW  32
01010:  ADDWF  xCF,W
01012:  MOVWF  xD9
01014:  MOVF   FF2,W
01016:  MOVWF  00
01018:  BCF    FF2.7
0101A:  CLRF   FAA
0101C:  MOVFF  7D9,FA9
01020:  MOVFF  7D0,FA8
01024:  BCF    FA6.6
01026:  BCF    FA6.7
01028:  BSF    FA6.2
0102A:  MOVLB  F
0102C:  MOVLW  55
0102E:  MOVWF  FA7
01030:  MOVLW  AA
01032:  MOVWF  FA7
01034:  BSF    FA6.1
01036:  BTFSC  FA6.1
01038:  BRA    1036
0103A:  BCF    FA6.2
0103C:  MOVF   00,W
0103E:  IORWF  FF2,F
....................          break;
01040:  BRA    1062
....................       }
01042:  BRA    105A
01044:  MOVLB  7
....................       else
....................       {
....................          sms_phonenumber[a] = phonenum;
01046:  CLRF   03
01048:  MOVF   xCF,W
0104A:  ADDLW  82
0104C:  MOVWF  FE9
0104E:  MOVLW  05
01050:  ADDWFC 03,W
01052:  MOVWF  FEA
01054:  MOVFF  7D0,FEF
01058:  MOVLB  F
....................       }
0105A:  MOVLB  7
0105C:  INCF   xCF,F
0105E:  BRA    0FD0
01060:  MOVLB  F
....................    }
....................    
....................       
....................    int16  i =3,j=0,k=0 , buff;
01062:  MOVLB  7
01064:  CLRF   xD2
01066:  MOVLW  03
01068:  MOVWF  xD1
0106A:  CLRF   xD4
0106C:  CLRF   xD3
0106E:  CLRF   xD6
01070:  CLRF   xD5
....................    for(; ; i++,j++)
....................    {
....................       restart_wdt();
01072:  CLRWDT
....................       buff = read_eeprom(0x5D+i);
01074:  MOVLW  5D
01076:  ADDWF  xD1,W
01078:  MOVWF  xD9
0107A:  MOVLW  00
0107C:  ADDWFC xD2,W
0107E:  MOVWF  xDA
01080:  MOVFF  FF2,7DB
01084:  BCF    FF2.7
01086:  MOVFF  7DA,FAA
0108A:  MOVFF  7D9,FA9
0108E:  BCF    FA6.6
01090:  BCF    FA6.7
01092:  BSF    FA6.0
01094:  MOVF   FA8,W
01096:  BTFSC  xDB.7
01098:  BSF    FF2.7
0109A:  CLRF   xD8
0109C:  MOVWF  xD7
....................       
....................       if((buff == 0x0D)|| (j>30))
0109E:  MOVF   xD7,W
010A0:  SUBLW  0D
010A2:  BNZ   10A8
010A4:  MOVF   xD8,F
010A6:  BZ    10B2
010A8:  MOVF   xD4,F
010AA:  BNZ   10B2
010AC:  MOVF   xD3,W
010AE:  SUBLW  1E
010B0:  BC    10C4
....................       {
....................          SMS_Massage1[j] = '\0' ; // end string
010B2:  MOVLW  91
010B4:  ADDWF  xD3,W
010B6:  MOVWF  FE9
010B8:  MOVLW  05
010BA:  ADDWFC xD4,W
010BC:  MOVWF  FEA
010BE:  CLRF   FEF
....................          break;
010C0:  BRA    10E8
....................       }
010C2:  BRA    10D4
....................       else
....................       {
....................          SMS_Massage1[j] = buff;  
010C4:  MOVLW  91
010C6:  ADDWF  xD3,W
010C8:  MOVWF  FE9
010CA:  MOVLW  05
010CC:  ADDWFC xD4,W
010CE:  MOVWF  FEA
010D0:  MOVFF  7D7,FEF
....................       }
010D4:  MOVFF  7D2,03
010D8:  MOVF   xD1,W
010DA:  INCF   xD1,F
010DC:  BTFSC  FD8.2
010DE:  INCF   xD2,F
010E0:  INCF   xD3,F
010E2:  BTFSC  FD8.2
010E4:  INCF   xD4,F
010E6:  BRA    1072
....................    }
....................    
....................    i++;
010E8:  INCF   xD1,F
010EA:  BTFSC  FD8.2
010EC:  INCF   xD2,F
....................    j=0;
010EE:  CLRF   xD4
010F0:  CLRF   xD3
....................    
....................    for(; ; i++,j++)
....................    {
....................       restart_wdt();
010F2:  CLRWDT
....................       buff = read_eeprom(0x5D+i);
010F4:  MOVLW  5D
010F6:  ADDWF  xD1,W
010F8:  MOVWF  xD9
010FA:  MOVLW  00
010FC:  ADDWFC xD2,W
010FE:  MOVWF  xDA
01100:  MOVFF  FF2,7DB
01104:  BCF    FF2.7
01106:  MOVFF  7DA,FAA
0110A:  MOVFF  7D9,FA9
0110E:  BCF    FA6.6
01110:  BCF    FA6.7
01112:  BSF    FA6.0
01114:  MOVF   FA8,W
01116:  BTFSC  xDB.7
01118:  BSF    FF2.7
0111A:  CLRF   xD8
0111C:  MOVWF  xD7
....................       
....................       if((buff == 0x0D) || (j>30))
0111E:  MOVF   xD7,W
01120:  SUBLW  0D
01122:  BNZ   1128
01124:  MOVF   xD8,F
01126:  BZ    1132
01128:  MOVF   xD4,F
0112A:  BNZ   1132
0112C:  MOVF   xD3,W
0112E:  SUBLW  1E
01130:  BC    1144
....................       {
....................          SMS_Massage2[j] = '\0' ; // end string
01132:  MOVLW  B1
01134:  ADDWF  xD3,W
01136:  MOVWF  FE9
01138:  MOVLW  05
0113A:  ADDWFC xD4,W
0113C:  MOVWF  FEA
0113E:  CLRF   FEF
....................          break;
01140:  BRA    1168
....................       }
01142:  BRA    1154
....................       else
....................       {
....................          SMS_Massage2[j] = buff;
01144:  MOVLW  B1
01146:  ADDWF  xD3,W
01148:  MOVWF  FE9
0114A:  MOVLW  05
0114C:  ADDWFC xD4,W
0114E:  MOVWF  FEA
01150:  MOVFF  7D7,FEF
....................          
....................       }
01154:  MOVFF  7D2,03
01158:  MOVF   xD1,W
0115A:  INCF   xD1,F
0115C:  BTFSC  FD8.2
0115E:  INCF   xD2,F
01160:  INCF   xD3,F
01162:  BTFSC  FD8.2
01164:  INCF   xD4,F
01166:  BRA    10F2
....................    }
....................    
....................    i++;
01168:  INCF   xD1,F
0116A:  BTFSC  FD8.2
0116C:  INCF   xD2,F
....................    j=0;
0116E:  CLRF   xD4
01170:  CLRF   xD3
....................    
....................    for(; ; i++,j++)
....................    {
....................       restart_wdt();
01172:  CLRWDT
....................       buff = read_eeprom(0x5D+i);
01174:  MOVLW  5D
01176:  ADDWF  xD1,W
01178:  MOVWF  xD9
0117A:  MOVLW  00
0117C:  ADDWFC xD2,W
0117E:  MOVWF  xDA
01180:  MOVFF  FF2,7DB
01184:  BCF    FF2.7
01186:  MOVFF  7DA,FAA
0118A:  MOVFF  7D9,FA9
0118E:  BCF    FA6.6
01190:  BCF    FA6.7
01192:  BSF    FA6.0
01194:  MOVF   FA8,W
01196:  BTFSC  xDB.7
01198:  BSF    FF2.7
0119A:  CLRF   xD8
0119C:  MOVWF  xD7
....................       
....................       if((buff == 0x0D) || (j>30))
0119E:  MOVF   xD7,W
011A0:  SUBLW  0D
011A2:  BNZ   11A8
011A4:  MOVF   xD8,F
011A6:  BZ    11B2
011A8:  MOVF   xD4,F
011AA:  BNZ   11B2
011AC:  MOVF   xD3,W
011AE:  SUBLW  1E
011B0:  BC    11C4
....................       {
....................          SMS_Massage3[j] = '\0' ; // end string
011B2:  MOVLW  D1
011B4:  ADDWF  xD3,W
011B6:  MOVWF  FE9
011B8:  MOVLW  05
011BA:  ADDWFC xD4,W
011BC:  MOVWF  FEA
011BE:  CLRF   FEF
....................          break;
011C0:  BRA    11E8
....................       }
011C2:  BRA    11D4
....................       else
....................       {
....................          SMS_Massage3[j] = buff;
011C4:  MOVLW  D1
011C6:  ADDWF  xD3,W
011C8:  MOVWF  FE9
011CA:  MOVLW  05
011CC:  ADDWFC xD4,W
011CE:  MOVWF  FEA
011D0:  MOVFF  7D7,FEF
....................          
....................       }
011D4:  MOVFF  7D2,03
011D8:  MOVF   xD1,W
011DA:  INCF   xD1,F
011DC:  BTFSC  FD8.2
011DE:  INCF   xD2,F
011E0:  INCF   xD3,F
011E2:  BTFSC  FD8.2
011E4:  INCF   xD4,F
011E6:  BRA    1172
....................    }
....................    
....................    i++;
011E8:  INCF   xD1,F
011EA:  BTFSC  FD8.2
011EC:  INCF   xD2,F
....................    j=0;
011EE:  CLRF   xD4
011F0:  CLRF   xD3
....................    
....................    for(; ; i++,j++)
....................    {
....................       restart_wdt();
011F2:  CLRWDT
....................       buff = read_eeprom(0x5D+i);
011F4:  MOVLW  5D
011F6:  ADDWF  xD1,W
011F8:  MOVWF  xD9
011FA:  MOVLW  00
011FC:  ADDWFC xD2,W
011FE:  MOVWF  xDA
01200:  MOVFF  FF2,7DB
01204:  BCF    FF2.7
01206:  MOVFF  7DA,FAA
0120A:  MOVFF  7D9,FA9
0120E:  BCF    FA6.6
01210:  BCF    FA6.7
01212:  BSF    FA6.0
01214:  MOVF   FA8,W
01216:  BTFSC  xDB.7
01218:  BSF    FF2.7
0121A:  CLRF   xD8
0121C:  MOVWF  xD7
....................       
....................       if((buff == 0x0D) || (j>30))
0121E:  MOVF   xD7,W
01220:  SUBLW  0D
01222:  BNZ   1228
01224:  MOVF   xD8,F
01226:  BZ    1232
01228:  MOVF   xD4,F
0122A:  BNZ   1232
0122C:  MOVF   xD3,W
0122E:  SUBLW  1E
01230:  BC    1244
....................       {
....................          SMS_Massage4[j] = '\0' ; // end string
01232:  MOVLW  F1
01234:  ADDWF  xD3,W
01236:  MOVWF  FE9
01238:  MOVLW  05
0123A:  ADDWFC xD4,W
0123C:  MOVWF  FEA
0123E:  CLRF   FEF
....................          break;
01240:  BRA    1268
....................       }
01242:  BRA    1254
....................       else
....................       {
....................          SMS_Massage4[j] = buff;
01244:  MOVLW  F1
01246:  ADDWF  xD3,W
01248:  MOVWF  FE9
0124A:  MOVLW  05
0124C:  ADDWFC xD4,W
0124E:  MOVWF  FEA
01250:  MOVFF  7D7,FEF
....................          
....................       }
01254:  MOVFF  7D2,03
01258:  MOVF   xD1,W
0125A:  INCF   xD1,F
0125C:  BTFSC  FD8.2
0125E:  INCF   xD2,F
01260:  INCF   xD3,F
01262:  BTFSC  FD8.2
01264:  INCF   xD4,F
01266:  BRA    11F2
....................    }
....................    
....................    i++;
01268:  INCF   xD1,F
0126A:  BTFSC  FD8.2
0126C:  INCF   xD2,F
....................    j=0;
0126E:  CLRF   xD4
01270:  CLRF   xD3
....................    
....................    for(; ; i++,j++)
....................    {
....................       restart_wdt();
01272:  CLRWDT
....................       buff = read_eeprom(0x5D+i);
01274:  MOVLW  5D
01276:  ADDWF  xD1,W
01278:  MOVWF  xD9
0127A:  MOVLW  00
0127C:  ADDWFC xD2,W
0127E:  MOVWF  xDA
01280:  MOVFF  FF2,7DB
01284:  BCF    FF2.7
01286:  MOVFF  7DA,FAA
0128A:  MOVFF  7D9,FA9
0128E:  BCF    FA6.6
01290:  BCF    FA6.7
01292:  BSF    FA6.0
01294:  MOVF   FA8,W
01296:  BTFSC  xDB.7
01298:  BSF    FF2.7
0129A:  CLRF   xD8
0129C:  MOVWF  xD7
....................       
....................       if((buff == 0x0D) || (j>30))
0129E:  MOVF   xD7,W
012A0:  SUBLW  0D
012A2:  BNZ   12A8
012A4:  MOVF   xD8,F
012A6:  BZ    12B2
012A8:  MOVF   xD4,F
012AA:  BNZ   12B2
012AC:  MOVF   xD3,W
012AE:  SUBLW  1E
012B0:  BC    12C4
....................       {
....................          SMS_Massage5[j] = '\0' ; // end string
012B2:  MOVLW  11
012B4:  ADDWF  xD3,W
012B6:  MOVWF  FE9
012B8:  MOVLW  06
012BA:  ADDWFC xD4,W
012BC:  MOVWF  FEA
012BE:  CLRF   FEF
....................          break;
012C0:  BRA    12E8
....................       }
012C2:  BRA    12D4
....................       else
....................       {
....................          SMS_Massage5[j] = buff;
012C4:  MOVLW  11
012C6:  ADDWF  xD3,W
012C8:  MOVWF  FE9
012CA:  MOVLW  06
012CC:  ADDWFC xD4,W
012CE:  MOVWF  FEA
012D0:  MOVFF  7D7,FEF
....................          
....................       }
012D4:  MOVFF  7D2,03
012D8:  MOVF   xD1,W
012DA:  INCF   xD1,F
012DC:  BTFSC  FD8.2
012DE:  INCF   xD2,F
012E0:  INCF   xD3,F
012E2:  BTFSC  FD8.2
012E4:  INCF   xD4,F
012E6:  BRA    1272
....................    }
....................    
....................    i++;
012E8:  INCF   xD1,F
012EA:  BTFSC  FD8.2
012EC:  INCF   xD2,F
....................    j=0;
012EE:  CLRF   xD4
012F0:  CLRF   xD3
....................    
....................    for(; ; i++,j++)
....................    {
....................       restart_wdt();
012F2:  CLRWDT
....................       buff = read_eeprom(0x5D+i);
012F4:  MOVLW  5D
012F6:  ADDWF  xD1,W
012F8:  MOVWF  xD9
012FA:  MOVLW  00
012FC:  ADDWFC xD2,W
012FE:  MOVWF  xDA
01300:  MOVFF  FF2,7DB
01304:  BCF    FF2.7
01306:  MOVFF  7DA,FAA
0130A:  MOVFF  7D9,FA9
0130E:  BCF    FA6.6
01310:  BCF    FA6.7
01312:  BSF    FA6.0
01314:  MOVF   FA8,W
01316:  BTFSC  xDB.7
01318:  BSF    FF2.7
0131A:  CLRF   xD8
0131C:  MOVWF  xD7
....................       
....................       if((buff == 0x0D) || (j>30))
0131E:  MOVF   xD7,W
01320:  SUBLW  0D
01322:  BNZ   1328
01324:  MOVF   xD8,F
01326:  BZ    1332
01328:  MOVF   xD4,F
0132A:  BNZ   1332
0132C:  MOVF   xD3,W
0132E:  SUBLW  1E
01330:  BC    1344
....................       {
....................          SMS_Massage6[j] = '\0' ; // end string
01332:  MOVLW  31
01334:  ADDWF  xD3,W
01336:  MOVWF  FE9
01338:  MOVLW  06
0133A:  ADDWFC xD4,W
0133C:  MOVWF  FEA
0133E:  CLRF   FEF
....................          break;
01340:  BRA    1368
....................       }
01342:  BRA    1354
....................       else
....................       {
....................          SMS_Massage6[j] = buff;
01344:  MOVLW  31
01346:  ADDWF  xD3,W
01348:  MOVWF  FE9
0134A:  MOVLW  06
0134C:  ADDWFC xD4,W
0134E:  MOVWF  FEA
01350:  MOVFF  7D7,FEF
....................          
....................       }
01354:  MOVFF  7D2,03
01358:  MOVF   xD1,W
0135A:  INCF   xD1,F
0135C:  BTFSC  FD8.2
0135E:  INCF   xD2,F
01360:  INCF   xD3,F
01362:  BTFSC  FD8.2
01364:  INCF   xD4,F
01366:  BRA    12F2
....................    }
....................    
....................    i++;
01368:  INCF   xD1,F
0136A:  BTFSC  FD8.2
0136C:  INCF   xD2,F
....................    j=0;
0136E:  CLRF   xD4
01370:  CLRF   xD3
....................    
....................    for(; ; i++,j++)
....................    {
....................       restart_wdt();
01372:  CLRWDT
....................       buff = read_eeprom(0x5D+i);
01374:  MOVLW  5D
01376:  ADDWF  xD1,W
01378:  MOVWF  xD9
0137A:  MOVLW  00
0137C:  ADDWFC xD2,W
0137E:  MOVWF  xDA
01380:  MOVFF  FF2,7DB
01384:  BCF    FF2.7
01386:  MOVFF  7DA,FAA
0138A:  MOVFF  7D9,FA9
0138E:  BCF    FA6.6
01390:  BCF    FA6.7
01392:  BSF    FA6.0
01394:  MOVF   FA8,W
01396:  BTFSC  xDB.7
01398:  BSF    FF2.7
0139A:  CLRF   xD8
0139C:  MOVWF  xD7
....................       
....................       if((buff == 0x0D) || (j>30))
0139E:  MOVF   xD7,W
013A0:  SUBLW  0D
013A2:  BNZ   13A8
013A4:  MOVF   xD8,F
013A6:  BZ    13B2
013A8:  MOVF   xD4,F
013AA:  BNZ   13B2
013AC:  MOVF   xD3,W
013AE:  SUBLW  1E
013B0:  BC    13C4
....................       {
....................          SMS_Massage7[j] = '\0' ; // end string
013B2:  MOVLW  51
013B4:  ADDWF  xD3,W
013B6:  MOVWF  FE9
013B8:  MOVLW  06
013BA:  ADDWFC xD4,W
013BC:  MOVWF  FEA
013BE:  CLRF   FEF
....................          break;
013C0:  BRA    13E8
....................       }
013C2:  BRA    13D4
....................       else
....................       {
....................          SMS_Massage7[j] = buff;
013C4:  MOVLW  51
013C6:  ADDWF  xD3,W
013C8:  MOVWF  FE9
013CA:  MOVLW  06
013CC:  ADDWFC xD4,W
013CE:  MOVWF  FEA
013D0:  MOVFF  7D7,FEF
....................          
....................       }
013D4:  MOVFF  7D2,03
013D8:  MOVF   xD1,W
013DA:  INCF   xD1,F
013DC:  BTFSC  FD8.2
013DE:  INCF   xD2,F
013E0:  INCF   xD3,F
013E2:  BTFSC  FD8.2
013E4:  INCF   xD4,F
013E6:  BRA    1372
....................    }
....................    
....................    i++;
013E8:  INCF   xD1,F
013EA:  BTFSC  FD8.2
013EC:  INCF   xD2,F
....................    j=0;
013EE:  CLRF   xD4
013F0:  CLRF   xD3
....................    
....................    for(; ; i++,j++)
....................    {
....................       restart_wdt();
013F2:  CLRWDT
....................       buff = read_eeprom(0x5D+i);
013F4:  MOVLW  5D
013F6:  ADDWF  xD1,W
013F8:  MOVWF  xD9
013FA:  MOVLW  00
013FC:  ADDWFC xD2,W
013FE:  MOVWF  xDA
01400:  MOVFF  FF2,7DB
01404:  BCF    FF2.7
01406:  MOVFF  7DA,FAA
0140A:  MOVFF  7D9,FA9
0140E:  BCF    FA6.6
01410:  BCF    FA6.7
01412:  BSF    FA6.0
01414:  MOVF   FA8,W
01416:  BTFSC  xDB.7
01418:  BSF    FF2.7
0141A:  CLRF   xD8
0141C:  MOVWF  xD7
....................       
....................       if((buff == 0x0D) || (j>30))
0141E:  MOVF   xD7,W
01420:  SUBLW  0D
01422:  BNZ   1428
01424:  MOVF   xD8,F
01426:  BZ    1432
01428:  MOVF   xD4,F
0142A:  BNZ   1432
0142C:  MOVF   xD3,W
0142E:  SUBLW  1E
01430:  BC    1444
....................       {
....................          SMS_Massage8[j] = '\0' ; // end string
01432:  MOVLW  71
01434:  ADDWF  xD3,W
01436:  MOVWF  FE9
01438:  MOVLW  06
0143A:  ADDWFC xD4,W
0143C:  MOVWF  FEA
0143E:  CLRF   FEF
....................          break;
01440:  BRA    1468
....................       }
01442:  BRA    1454
....................       else
....................       {
....................          SMS_Massage8[j] = buff;
01444:  MOVLW  71
01446:  ADDWF  xD3,W
01448:  MOVWF  FE9
0144A:  MOVLW  06
0144C:  ADDWFC xD4,W
0144E:  MOVWF  FEA
01450:  MOVFF  7D7,FEF
....................          
....................       }
01454:  MOVFF  7D2,03
01458:  MOVF   xD1,W
0145A:  INCF   xD1,F
0145C:  BTFSC  FD8.2
0145E:  INCF   xD2,F
01460:  INCF   xD3,F
01462:  BTFSC  FD8.2
01464:  INCF   xD4,F
01466:  BRA    13F2
....................    }
....................    
....................    i++;
01468:  INCF   xD1,F
0146A:  BTFSC  FD8.2
0146C:  INCF   xD2,F
....................    j=0;
0146E:  CLRF   xD4
01470:  CLRF   xD3
....................    
....................    for(; ; i++,j++)
....................    {
....................       restart_wdt();
01472:  CLRWDT
....................       buff = read_eeprom(0x5D+i);
01474:  MOVLW  5D
01476:  ADDWF  xD1,W
01478:  MOVWF  xD9
0147A:  MOVLW  00
0147C:  ADDWFC xD2,W
0147E:  MOVWF  xDA
01480:  MOVFF  FF2,7DB
01484:  BCF    FF2.7
01486:  MOVFF  7DA,FAA
0148A:  MOVFF  7D9,FA9
0148E:  BCF    FA6.6
01490:  BCF    FA6.7
01492:  BSF    FA6.0
01494:  MOVF   FA8,W
01496:  BTFSC  xDB.7
01498:  BSF    FF2.7
0149A:  CLRF   xD8
0149C:  MOVWF  xD7
....................       
....................       if((buff == 0x0D) || (j>30))
0149E:  MOVF   xD7,W
014A0:  SUBLW  0D
014A2:  BNZ   14A8
014A4:  MOVF   xD8,F
014A6:  BZ    14B2
014A8:  MOVF   xD4,F
014AA:  BNZ   14B2
014AC:  MOVF   xD3,W
014AE:  SUBLW  1E
014B0:  BC    14C4
....................       {
....................          SMS_Massage9[j] = '\0' ; // end string
014B2:  MOVLW  91
014B4:  ADDWF  xD3,W
014B6:  MOVWF  FE9
014B8:  MOVLW  06
014BA:  ADDWFC xD4,W
014BC:  MOVWF  FEA
014BE:  CLRF   FEF
....................          break;
014C0:  BRA    14E8
....................       }
014C2:  BRA    14D4
....................       else
....................       {
....................          SMS_Massage9[j] = buff;
014C4:  MOVLW  91
014C6:  ADDWF  xD3,W
014C8:  MOVWF  FE9
014CA:  MOVLW  06
014CC:  ADDWFC xD4,W
014CE:  MOVWF  FEA
014D0:  MOVFF  7D7,FEF
....................          
....................       }
014D4:  MOVFF  7D2,03
014D8:  MOVF   xD1,W
014DA:  INCF   xD1,F
014DC:  BTFSC  FD8.2
014DE:  INCF   xD2,F
014E0:  INCF   xD3,F
014E2:  BTFSC  FD8.2
014E4:  INCF   xD4,F
014E6:  BRA    1472
....................    }
....................    
....................    i++;
014E8:  INCF   xD1,F
014EA:  BTFSC  FD8.2
014EC:  INCF   xD2,F
....................    j=0;
014EE:  CLRF   xD4
014F0:  CLRF   xD3
....................    
....................    for(; ; i++,j++)
....................    {
....................       restart_wdt();
014F2:  CLRWDT
....................       buff = read_eeprom(0x5D+i);
014F4:  MOVLW  5D
014F6:  ADDWF  xD1,W
014F8:  MOVWF  xD9
014FA:  MOVLW  00
014FC:  ADDWFC xD2,W
014FE:  MOVWF  xDA
01500:  MOVFF  FF2,7DB
01504:  BCF    FF2.7
01506:  MOVFF  7DA,FAA
0150A:  MOVFF  7D9,FA9
0150E:  BCF    FA6.6
01510:  BCF    FA6.7
01512:  BSF    FA6.0
01514:  MOVF   FA8,W
01516:  BTFSC  xDB.7
01518:  BSF    FF2.7
0151A:  CLRF   xD8
0151C:  MOVWF  xD7
....................       
....................       if((buff == 0x0D) || (j>30))
0151E:  MOVF   xD7,W
01520:  SUBLW  0D
01522:  BNZ   1528
01524:  MOVF   xD8,F
01526:  BZ    1532
01528:  MOVF   xD4,F
0152A:  BNZ   1532
0152C:  MOVF   xD3,W
0152E:  SUBLW  1E
01530:  BC    1544
....................       {
....................          SMS_Massage10[j] = '\0' ; // end string
01532:  MOVLW  B1
01534:  ADDWF  xD3,W
01536:  MOVWF  FE9
01538:  MOVLW  06
0153A:  ADDWFC xD4,W
0153C:  MOVWF  FEA
0153E:  CLRF   FEF
....................          break;
01540:  BRA    1568
....................       }
01542:  BRA    1554
....................       else
....................       {
....................          SMS_Massage10[j] = buff;
01544:  MOVLW  B1
01546:  ADDWF  xD3,W
01548:  MOVWF  FE9
0154A:  MOVLW  06
0154C:  ADDWFC xD4,W
0154E:  MOVWF  FEA
01550:  MOVFF  7D7,FEF
....................          
....................       }
01554:  MOVFF  7D2,03
01558:  MOVF   xD1,W
0155A:  INCF   xD1,F
0155C:  BTFSC  FD8.2
0155E:  INCF   xD2,F
01560:  INCF   xD3,F
01562:  BTFSC  FD8.2
01564:  INCF   xD4,F
01566:  BRA    14F2
....................    }
01568:  MOVLB  0
0156A:  RETURN 0
....................    
.................... }
.................... //////////////////////////////////////////////////////////////////////////////////
.................... ////////////////////////////////////////////////////////////////////////////////
.................... #int_RDA
.................... void RDA_isr(void)
.................... {
....................    SBUF = getc();
*
005B6:  BTFSS  F9E.5
005B8:  BRA    05B6
005BA:  MOVFF  FAE,30
....................    checkCommand();
005BE:  BRA    02FA
.................... }
005C0:  BCF    F9E.5
005C2:  GOTO   0078
.................... #int_TIMER1
.................... void  TIMER1_isr(void) 
.................... {
....................    //ReadIn_flag =1;
.................... }
.................... 
005C6:  BCF    F9E.0
005C8:  GOTO   0078
.................... #int_TIMER2
.................... void TIMER2_isr(void)      //10ms
.................... {
....................    StatusTime++;
005CC:  INCF   1B,F
.................... 
....................    if(T_timeout != 0)
005CE:  MOVLB  5
005D0:  MOVF   x7E,F
005D2:  BZ    05E2
....................    {
....................       T_timeout--;
005D4:  DECF   x7E,F
....................       if(T_timeout == 0)
005D6:  MOVF   x7E,F
005D8:  BNZ   05E2
....................       {
....................          //sequence = stop_sq;         //timeout
....................          sequence = end_sq;         //timeout 
005DA:  MOVFF  66,6F
....................          output_bit(P485ctrl,0);
005DE:  BCF    F8A.3
005E0:  BCF    F93.3
....................       }
....................    }
....................    ////////// Time Base 1 Second /////////////
....................    if(TimeBase1s != 0x00)
005E2:  MOVF   1E,F
005E4:  BZ    0620
....................    {
....................       TimeBase1s--;
005E6:  DECF   1E,F
....................       if(TimeBase1s == 0x00)      // <====== code in time base 1 second
005E8:  MOVF   1E,F
005EA:  BNZ   0620
....................       {
....................          if(AutoAckDelayTime != 0x00)
005EC:  MOVF   1F,F
005EE:  BZ    05F8
....................          {
....................             AutoAckDelayTime--;
005F0:  DECF   1F,F
....................             if(AutoAckDelayTime == 0x00)
005F2:  MOVF   1F,F
005F4:  BNZ   05F8
....................             {
....................                AutoAckFlag = 1 ;
005F6:  BSF    1C.2
....................             }
....................          }
....................          //////////////////////////////
....................          if(++StartReadCount >=2)
005F8:  MOVLB  0
005FA:  INCF   x65,F
005FC:  MOVF   x65,W
005FE:  SUBLW  01
00600:  BC    0608
....................          {
....................             StartRead = 1;
00602:  BSF    32.4
....................             StartReadCount =2;
00604:  MOVLW  02
00606:  MOVWF  x65
....................          }
....................          if(++send_SMS_count >=5){
00608:  MOVLB  7
0060A:  INCF   x74,F
0060C:  MOVF   x74,W
0060E:  SUBLW  04
00610:  BC    0618
....................             send_SMS_count =0;
00612:  CLRF   x74
....................             send_SMS_period = 1;
00614:  MOVLW  01
00616:  MOVWF  x73
....................          }
....................          ///////////////////////////
....................          RefreshConfigData = 1;
00618:  BSF    32.5
....................          TimeBase1s = 100;
0061A:  MOVLW  64
0061C:  MOVWF  1E
0061E:  MOVLB  5
....................       }
.................... 
....................    }
....................    ///////////// End Time base 1 Second ///////
.................... 
.................... 
.................... 
....................    if(StatusTime == 50)    //500mS
00620:  MOVF   1B,W
00622:  SUBLW  32
00624:  BNZ   064E
....................    {
....................       StatusTime = 0;
00626:  CLRF   1B
....................       if(HearthbeatInd == 0)
00628:  BTFSC  1C.0
0062A:  BRA    0634
....................       {
....................          HearthbeatInd = 1;
0062C:  BSF    1C.0
....................          output_bit(Pled,1);
0062E:  BSF    F8A.5
00630:  BCF    F93.5
....................       }
00632:  BRA    063A
....................       else
....................       {
....................          HearthbeatInd = 0;
00634:  BCF    1C.0
....................          output_bit(Pled,0);
00636:  BCF    F8A.5
00638:  BCF    F93.5
....................       }
....................       /////////////////////////////////////////// time base 500 ms
....................       if(Test == 1)            //Test function
0063A:  BTFSS  1C.6
0063C:  BRA    064C
....................          {
....................              if(T_test > 0x00) T_test --;
0063E:  MOVF   31,F
00640:  BZ    0644
00642:  DECF   31,F
....................              if(T_test == 0x00) Test_fault = 1;
00644:  MOVF   31,F
00646:  BNZ   064A
00648:  BSF    1C.5
....................          }
0064A:  BRA    064E
....................          else
....................          {
....................              //Test = 0;
....................              T_test = 0x00;
0064C:  CLRF   31
....................          }
....................    }
....................    ///////////////////////////////
....................    if(FlashingRateTime != 0)
0064E:  MOVF   1D,F
00650:  BZ    0678
....................    {
....................       FlashingRateTime--;
00652:  DECF   1D,F
....................       if(FlashingRateTime == 0)
00654:  MOVF   1D,F
00656:  BNZ   066C
....................       {
....................          outmcp23 = 0xff;  
00658:  SETF   x81
....................          if(SyncStatus == 0)
0065A:  BTFSC  32.2
0065C:  BRA    0668
....................          {
....................             if(FlashingFlag == 1)
0065E:  BTFSS  1C.1
00660:  BRA    0666
....................             {
....................                FlashingFlag = 0;
00662:  BCF    1C.1
....................                //output_bit(PSyncS,0);
....................             }
00664:  BRA    0668
....................             else
....................             {
....................                FlashingFlag = 1;
00666:  BSF    1C.1
....................                //output_bit(PSyncS,1);
....................             }
....................          }
....................          //FlashingFlag = ~FlashingFlag;
....................          FlashingRateTime = FlashingRate;      //reload value
00668:  MOVFF  62,1D
....................       }
.................... 
....................       if(Synctimer != 0x00)
0066C:  MOVF   33,F
0066E:  BZ    0678
....................       {
....................          Synctimer--;
00670:  DECF   33,F
....................          if(Synctimer == 0x00)
00672:  MOVF   33,F
00674:  BNZ   0678
....................          {
....................             SyncStatus = 0;
00676:  BCF    32.2
....................          }
....................       }
.................... 
....................    }
....................    
....................    
00678:  BCF    F9E.1
0067A:  MOVLB  0
0067C:  GOTO   0078
.................... }
.................... 
.................... ///////////////////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////////////////
.................... 
.................... //////////////////////////////////////////////////////////////////////////////
.................... void Anal_Function(void)
.................... {
....................    /////////////////////////////////////////////////////////////////////////////
....................    ////////////////////////////// MANUAL RESET /////////////////////////////////
....................    /////////////////////////////////////////////////////////////////////////////
.................... //if(NoOfPoint >= 10)
.................... //{
.................... 
.................... //input1
....................    if(AlarmIndicator.B1 == 1)    // Alarm Function
*
0482E:  MOVLB  7
04830:  BTFSS  x81.0
04832:  BRA    48E0
....................    {
....................       if((((Inputt.B1 ^ InputType.B1) == 1) && (FaultType.B1 == 1))|| In.B1 == 1)    // alarm1 occure and "Lock type"
04834:  MOVLW  00
04836:  BTFSC  x75.0
04838:  MOVLW  01
0483A:  MOVWF  xD0
0483C:  MOVLW  00
0483E:  BTFSC  x79.0
04840:  MOVLW  01
04842:  XORWF  xD0,W
04844:  SUBLW  01
04846:  BNZ   484C
04848:  BTFSC  x7B.0
0484A:  BRA    4850
0484C:  BTFSS  x85.0
0484E:  BRA    48D8
....................       //if(Inputt.B1 == 0)
....................       {
....................          if(Ack.B1 == 0)
04850:  BTFSC  x83.0
04852:  BRA    48D6
....................          {
....................             if(In.B1 == 0 && AutoAck == 0x0F)   //use auto acknowlegde
04854:  BTFSC  x85.0
04856:  BRA    4870
04858:  MOVLB  0
0485A:  MOVF   x60,W
0485C:  SUBLW  0F
0485E:  BTFSC  FD8.2
04860:  BRA    4866
04862:  MOVLB  7
04864:  BRA    4870
....................             {
....................                TimeBase1s = 100 ;            //reload again
04866:  MOVLW  64
04868:  MOVWF  1E
....................                AutoAckDelayTime = AutoAckTime ;
0486A:  MOVFF  61,1F
0486E:  MOVLB  7
....................             }
.................... 
....................             In.B1 = 1;                                 // setbit in1
04870:  BSF    x85.0
....................             if(FlashingFlag == 0)                                                                                                                                                                                                                                                                
04872:  BTFSC  1C.1
04874:  BRA    487A
....................             {
....................                Output.B1 = 0;           //Flash output1
04876:  BCF    x77.0
....................             }
04878:  BRA    487C
....................             else
....................             {
....................                Output.B1 = 1;
0487A:  BSF    x77.0
....................             }
.................... 
....................             if (~AutoTestFlag)
0487C:  BTFSC  1C.4
0487E:  BRA    489C
....................             {
....................                if(OutputBoth.B1 == 0)                  //Both output
04880:  BTFSC  x7F.0
04882:  BRA    488E
....................                {
....................                   output_bit(Pbuzzer,1);   //Buzzer
04884:  BSF    F89.4
04886:  BCF    F92.4
....................                   output_bit(Pbell,1);     //Bell
04888:  BSF    F89.3
0488A:  BCF    F92.3
....................                }
0488C:  BRA    489C
....................                else
....................                {
....................                   if(OutputType.B1 == 1) output_bit(Pbuzzer,1);     //Buzzer
0488E:  BTFSS  x7D.0
04890:  BRA    4898
04892:  BSF    F89.4
04894:  BCF    F92.4
04896:  BRA    489C
....................                   else output_bit(Pbell,1);                          //Bell
04898:  BSF    F89.3
0489A:  BCF    F92.3
....................                }
....................             }
....................             //////////////////////////////////////////////////////////////////
....................             // SMS Sending 
....................             if((SendSMS.B1 ==0) && (functointest_f ==0) && (Ack.B1 ==0))
0489C:  BTFSC  x91.0
0489E:  BRA    48D6
048A0:  BTFSC  32.1
048A2:  BRA    48D6
048A4:  BTFSC  x83.0
048A6:  BRA    48D6
....................             {            
....................                SendSMS.B1 =1;
048A8:  BSF    x91.0
....................                strcat(SMS_MassageSUM, SMS_Massage1);
048AA:  MOVLW  06
048AC:  MOVWF  xD0
048AE:  MOVLW  D1
048B0:  MOVWF  xCF
048B2:  MOVLW  05
048B4:  MOVWF  xD2
048B6:  MOVLW  91
048B8:  MOVWF  xD1
048BA:  MOVLB  0
048BC:  RCALL  430C
....................                strcat(SMS_MassageSUM, spacestring);
048BE:  MOVLW  06
048C0:  MOVLB  7
048C2:  MOVWF  xD0
048C4:  MOVLW  D1
048C6:  MOVWF  xCF
048C8:  MOVLW  07
048CA:  MOVWF  xD2
048CC:  MOVLW  71
048CE:  MOVWF  xD1
048D0:  MOVLB  0
048D2:  RCALL  430C
048D4:  MOVLB  7
....................             /*
....................                fprintf(CH2,"AT+CMGF=1"); 
....................                putc('\n',CH2);
....................                delay_ms(10);
.................... 
....................                fprintf(CH2,"AT+CMGS=\"");
....................                fprintf(CH2,sms_phonenumber);
....................                
....................                fprintf(CH2,"\"");
....................                putc('\n',CH2);
....................                delay_ms(50);
....................               
....................               fprintf(CH2,SMS_Massage1);
....................               putc('\n',CH2);
....................               putc(26,CH2);
....................               */
....................             }
....................             //////////////////////////////////////////////////////////////////
....................         }
....................       }
048D6:  BRA    48DE
....................       else if(FaultType.B1 == 1) Ack.B1 = 0;
048D8:  BTFSS  x7B.0
048DA:  BRA    48DE
048DC:  BCF    x83.0
....................    }
048DE:  BRA    4938
....................    else  //Indicator Function
....................    {
....................       if((Inputt.B1 ^ InputType.B1) == 1)
048E0:  MOVLW  00
048E2:  BTFSC  x75.0
048E4:  MOVLW  01
048E6:  MOVWF  xD0
048E8:  MOVLW  00
048EA:  BTFSC  x79.0
048EC:  MOVLW  01
048EE:  XORWF  xD0,W
048F0:  SUBLW  01
048F2:  BNZ   4932
....................       {
....................          Output.B1 = 0;
048F4:  BCF    x77.0
....................          // SMS Sending   
....................          if((SendSMS.B1 ==0) && (functointest_f ==0) && (Ack.B1 ==0))
048F6:  BTFSC  x91.0
048F8:  BRA    4930
048FA:  BTFSC  32.1
048FC:  BRA    4930
048FE:  BTFSC  x83.0
04900:  BRA    4930
....................          {            
....................             SendSMS.B1 =1;
04902:  BSF    x91.0
....................             strcat(SMS_MassageSUM, SMS_Massage1);
04904:  MOVLW  06
04906:  MOVWF  xD0
04908:  MOVLW  D1
0490A:  MOVWF  xCF
0490C:  MOVLW  05
0490E:  MOVWF  xD2
04910:  MOVLW  91
04912:  MOVWF  xD1
04914:  MOVLB  0
04916:  RCALL  430C
....................             strcat(SMS_MassageSUM, spacestring);
04918:  MOVLW  06
0491A:  MOVLB  7
0491C:  MOVWF  xD0
0491E:  MOVLW  D1
04920:  MOVWF  xCF
04922:  MOVLW  07
04924:  MOVWF  xD2
04926:  MOVLW  71
04928:  MOVWF  xD1
0492A:  MOVLB  0
0492C:  RCALL  430C
0492E:  MOVLB  7
....................             /*
....................             fprintf(CH2,"AT+CMGF=1"); 
....................             putc('\n',CH2);
....................             delay_ms(10);
.................... 
....................             fprintf(CH2,"AT+CMGS=\"");
....................             fprintf(CH2,sms_phonenumber);
....................             
....................             fprintf(CH2,"\"");
....................             putc('\n',CH2);
....................             delay_ms(50);
....................            
....................            fprintf(CH2,SMS_Massage1);
....................            putc('\n',CH2);
....................           putc(26,CH2);
....................               */
....................          }
....................       }
04930:  BRA    4938
....................       else
....................       {
....................          Output.B1 = 1;
04932:  BSF    x77.0
....................          
....................          SendSMS.B1 =0;
04934:  BCF    x91.0
....................          functointest_f =0;
04936:  BCF    32.1
....................       }
....................    }
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //input2
....................    if(AlarmIndicator.B2 == 1)    // Alarm Function
04938:  BTFSS  x81.1
0493A:  BRA    49E8
....................    {
....................       if((((Inputt.B2 ^ InputType.B2) == 1) && (FaultType.B2 == 1))|| In.B2 == 1)    // alarm1 occure and "Lock type"
0493C:  MOVLW  00
0493E:  BTFSC  x75.1
04940:  MOVLW  01
04942:  MOVWF  xD0
04944:  MOVLW  00
04946:  BTFSC  x79.1
04948:  MOVLW  01
0494A:  XORWF  xD0,W
0494C:  SUBLW  01
0494E:  BNZ   4954
04950:  BTFSC  x7B.1
04952:  BRA    4958
04954:  BTFSS  x85.1
04956:  BRA    49E0
....................       //if(Inputt.B2 == 0)
....................       {
....................          if(Ack.B2 == 0)
04958:  BTFSC  x83.1
0495A:  BRA    49DE
....................          {
....................             if(In.B2 == 0 && AutoAck == 0x0F)   //use auto acknowlegde
0495C:  BTFSC  x85.1
0495E:  BRA    4978
04960:  MOVLB  0
04962:  MOVF   x60,W
04964:  SUBLW  0F
04966:  BTFSC  FD8.2
04968:  BRA    496E
0496A:  MOVLB  7
0496C:  BRA    4978
....................             {
....................                TimeBase1s = 100 ;            //reload again
0496E:  MOVLW  64
04970:  MOVWF  1E
....................                AutoAckDelayTime = AutoAckTime ;
04972:  MOVFF  61,1F
04976:  MOVLB  7
....................             }
.................... 
....................             In.B2 = 1;                                 // setbit in1
04978:  BSF    x85.1
....................             if(FlashingFlag == 0)
0497A:  BTFSC  1C.1
0497C:  BRA    4982
....................             {
....................                Output.B2 = 0;           //Flash output1
0497E:  BCF    x77.1
....................             }
04980:  BRA    4984
....................             else
....................             {
....................                Output.B2 = 1;
04982:  BSF    x77.1
....................             }
.................... 
....................             if (~AutoTestFlag)
04984:  BTFSC  1C.4
04986:  BRA    49A4
....................             {
....................                if(OutputBoth.B2 == 0)                  //Both output
04988:  BTFSC  x7F.1
0498A:  BRA    4996
....................                {
....................                   output_bit(Pbuzzer,1);   //Buzzer
0498C:  BSF    F89.4
0498E:  BCF    F92.4
....................                   output_bit(Pbell,1);     //Bell
04990:  BSF    F89.3
04992:  BCF    F92.3
....................                }
04994:  BRA    49A4
....................                else
....................                {
....................                   if(OutputType.B2 == 1) output_bit(Pbuzzer,1);     //Buzzer
04996:  BTFSS  x7D.1
04998:  BRA    49A0
0499A:  BSF    F89.4
0499C:  BCF    F92.4
0499E:  BRA    49A4
....................                   else output_bit(Pbell,1);                          //Bell
049A0:  BSF    F89.3
049A2:  BCF    F92.3
....................                }
....................             }
....................             // SMS Sending   
....................             if((SendSMS.B2 ==0)&& (functointest_f ==0) && (Ack.B2 ==0))
049A4:  BTFSC  x91.1
049A6:  BRA    49DE
049A8:  BTFSC  32.1
049AA:  BRA    49DE
049AC:  BTFSC  x83.1
049AE:  BRA    49DE
....................             {                
....................                SendSMS.B2 =1;
049B0:  BSF    x91.1
....................                strcat(SMS_MassageSUM, SMS_Massage2);
049B2:  MOVLW  06
049B4:  MOVWF  xD0
049B6:  MOVLW  D1
049B8:  MOVWF  xCF
049BA:  MOVLW  05
049BC:  MOVWF  xD2
049BE:  MOVLW  B1
049C0:  MOVWF  xD1
049C2:  MOVLB  0
049C4:  RCALL  430C
....................                strcat(SMS_MassageSUM, spacestring);
049C6:  MOVLW  06
049C8:  MOVLB  7
049CA:  MOVWF  xD0
049CC:  MOVLW  D1
049CE:  MOVWF  xCF
049D0:  MOVLW  07
049D2:  MOVWF  xD2
049D4:  MOVLW  71
049D6:  MOVWF  xD1
049D8:  MOVLB  0
049DA:  RCALL  430C
049DC:  MOVLB  7
....................             /*
....................                fprintf(CH2,"AT+CMGF=1"); 
....................                putc('\n',CH2);
....................                delay_ms(10);
.................... 
....................                fprintf(CH2,"AT+CMGS=\"");
....................                fprintf(CH2,sms_phonenumber);
....................                
....................                fprintf(CH2,"\"");
....................                putc('\n',CH2);
....................                delay_ms(50);
....................                
....................               fprintf(CH2,SMS_Massage2);
....................               putc('\n',CH2);
....................              putc(26,CH2);
....................               */
....................             } 
....................           }
.................... 
....................       }
049DE:  BRA    49E6
....................       else if(FaultType.B2 == 1) Ack.B2 = 0;
049E0:  BTFSS  x7B.1
049E2:  BRA    49E6
049E4:  BCF    x83.1
....................    }
049E6:  BRA    4A40
....................    else  //Indicator Function
....................    {
....................       if((Inputt.B2 ^ InputType.B2) == 1)
049E8:  MOVLW  00
049EA:  BTFSC  x75.1
049EC:  MOVLW  01
049EE:  MOVWF  xD0
049F0:  MOVLW  00
049F2:  BTFSC  x79.1
049F4:  MOVLW  01
049F6:  XORWF  xD0,W
049F8:  SUBLW  01
049FA:  BNZ   4A3A
....................       {
....................          Output.B2 = 0;
049FC:  BCF    x77.1
....................          // SMS Sending   
....................             if((SendSMS.B2 ==0)&& (functointest_f ==0) && (Ack.B2 ==0))
049FE:  BTFSC  x91.1
04A00:  BRA    4A38
04A02:  BTFSC  32.1
04A04:  BRA    4A38
04A06:  BTFSC  x83.1
04A08:  BRA    4A38
....................             {                
....................                SendSMS.B2 =1;
04A0A:  BSF    x91.1
....................                strcat(SMS_MassageSUM, SMS_Massage2);
04A0C:  MOVLW  06
04A0E:  MOVWF  xD0
04A10:  MOVLW  D1
04A12:  MOVWF  xCF
04A14:  MOVLW  05
04A16:  MOVWF  xD2
04A18:  MOVLW  B1
04A1A:  MOVWF  xD1
04A1C:  MOVLB  0
04A1E:  RCALL  430C
....................                strcat(SMS_MassageSUM, spacestring);
04A20:  MOVLW  06
04A22:  MOVLB  7
04A24:  MOVWF  xD0
04A26:  MOVLW  D1
04A28:  MOVWF  xCF
04A2A:  MOVLW  07
04A2C:  MOVWF  xD2
04A2E:  MOVLW  71
04A30:  MOVWF  xD1
04A32:  MOVLB  0
04A34:  RCALL  430C
04A36:  MOVLB  7
....................             /*
....................                fprintf(CH2,"AT+CMGF=1"); 
....................                putc('\n',CH2);
....................                delay_ms(10);
.................... 
....................                fprintf(CH2,"AT+CMGS=\"");
....................                fprintf(CH2,sms_phonenumber);
....................                
....................                fprintf(CH2,"\"");
....................                putc('\n',CH2);
....................                delay_ms(50);
....................                
....................               fprintf(CH2,SMS_Massage2);
....................               putc('\n',CH2);
....................              putc(26,CH2);
....................               */
....................             } 
....................       }
04A38:  BRA    4A40
....................       else
....................       {
....................          Output.B2 = 1;
04A3A:  BSF    x77.1
....................          SendSMS.B2 =0;
04A3C:  BCF    x91.1
....................          functointest_f =0;
04A3E:  BCF    32.1
....................       }
....................    }
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //input3
....................    if(AlarmIndicator.B3 == 1)    // Alarm Function
04A40:  BTFSS  x81.2
04A42:  BRA    4AF0
....................    {
....................       if((((Inputt.B3 ^ InputType.B3) == 1) && (FaultType.B3 == 1))|| In.B3 == 1)    // alarm1 occure and "Lock type"
04A44:  MOVLW  00
04A46:  BTFSC  x75.2
04A48:  MOVLW  01
04A4A:  MOVWF  xD0
04A4C:  MOVLW  00
04A4E:  BTFSC  x79.2
04A50:  MOVLW  01
04A52:  XORWF  xD0,W
04A54:  SUBLW  01
04A56:  BNZ   4A5C
04A58:  BTFSC  x7B.2
04A5A:  BRA    4A60
04A5C:  BTFSS  x85.2
04A5E:  BRA    4AE8
....................       //if(Inputt.B3 == 0)
....................       {
....................          if(Ack.B3 == 0)
04A60:  BTFSC  x83.2
04A62:  BRA    4AE6
....................          {
....................             if(In.B3 == 0 && AutoAck == 0x0F)   //use auto acknowlegde
04A64:  BTFSC  x85.2
04A66:  BRA    4A80
04A68:  MOVLB  0
04A6A:  MOVF   x60,W
04A6C:  SUBLW  0F
04A6E:  BTFSC  FD8.2
04A70:  BRA    4A76
04A72:  MOVLB  7
04A74:  BRA    4A80
....................             {
....................                TimeBase1s = 100 ;            //reload again
04A76:  MOVLW  64
04A78:  MOVWF  1E
....................                AutoAckDelayTime = AutoAckTime ;
04A7A:  MOVFF  61,1F
04A7E:  MOVLB  7
....................             }
.................... 
....................             In.B3 = 1;                                 // setbit in1
04A80:  BSF    x85.2
....................             if(FlashingFlag == 0)
04A82:  BTFSC  1C.1
04A84:  BRA    4A8A
....................             {
....................                Output.B3 = 0;           //Flash output1
04A86:  BCF    x77.2
....................             }
04A88:  BRA    4A8C
....................             else
....................             {
....................                Output.B3 = 1;
04A8A:  BSF    x77.2
....................             }
.................... 
....................             if (~AutoTestFlag)
04A8C:  BTFSC  1C.4
04A8E:  BRA    4AAC
....................             {
....................                if(OutputBoth.B3 == 0)                  //Both output
04A90:  BTFSC  x7F.2
04A92:  BRA    4A9E
....................                {
....................                   output_bit(Pbuzzer,1);   //Buzzer
04A94:  BSF    F89.4
04A96:  BCF    F92.4
....................                   output_bit(Pbell,1);     //Bell
04A98:  BSF    F89.3
04A9A:  BCF    F92.3
....................                }
04A9C:  BRA    4AAC
....................                else
....................                {
....................                   if(OutputType.B3 == 1) output_bit(Pbuzzer,1);     //Buzzer
04A9E:  BTFSS  x7D.2
04AA0:  BRA    4AA8
04AA2:  BSF    F89.4
04AA4:  BCF    F92.4
04AA6:  BRA    4AAC
....................                   else output_bit(Pbell,1);                          //Bell
04AA8:  BSF    F89.3
04AAA:  BCF    F92.3
....................                }
....................             }
....................             // SMS Sending   
....................             if((SendSMS.B3 ==0)&& (functointest_f ==0) && (Ack.B3 ==0))
04AAC:  BTFSC  x91.2
04AAE:  BRA    4AE6
04AB0:  BTFSC  32.1
04AB2:  BRA    4AE6
04AB4:  BTFSC  x83.2
04AB6:  BRA    4AE6
....................             {               
....................                SendSMS.B3 =1;
04AB8:  BSF    x91.2
....................                strcat(SMS_MassageSUM, SMS_Massage3);
04ABA:  MOVLW  06
04ABC:  MOVWF  xD0
04ABE:  MOVLW  D1
04AC0:  MOVWF  xCF
04AC2:  MOVLW  05
04AC4:  MOVWF  xD2
04AC6:  MOVLW  D1
04AC8:  MOVWF  xD1
04ACA:  MOVLB  0
04ACC:  RCALL  430C
....................                strcat(SMS_MassageSUM, spacestring);
04ACE:  MOVLW  06
04AD0:  MOVLB  7
04AD2:  MOVWF  xD0
04AD4:  MOVLW  D1
04AD6:  MOVWF  xCF
04AD8:  MOVLW  07
04ADA:  MOVWF  xD2
04ADC:  MOVLW  71
04ADE:  MOVWF  xD1
04AE0:  MOVLB  0
04AE2:  RCALL  430C
04AE4:  MOVLB  7
....................             /*
....................                fprintf(CH2,"AT+CMGF=1"); 
....................                putc('\n',CH2);
....................                delay_ms(10);
.................... 
....................                fprintf(CH2,"AT+CMGS=\"");
....................                fprintf(CH2,sms_phonenumber);
....................                
....................                fprintf(CH2,"\"");
....................                putc('\n',CH2);
....................                delay_ms(50);
....................               
....................               fprintf(CH2,SMS_Massage3);
....................               putc('\n',CH2);
....................              putc(26,CH2);
....................               */
....................             }
....................             
....................             
....................           }
.................... 
....................       }
04AE6:  BRA    4AEE
....................       else if(FaultType.B3 == 1) Ack.B3 = 0;
04AE8:  BTFSS  x7B.2
04AEA:  BRA    4AEE
04AEC:  BCF    x83.2
....................    }
04AEE:  BRA    4B4C
....................    else  //Indicator Function
....................    {
....................       if((Inputt.B3 ^ InputType.B3) == 1)
04AF0:  MOVLW  00
04AF2:  BTFSC  x75.2
04AF4:  MOVLW  01
04AF6:  MOVWF  xD0
04AF8:  MOVLW  00
04AFA:  BTFSC  x79.2
04AFC:  MOVLW  01
04AFE:  XORWF  xD0,W
04B00:  SUBLW  01
04B02:  BNZ   4B46
....................       {
....................          Output.B3 = 0;
04B04:  BCF    x77.2
....................          // SMS Sending   
....................             if((SendSMS.B3 ==0)&& (functointest_f ==0) && (Ack.B3 ==0))
04B06:  BTFSC  x91.2
04B08:  BRA    4B44
04B0A:  BTFSC  32.1
04B0C:  BRA    4B44
04B0E:  BTFSC  x83.2
04B10:  BRA    4B44
....................             {               
....................                SendSMS.B3 =1;
04B12:  BSF    x91.2
....................                strcat(SMS_MassageSUM, SMS_Massage3);
04B14:  MOVLW  06
04B16:  MOVWF  xD0
04B18:  MOVLW  D1
04B1A:  MOVWF  xCF
04B1C:  MOVLW  05
04B1E:  MOVWF  xD2
04B20:  MOVLW  D1
04B22:  MOVWF  xD1
04B24:  MOVLB  0
04B26:  CALL   430C
....................                strcat(SMS_MassageSUM, spacestring);
04B2A:  MOVLW  06
04B2C:  MOVLB  7
04B2E:  MOVWF  xD0
04B30:  MOVLW  D1
04B32:  MOVWF  xCF
04B34:  MOVLW  07
04B36:  MOVWF  xD2
04B38:  MOVLW  71
04B3A:  MOVWF  xD1
04B3C:  MOVLB  0
04B3E:  CALL   430C
04B42:  MOVLB  7
....................             /*
....................                fprintf(CH2,"AT+CMGF=1"); 
....................                putc('\n',CH2);
....................                delay_ms(10);
.................... 
....................                fprintf(CH2,"AT+CMGS=\"");
....................                fprintf(CH2,sms_phonenumber);
....................                
....................                fprintf(CH2,"\"");
....................                putc('\n',CH2);
....................                delay_ms(50);
....................               
....................               fprintf(CH2,SMS_Massage3);
....................               putc('\n',CH2);
....................              putc(26,CH2);
....................               */
....................             }
....................       }
04B44:  BRA    4B4C
....................       else
....................       {
....................          Output.B3 = 1;
04B46:  BSF    x77.2
....................          SendSMS.B3 =0;
04B48:  BCF    x91.2
....................          functointest_f =0;
04B4A:  BCF    32.1
....................       }
....................    }
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //input4
....................    if(AlarmIndicator.B4 == 1)    // Alarm Function
04B4C:  BTFSS  x81.3
04B4E:  BRA    4C00
....................    {
....................       if((((Inputt.B4 ^ InputType.B4) == 1) && (FaultType.B4 == 1))|| In.B4 == 1)    // alarm1 occure and "Lock type"
04B50:  MOVLW  00
04B52:  BTFSC  x75.3
04B54:  MOVLW  01
04B56:  MOVWF  xD0
04B58:  MOVLW  00
04B5A:  BTFSC  x79.3
04B5C:  MOVLW  01
04B5E:  XORWF  xD0,W
04B60:  SUBLW  01
04B62:  BNZ   4B68
04B64:  BTFSC  x7B.3
04B66:  BRA    4B6C
04B68:  BTFSS  x85.3
04B6A:  BRA    4BF8
....................       //if(Inputt.B4 == 0)
....................       {
....................          if(Ack.B4 == 0)
04B6C:  BTFSC  x83.3
04B6E:  BRA    4BF6
....................          {
....................             if(In.B4 == 0 && AutoAck == 0x0F)   //use auto acknowlegde
04B70:  BTFSC  x85.3
04B72:  BRA    4B8C
04B74:  MOVLB  0
04B76:  MOVF   x60,W
04B78:  SUBLW  0F
04B7A:  BTFSC  FD8.2
04B7C:  BRA    4B82
04B7E:  MOVLB  7
04B80:  BRA    4B8C
....................             {
....................                TimeBase1s = 100 ;            //reload again
04B82:  MOVLW  64
04B84:  MOVWF  1E
....................                AutoAckDelayTime = AutoAckTime ;
04B86:  MOVFF  61,1F
04B8A:  MOVLB  7
....................             }
.................... 
....................             In.B4 = 1;                                 // setbit in1
04B8C:  BSF    x85.3
....................             if(FlashingFlag == 0)
04B8E:  BTFSC  1C.1
04B90:  BRA    4B96
....................             {
....................                Output.B4 = 0;           //Flash output1
04B92:  BCF    x77.3
....................             }
04B94:  BRA    4B98
....................             else
....................             {
....................                Output.B4 = 1;
04B96:  BSF    x77.3
....................             }
.................... 
....................             if (~AutoTestFlag)
04B98:  BTFSC  1C.4
04B9A:  BRA    4BB8
....................             {
....................                if(OutputBoth.B4 == 0)                  //Both output
04B9C:  BTFSC  x7F.3
04B9E:  BRA    4BAA
....................                {
....................                   output_bit(Pbuzzer,1);   //Buzzer
04BA0:  BSF    F89.4
04BA2:  BCF    F92.4
....................                   output_bit(Pbell,1);     //Bell
04BA4:  BSF    F89.3
04BA6:  BCF    F92.3
....................                }
04BA8:  BRA    4BB8
....................                else
....................                {
....................                   if(OutputType.B4 == 1) output_bit(Pbuzzer,1);     //Buzzer
04BAA:  BTFSS  x7D.3
04BAC:  BRA    4BB4
04BAE:  BSF    F89.4
04BB0:  BCF    F92.4
04BB2:  BRA    4BB8
....................                   else output_bit(Pbell,1);                          //Bell
04BB4:  BSF    F89.3
04BB6:  BCF    F92.3
....................                }
....................             }
....................             // SMS Sending   
....................             if((SendSMS.B4 ==0)&& (functointest_f ==0) && (Ack.B4 ==0))
04BB8:  BTFSC  x91.3
04BBA:  BRA    4BF6
04BBC:  BTFSC  32.1
04BBE:  BRA    4BF6
04BC0:  BTFSC  x83.3
04BC2:  BRA    4BF6
....................             {               
....................                SendSMS.B4 =1;
04BC4:  BSF    x91.3
....................                strcat(SMS_MassageSUM, SMS_Massage4);
04BC6:  MOVLW  06
04BC8:  MOVWF  xD0
04BCA:  MOVLW  D1
04BCC:  MOVWF  xCF
04BCE:  MOVLW  05
04BD0:  MOVWF  xD2
04BD2:  MOVLW  F1
04BD4:  MOVWF  xD1
04BD6:  MOVLB  0
04BD8:  CALL   430C
....................                strcat(SMS_MassageSUM, spacestring);
04BDC:  MOVLW  06
04BDE:  MOVLB  7
04BE0:  MOVWF  xD0
04BE2:  MOVLW  D1
04BE4:  MOVWF  xCF
04BE6:  MOVLW  07
04BE8:  MOVWF  xD2
04BEA:  MOVLW  71
04BEC:  MOVWF  xD1
04BEE:  MOVLB  0
04BF0:  CALL   430C
04BF4:  MOVLB  7
....................             /*
....................                fprintf(CH2,"AT+CMGF=1"); 
....................                putc('\n',CH2);
....................                delay_ms(10);
.................... 
....................                fprintf(CH2,"AT+CMGS=\"");
....................                fprintf(CH2,sms_phonenumber);
....................             
....................                fprintf(CH2,"\"");
....................                putc('\n',CH2);
....................                delay_ms(50);
....................               
....................               fprintf(CH2,SMS_Massage4);
....................               putc('\n',CH2);
....................              putc(26,CH2);
....................               */
....................             }
....................           }
.................... 
....................       }
04BF6:  BRA    4BFE
....................       else if(FaultType.B4 == 1) Ack.B4 = 0;
04BF8:  BTFSS  x7B.3
04BFA:  BRA    4BFE
04BFC:  BCF    x83.3
....................    }
04BFE:  BRA    4C5C
....................    else  //Indicator Function
....................    {
....................       if((Inputt.B4 ^ InputType.B4) == 1)
04C00:  MOVLW  00
04C02:  BTFSC  x75.3
04C04:  MOVLW  01
04C06:  MOVWF  xD0
04C08:  MOVLW  00
04C0A:  BTFSC  x79.3
04C0C:  MOVLW  01
04C0E:  XORWF  xD0,W
04C10:  SUBLW  01
04C12:  BNZ   4C56
....................       {
....................          Output.B4 = 0;
04C14:  BCF    x77.3
....................          // SMS Sending   
....................             if((SendSMS.B4 ==0)&& (functointest_f ==0) && (Ack.B4 ==0))
04C16:  BTFSC  x91.3
04C18:  BRA    4C54
04C1A:  BTFSC  32.1
04C1C:  BRA    4C54
04C1E:  BTFSC  x83.3
04C20:  BRA    4C54
....................             {               
....................                SendSMS.B4 =1;
04C22:  BSF    x91.3
....................                strcat(SMS_MassageSUM, SMS_Massage4);
04C24:  MOVLW  06
04C26:  MOVWF  xD0
04C28:  MOVLW  D1
04C2A:  MOVWF  xCF
04C2C:  MOVLW  05
04C2E:  MOVWF  xD2
04C30:  MOVLW  F1
04C32:  MOVWF  xD1
04C34:  MOVLB  0
04C36:  CALL   430C
....................                strcat(SMS_MassageSUM, spacestring);
04C3A:  MOVLW  06
04C3C:  MOVLB  7
04C3E:  MOVWF  xD0
04C40:  MOVLW  D1
04C42:  MOVWF  xCF
04C44:  MOVLW  07
04C46:  MOVWF  xD2
04C48:  MOVLW  71
04C4A:  MOVWF  xD1
04C4C:  MOVLB  0
04C4E:  CALL   430C
04C52:  MOVLB  7
....................             /*
....................                fprintf(CH2,"AT+CMGF=1"); 
....................                putc('\n',CH2);
....................                delay_ms(10);
.................... 
....................                fprintf(CH2,"AT+CMGS=\"");
....................                fprintf(CH2,sms_phonenumber);
....................             
....................                fprintf(CH2,"\"");
....................                putc('\n',CH2);
....................                delay_ms(50);
....................               
....................               fprintf(CH2,SMS_Massage4);
....................               putc('\n',CH2);
....................              putc(26,CH2);
....................               */
....................             }
....................       }
04C54:  BRA    4C5C
....................       else
....................       {
....................          Output.B4 = 1;
04C56:  BSF    x77.3
....................          SendSMS.B4 =0;
04C58:  BCF    x91.3
....................          functointest_f =0;
04C5A:  BCF    32.1
....................       }
....................    }
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //input5
....................    if(AlarmIndicator.B5 == 1)    // Alarm Function
04C5C:  BTFSS  x81.4
04C5E:  BRA    4D10
....................    {
....................       if((((Inputt.B5 ^ InputType.B5) == 1) && (FaultType.B5 == 1))|| In.B5 == 1)    // alarm1 occure and "Lock type"
04C60:  MOVLW  00
04C62:  BTFSC  x75.4
04C64:  MOVLW  01
04C66:  MOVWF  xD0
04C68:  MOVLW  00
04C6A:  BTFSC  x79.4
04C6C:  MOVLW  01
04C6E:  XORWF  xD0,W
04C70:  SUBLW  01
04C72:  BNZ   4C78
04C74:  BTFSC  x7B.4
04C76:  BRA    4C7C
04C78:  BTFSS  x85.4
04C7A:  BRA    4D08
....................       //if(Inputt.B5 == 0)
....................       {
....................          if(Ack.B5 == 0)
04C7C:  BTFSC  x83.4
04C7E:  BRA    4D06
....................          {
....................             if(In.B5 == 0 && AutoAck == 0x0F)   //use auto acknowlegde
04C80:  BTFSC  x85.4
04C82:  BRA    4C9C
04C84:  MOVLB  0
04C86:  MOVF   x60,W
04C88:  SUBLW  0F
04C8A:  BTFSC  FD8.2
04C8C:  BRA    4C92
04C8E:  MOVLB  7
04C90:  BRA    4C9C
....................             {
....................                TimeBase1s = 100 ;            //reload again
04C92:  MOVLW  64
04C94:  MOVWF  1E
....................                AutoAckDelayTime = AutoAckTime ;
04C96:  MOVFF  61,1F
04C9A:  MOVLB  7
....................             }
.................... 
....................             In.B5 = 1;                                 // setbit in1
04C9C:  BSF    x85.4
....................             if(FlashingFlag == 0)
04C9E:  BTFSC  1C.1
04CA0:  BRA    4CA6
....................             {
....................                Output.B5 = 0;           //Flash output1
04CA2:  BCF    x77.4
....................             }
04CA4:  BRA    4CA8
....................             else
....................             {
....................                Output.B5 = 1;
04CA6:  BSF    x77.4
....................             }
.................... 
....................             if (~AutoTestFlag)
04CA8:  BTFSC  1C.4
04CAA:  BRA    4CC8
....................             {
....................                if(OutputBoth.B5 == 0)                  //Both output
04CAC:  BTFSC  x7F.4
04CAE:  BRA    4CBA
....................                {
....................                   output_bit(Pbuzzer,1);   //Buzzer
04CB0:  BSF    F89.4
04CB2:  BCF    F92.4
....................                   output_bit(Pbell,1);     //Bell
04CB4:  BSF    F89.3
04CB6:  BCF    F92.3
....................                }
04CB8:  BRA    4CC8
....................                else
....................                {
....................                   if(OutputType.B5 == 1) output_bit(Pbuzzer,1);     //Buzzer
04CBA:  BTFSS  x7D.4
04CBC:  BRA    4CC4
04CBE:  BSF    F89.4
04CC0:  BCF    F92.4
04CC2:  BRA    4CC8
....................                   else output_bit(Pbell,1);                          //Bell
04CC4:  BSF    F89.3
04CC6:  BCF    F92.3
....................                }
....................             }
....................             // SMS Sending   
....................             if((SendSMS.B5 ==0)&& (functointest_f ==0) && (Ack.B5 ==0))
04CC8:  BTFSC  x91.4
04CCA:  BRA    4D06
04CCC:  BTFSC  32.1
04CCE:  BRA    4D06
04CD0:  BTFSC  x83.4
04CD2:  BRA    4D06
....................             {               
....................                SendSMS.B5 =1;
04CD4:  BSF    x91.4
....................                strcat(SMS_MassageSUM, SMS_Massage5);
04CD6:  MOVLW  06
04CD8:  MOVWF  xD0
04CDA:  MOVLW  D1
04CDC:  MOVWF  xCF
04CDE:  MOVLW  06
04CE0:  MOVWF  xD2
04CE2:  MOVLW  11
04CE4:  MOVWF  xD1
04CE6:  MOVLB  0
04CE8:  CALL   430C
....................                strcat(SMS_MassageSUM, spacestring);
04CEC:  MOVLW  06
04CEE:  MOVLB  7
04CF0:  MOVWF  xD0
04CF2:  MOVLW  D1
04CF4:  MOVWF  xCF
04CF6:  MOVLW  07
04CF8:  MOVWF  xD2
04CFA:  MOVLW  71
04CFC:  MOVWF  xD1
04CFE:  MOVLB  0
04D00:  CALL   430C
04D04:  MOVLB  7
....................             /*
....................                fprintf(CH2,"AT+CMGF=1"); 
....................                putc('\n',CH2);
....................                delay_ms(10);
.................... 
....................                fprintf(CH2,"AT+CMGS=\"");
....................                fprintf(CH2,sms_phonenumber);
....................                
....................                fprintf(CH2,"\"");
....................                putc('\n',CH2);
....................                delay_ms(50);
....................               
....................               fprintf(CH2,SMS_Massage5);
....................               putc('\n',CH2);
....................              putc(26,CH2);
....................               */
....................             }
....................           }
.................... 
....................       }
04D06:  BRA    4D0E
....................       else if(FaultType.B5 == 1) Ack.B5 = 0;
04D08:  BTFSS  x7B.4
04D0A:  BRA    4D0E
04D0C:  BCF    x83.4
....................    }
04D0E:  BRA    4D6C
....................    else  //Indicator Function
....................    {
....................       if((Inputt.B5 ^ InputType.B5) == 1)
04D10:  MOVLW  00
04D12:  BTFSC  x75.4
04D14:  MOVLW  01
04D16:  MOVWF  xD0
04D18:  MOVLW  00
04D1A:  BTFSC  x79.4
04D1C:  MOVLW  01
04D1E:  XORWF  xD0,W
04D20:  SUBLW  01
04D22:  BNZ   4D66
....................       {
....................          Output.B5 = 0;
04D24:  BCF    x77.4
....................          // SMS Sending   
....................             if((SendSMS.B5 ==0)&& (functointest_f ==0) && (Ack.B5 ==0))
04D26:  BTFSC  x91.4
04D28:  BRA    4D64
04D2A:  BTFSC  32.1
04D2C:  BRA    4D64
04D2E:  BTFSC  x83.4
04D30:  BRA    4D64
....................             {               
....................                SendSMS.B5 =1;
04D32:  BSF    x91.4
....................                strcat(SMS_MassageSUM, SMS_Massage5);
04D34:  MOVLW  06
04D36:  MOVWF  xD0
04D38:  MOVLW  D1
04D3A:  MOVWF  xCF
04D3C:  MOVLW  06
04D3E:  MOVWF  xD2
04D40:  MOVLW  11
04D42:  MOVWF  xD1
04D44:  MOVLB  0
04D46:  CALL   430C
....................                strcat(SMS_MassageSUM, spacestring);
04D4A:  MOVLW  06
04D4C:  MOVLB  7
04D4E:  MOVWF  xD0
04D50:  MOVLW  D1
04D52:  MOVWF  xCF
04D54:  MOVLW  07
04D56:  MOVWF  xD2
04D58:  MOVLW  71
04D5A:  MOVWF  xD1
04D5C:  MOVLB  0
04D5E:  CALL   430C
04D62:  MOVLB  7
....................             /*
....................                fprintf(CH2,"AT+CMGF=1"); 
....................                putc('\n',CH2);
....................                delay_ms(10);
.................... 
....................                fprintf(CH2,"AT+CMGS=\"");
....................                fprintf(CH2,sms_phonenumber);
....................                
....................                fprintf(CH2,"\"");
....................                putc('\n',CH2);
....................                delay_ms(50);
....................               
....................               fprintf(CH2,SMS_Massage5);
....................               putc('\n',CH2);
....................              putc(26,CH2);
....................               */
....................             }
....................       }
04D64:  BRA    4D6C
....................       else
....................       {
....................          Output.B5 = 1;
04D66:  BSF    x77.4
....................          SendSMS.B5 =0;
04D68:  BCF    x91.4
....................          functointest_f =0;
04D6A:  BCF    32.1
....................       }
....................    }
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //input6
....................    if(AlarmIndicator.B6 == 1)    // Alarm Function
04D6C:  BTFSS  x81.5
04D6E:  BRA    4E20
....................    {
....................       if((((Inputt.B6 ^ InputType.B6) == 1) && (FaultType.B6 == 1))|| In.B6 == 1)    // alarm1 occure and "Lock type"
04D70:  MOVLW  00
04D72:  BTFSC  x75.5
04D74:  MOVLW  01
04D76:  MOVWF  xD0
04D78:  MOVLW  00
04D7A:  BTFSC  x79.5
04D7C:  MOVLW  01
04D7E:  XORWF  xD0,W
04D80:  SUBLW  01
04D82:  BNZ   4D88
04D84:  BTFSC  x7B.5
04D86:  BRA    4D8C
04D88:  BTFSS  x85.5
04D8A:  BRA    4E18
....................       //if(Inputt.B6 == 0)
....................       {
....................          if(Ack.B6 == 0)
04D8C:  BTFSC  x83.5
04D8E:  BRA    4E16
....................          {
....................             if(In.B6 == 0 && AutoAck == 0x0F)   //use auto acknowlegde
04D90:  BTFSC  x85.5
04D92:  BRA    4DAC
04D94:  MOVLB  0
04D96:  MOVF   x60,W
04D98:  SUBLW  0F
04D9A:  BTFSC  FD8.2
04D9C:  BRA    4DA2
04D9E:  MOVLB  7
04DA0:  BRA    4DAC
....................             {
....................                TimeBase1s = 100 ;            //reload again
04DA2:  MOVLW  64
04DA4:  MOVWF  1E
....................                AutoAckDelayTime = AutoAckTime ;
04DA6:  MOVFF  61,1F
04DAA:  MOVLB  7
....................             }
.................... 
....................             In.B6 = 1;                                 // setbit in1
04DAC:  BSF    x85.5
....................             if(FlashingFlag == 0)
04DAE:  BTFSC  1C.1
04DB0:  BRA    4DB6
....................             {
....................                Output.B6 = 0;           //Flash output1
04DB2:  BCF    x77.5
....................             }
04DB4:  BRA    4DB8
....................             else
....................             {
....................                Output.B6 = 1;
04DB6:  BSF    x77.5
....................             }
.................... 
....................             if (~AutoTestFlag)
04DB8:  BTFSC  1C.4
04DBA:  BRA    4DD8
....................             {
....................                if(OutputBoth.B6 == 0)                  //Both output
04DBC:  BTFSC  x7F.5
04DBE:  BRA    4DCA
....................                {
....................                   output_bit(Pbuzzer,1);   //Buzzer
04DC0:  BSF    F89.4
04DC2:  BCF    F92.4
....................                   output_bit(Pbell,1);     //Bell
04DC4:  BSF    F89.3
04DC6:  BCF    F92.3
....................                }
04DC8:  BRA    4DD8
....................                else
....................                {
....................                   if(OutputType.B6 == 1) output_bit(Pbuzzer,1);     //Buzzer
04DCA:  BTFSS  x7D.5
04DCC:  BRA    4DD4
04DCE:  BSF    F89.4
04DD0:  BCF    F92.4
04DD2:  BRA    4DD8
....................                   else output_bit(Pbell,1);                          //Bell
04DD4:  BSF    F89.3
04DD6:  BCF    F92.3
....................                }
....................             }
....................             // SMS Sending   
....................             if((SendSMS.B6 ==0)&& (functointest_f ==0) && (Ack.B6 ==0))
04DD8:  BTFSC  x91.5
04DDA:  BRA    4E16
04DDC:  BTFSC  32.1
04DDE:  BRA    4E16
04DE0:  BTFSC  x83.5
04DE2:  BRA    4E16
....................             {               
....................                SendSMS.B6 =1;
04DE4:  BSF    x91.5
....................                strcat(SMS_MassageSUM, SMS_Massage6);
04DE6:  MOVLW  06
04DE8:  MOVWF  xD0
04DEA:  MOVLW  D1
04DEC:  MOVWF  xCF
04DEE:  MOVLW  06
04DF0:  MOVWF  xD2
04DF2:  MOVLW  31
04DF4:  MOVWF  xD1
04DF6:  MOVLB  0
04DF8:  CALL   430C
....................                strcat(SMS_MassageSUM, spacestring);
04DFC:  MOVLW  06
04DFE:  MOVLB  7
04E00:  MOVWF  xD0
04E02:  MOVLW  D1
04E04:  MOVWF  xCF
04E06:  MOVLW  07
04E08:  MOVWF  xD2
04E0A:  MOVLW  71
04E0C:  MOVWF  xD1
04E0E:  MOVLB  0
04E10:  CALL   430C
04E14:  MOVLB  7
....................             /*
....................                fprintf(CH2,"AT+CMGF=1"); 
....................                putc('\n',CH2);
....................                delay_ms(10);
.................... 
....................                fprintf(CH2,"AT+CMGS=\"");
....................                fprintf(CH2,sms_phonenumber);
....................                
....................                fprintf(CH2,"\"");
....................                putc('\n',CH2);
....................                delay_ms(50);
....................               
....................               fprintf(CH2,SMS_Massage6);
....................               putc('\n',CH2);
....................              putc(26,CH2);
....................               */
....................             }
....................           }
.................... 
....................       }
04E16:  BRA    4E1E
....................       else if(FaultType.B6 == 1) Ack.B6 = 0;
04E18:  BTFSS  x7B.5
04E1A:  BRA    4E1E
04E1C:  BCF    x83.5
....................    }
04E1E:  BRA    4E7C
....................    else  //Indicator Function
....................    {
....................       if((Inputt.B6 ^ InputType.B6) == 1)
04E20:  MOVLW  00
04E22:  BTFSC  x75.5
04E24:  MOVLW  01
04E26:  MOVWF  xD0
04E28:  MOVLW  00
04E2A:  BTFSC  x79.5
04E2C:  MOVLW  01
04E2E:  XORWF  xD0,W
04E30:  SUBLW  01
04E32:  BNZ   4E76
....................       {
....................          Output.B6 = 0;
04E34:  BCF    x77.5
....................          // SMS Sending   
....................             if((SendSMS.B6 ==0)&& (functointest_f ==0) && (Ack.B6 ==0))
04E36:  BTFSC  x91.5
04E38:  BRA    4E74
04E3A:  BTFSC  32.1
04E3C:  BRA    4E74
04E3E:  BTFSC  x83.5
04E40:  BRA    4E74
....................             {               
....................                SendSMS.B6 =1;
04E42:  BSF    x91.5
....................                strcat(SMS_MassageSUM, SMS_Massage6);
04E44:  MOVLW  06
04E46:  MOVWF  xD0
04E48:  MOVLW  D1
04E4A:  MOVWF  xCF
04E4C:  MOVLW  06
04E4E:  MOVWF  xD2
04E50:  MOVLW  31
04E52:  MOVWF  xD1
04E54:  MOVLB  0
04E56:  CALL   430C
....................                strcat(SMS_MassageSUM, spacestring);
04E5A:  MOVLW  06
04E5C:  MOVLB  7
04E5E:  MOVWF  xD0
04E60:  MOVLW  D1
04E62:  MOVWF  xCF
04E64:  MOVLW  07
04E66:  MOVWF  xD2
04E68:  MOVLW  71
04E6A:  MOVWF  xD1
04E6C:  MOVLB  0
04E6E:  CALL   430C
04E72:  MOVLB  7
....................             /*
....................                fprintf(CH2,"AT+CMGF=1"); 
....................                putc('\n',CH2);
....................                delay_ms(10);
.................... 
....................                fprintf(CH2,"AT+CMGS=\"");
....................                fprintf(CH2,sms_phonenumber);
....................                
....................                fprintf(CH2,"\"");
....................                putc('\n',CH2);
....................                delay_ms(50);
....................               
....................               fprintf(CH2,SMS_Massage6);
....................               putc('\n',CH2);
....................              putc(26,CH2);
....................               */
....................             }
....................       }
04E74:  BRA    4E7C
....................       else
....................       {
....................          Output.B6 = 1;
04E76:  BSF    x77.5
....................          SendSMS.B6 =0;
04E78:  BCF    x91.5
....................          functointest_f =0;
04E7A:  BCF    32.1
....................       }
....................    }
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //input7
....................    if(AlarmIndicator.B7 == 1)    // Alarm Function
04E7C:  BTFSS  x81.6
04E7E:  BRA    4F30
....................    {
....................       if((((Inputt.B7 ^ InputType.B7) == 1) && (FaultType.B7 == 1))|| In.B7 == 1)    // alarm1 occure and "Lock type"
04E80:  MOVLW  00
04E82:  BTFSC  x75.6
04E84:  MOVLW  01
04E86:  MOVWF  xD0
04E88:  MOVLW  00
04E8A:  BTFSC  x79.6
04E8C:  MOVLW  01
04E8E:  XORWF  xD0,W
04E90:  SUBLW  01
04E92:  BNZ   4E98
04E94:  BTFSC  x7B.6
04E96:  BRA    4E9C
04E98:  BTFSS  x85.6
04E9A:  BRA    4F28
....................       //if(Inputt.B7 == 0)
....................       {
....................          if(Ack.B7 == 0)
04E9C:  BTFSC  x83.6
04E9E:  BRA    4F26
....................          {
....................             if(In.B7 == 0 && AutoAck == 0x0F)   //use auto acknowlegde
04EA0:  BTFSC  x85.6
04EA2:  BRA    4EBC
04EA4:  MOVLB  0
04EA6:  MOVF   x60,W
04EA8:  SUBLW  0F
04EAA:  BTFSC  FD8.2
04EAC:  BRA    4EB2
04EAE:  MOVLB  7
04EB0:  BRA    4EBC
....................             {
....................                TimeBase1s = 100 ;            //reload again
04EB2:  MOVLW  64
04EB4:  MOVWF  1E
....................                AutoAckDelayTime = AutoAckTime ;
04EB6:  MOVFF  61,1F
04EBA:  MOVLB  7
....................             }
.................... 
....................             In.B7 = 1;                                 // setbit in1
04EBC:  BSF    x85.6
....................             if(FlashingFlag == 0)
04EBE:  BTFSC  1C.1
04EC0:  BRA    4EC6
....................             {
....................                Output.B7 = 0;           //Flash output1
04EC2:  BCF    x77.6
....................             }
04EC4:  BRA    4EC8
....................             else
....................             {
....................                Output.B7 = 1;
04EC6:  BSF    x77.6
....................             }
.................... 
....................             if (~AutoTestFlag)
04EC8:  BTFSC  1C.4
04ECA:  BRA    4EE8
....................             {
....................                if(OutputBoth.B7 == 0)                  //Both output
04ECC:  BTFSC  x7F.6
04ECE:  BRA    4EDA
....................                {
....................                   output_bit(Pbuzzer,1);   //Buzzer
04ED0:  BSF    F89.4
04ED2:  BCF    F92.4
....................                   output_bit(Pbell,1);     //Bell
04ED4:  BSF    F89.3
04ED6:  BCF    F92.3
....................                }
04ED8:  BRA    4EE8
....................                else
....................                {
....................                   if(OutputType.B7 == 1) output_bit(Pbuzzer,1);     //Buzzer
04EDA:  BTFSS  x7D.6
04EDC:  BRA    4EE4
04EDE:  BSF    F89.4
04EE0:  BCF    F92.4
04EE2:  BRA    4EE8
....................                   else output_bit(Pbell,1);                          //Bell
04EE4:  BSF    F89.3
04EE6:  BCF    F92.3
....................                }
....................             }
....................             // SMS Sending   
....................             if((SendSMS.B7 ==0)&& (functointest_f ==0) && (Ack.B7 ==0))
04EE8:  BTFSC  x91.6
04EEA:  BRA    4F26
04EEC:  BTFSC  32.1
04EEE:  BRA    4F26
04EF0:  BTFSC  x83.6
04EF2:  BRA    4F26
....................             {               
....................                SendSMS.B7 =1;
04EF4:  BSF    x91.6
....................                strcat(SMS_MassageSUM, SMS_Massage7);
04EF6:  MOVLW  06
04EF8:  MOVWF  xD0
04EFA:  MOVLW  D1
04EFC:  MOVWF  xCF
04EFE:  MOVLW  06
04F00:  MOVWF  xD2
04F02:  MOVLW  51
04F04:  MOVWF  xD1
04F06:  MOVLB  0
04F08:  CALL   430C
....................                strcat(SMS_MassageSUM, spacestring);
04F0C:  MOVLW  06
04F0E:  MOVLB  7
04F10:  MOVWF  xD0
04F12:  MOVLW  D1
04F14:  MOVWF  xCF
04F16:  MOVLW  07
04F18:  MOVWF  xD2
04F1A:  MOVLW  71
04F1C:  MOVWF  xD1
04F1E:  MOVLB  0
04F20:  CALL   430C
04F24:  MOVLB  7
....................             /*
....................                fprintf(CH2,"AT+CMGF=1"); 
....................                putc('\n',CH2);
....................                delay_ms(10);
.................... 
....................                fprintf(CH2,"AT+CMGS=\"");
....................                fprintf(CH2,sms_phonenumber);
....................                
....................                fprintf(CH2,"\"");
....................                putc('\n',CH2);
....................                delay_ms(50);
....................               
....................               fprintf(CH2,SMS_Massage7);  
....................               putc('\n',CH2);
....................              putc(26,CH2);
....................               */
....................             }
....................           }
.................... 
....................       }
04F26:  BRA    4F2E
....................       else if(FaultType.B7 == 1) Ack.B7 = 0;
04F28:  BTFSS  x7B.6
04F2A:  BRA    4F2E
04F2C:  BCF    x83.6
....................    }
04F2E:  BRA    4F8C
....................    else  //Indicator Function
....................    {
....................       if((Inputt.B7 ^ InputType.B7) == 1)
04F30:  MOVLW  00
04F32:  BTFSC  x75.6
04F34:  MOVLW  01
04F36:  MOVWF  xD0
04F38:  MOVLW  00
04F3A:  BTFSC  x79.6
04F3C:  MOVLW  01
04F3E:  XORWF  xD0,W
04F40:  SUBLW  01
04F42:  BNZ   4F86
....................       {
....................          Output.B7 = 0;
04F44:  BCF    x77.6
....................          // SMS Sending   
....................             if((SendSMS.B7 ==0)&& (functointest_f ==0) && (Ack.B7 ==0))
04F46:  BTFSC  x91.6
04F48:  BRA    4F84
04F4A:  BTFSC  32.1
04F4C:  BRA    4F84
04F4E:  BTFSC  x83.6
04F50:  BRA    4F84
....................             {               
....................                SendSMS.B7 =1;
04F52:  BSF    x91.6
....................                strcat(SMS_MassageSUM, SMS_Massage7);
04F54:  MOVLW  06
04F56:  MOVWF  xD0
04F58:  MOVLW  D1
04F5A:  MOVWF  xCF
04F5C:  MOVLW  06
04F5E:  MOVWF  xD2
04F60:  MOVLW  51
04F62:  MOVWF  xD1
04F64:  MOVLB  0
04F66:  CALL   430C
....................                strcat(SMS_MassageSUM, spacestring);
04F6A:  MOVLW  06
04F6C:  MOVLB  7
04F6E:  MOVWF  xD0
04F70:  MOVLW  D1
04F72:  MOVWF  xCF
04F74:  MOVLW  07
04F76:  MOVWF  xD2
04F78:  MOVLW  71
04F7A:  MOVWF  xD1
04F7C:  MOVLB  0
04F7E:  CALL   430C
04F82:  MOVLB  7
....................             /*
....................                fprintf(CH2,"AT+CMGF=1"); 
....................                putc('\n',CH2);
....................                delay_ms(10);
.................... 
....................                fprintf(CH2,"AT+CMGS=\"");
....................                fprintf(CH2,sms_phonenumber);
....................                
....................                fprintf(CH2,"\"");
....................                putc('\n',CH2);
....................                delay_ms(50);
....................               
....................               fprintf(CH2,SMS_Massage7);  
....................               putc('\n',CH2);
....................              putc(26,CH2);
....................               */
....................             }
....................       }
04F84:  BRA    4F8C
....................       else
....................       {
....................          Output.B7 = 1;
04F86:  BSF    x77.6
....................          SendSMS.B7 =0;
04F88:  BCF    x91.6
....................          functointest_f =0;
04F8A:  BCF    32.1
....................       }
....................    }
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //input8
....................    if(AlarmIndicator.B8 == 1)    // Alarm Function
04F8C:  BTFSS  x81.7
04F8E:  BRA    5040
....................    {
....................       if((((Inputt.B8 ^ InputType.B8) == 1) && (FaultType.B8 == 1))|| In.B8 == 1)    // alarm1 occure and "Lock type"
04F90:  MOVLW  00
04F92:  BTFSC  x75.7
04F94:  MOVLW  01
04F96:  MOVWF  xD0
04F98:  MOVLW  00
04F9A:  BTFSC  x79.7
04F9C:  MOVLW  01
04F9E:  XORWF  xD0,W
04FA0:  SUBLW  01
04FA2:  BNZ   4FA8
04FA4:  BTFSC  x7B.7
04FA6:  BRA    4FAC
04FA8:  BTFSS  x85.7
04FAA:  BRA    5038
....................       //if(Inputt.B8 == 0)
....................       {
....................          if(Ack.B8 == 0)
04FAC:  BTFSC  x83.7
04FAE:  BRA    5036
....................          {
....................             if(In.B8 == 0 && AutoAck == 0x0F)   //use auto acknowlegde
04FB0:  BTFSC  x85.7
04FB2:  BRA    4FCC
04FB4:  MOVLB  0
04FB6:  MOVF   x60,W
04FB8:  SUBLW  0F
04FBA:  BTFSC  FD8.2
04FBC:  BRA    4FC2
04FBE:  MOVLB  7
04FC0:  BRA    4FCC
....................             {
....................                TimeBase1s = 100 ;            //reload again
04FC2:  MOVLW  64
04FC4:  MOVWF  1E
....................                AutoAckDelayTime = AutoAckTime ;
04FC6:  MOVFF  61,1F
04FCA:  MOVLB  7
....................             }
.................... 
....................             In.B8 = 1;                                 // setbit in1
04FCC:  BSF    x85.7
....................             if(FlashingFlag == 0)
04FCE:  BTFSC  1C.1
04FD0:  BRA    4FD6
....................             {
....................                Output.B8 = 0;           //Flash output1
04FD2:  BCF    x77.7
....................             }
04FD4:  BRA    4FD8
....................             else
....................             {
....................                Output.B8 = 1;
04FD6:  BSF    x77.7
....................             }
.................... 
....................             if (~AutoTestFlag)
04FD8:  BTFSC  1C.4
04FDA:  BRA    4FF8
....................             {
....................                if(OutputBoth.B8 == 0)                  //Both output
04FDC:  BTFSC  x7F.7
04FDE:  BRA    4FEA
....................                {
....................                   output_bit(Pbuzzer,1);   //Buzzer
04FE0:  BSF    F89.4
04FE2:  BCF    F92.4
....................                   output_bit(Pbell,1);     //Bell
04FE4:  BSF    F89.3
04FE6:  BCF    F92.3
....................                }
04FE8:  BRA    4FF8
....................                else
....................                {
....................                   if(OutputType.B8 == 1) output_bit(Pbuzzer,1);     //Buzzer
04FEA:  BTFSS  x7D.7
04FEC:  BRA    4FF4
04FEE:  BSF    F89.4
04FF0:  BCF    F92.4
04FF2:  BRA    4FF8
....................                   else output_bit(Pbell,1);                          //Bell
04FF4:  BSF    F89.3
04FF6:  BCF    F92.3
....................                }
....................             }
....................             // SMS Sending   
....................          if((SendSMS.B8 ==0)&& (functointest_f ==0) && (Ack.B8 ==0))
04FF8:  BTFSC  x91.7
04FFA:  BRA    5036
04FFC:  BTFSC  32.1
04FFE:  BRA    5036
05000:  BTFSC  x83.7
05002:  BRA    5036
....................          {            
....................             SendSMS.B8 =1;
05004:  BSF    x91.7
....................                strcat(SMS_MassageSUM, SMS_Massage8);
05006:  MOVLW  06
05008:  MOVWF  xD0
0500A:  MOVLW  D1
0500C:  MOVWF  xCF
0500E:  MOVLW  06
05010:  MOVWF  xD2
05012:  MOVLW  71
05014:  MOVWF  xD1
05016:  MOVLB  0
05018:  CALL   430C
....................                strcat(SMS_MassageSUM, spacestring);
0501C:  MOVLW  06
0501E:  MOVLB  7
05020:  MOVWF  xD0
05022:  MOVLW  D1
05024:  MOVWF  xCF
05026:  MOVLW  07
05028:  MOVWF  xD2
0502A:  MOVLW  71
0502C:  MOVWF  xD1
0502E:  MOVLB  0
05030:  CALL   430C
05034:  MOVLB  7
....................             /*
....................             fprintf(CH2,"AT+CMGF=1"); 
....................             putc('\n',CH2);
....................             delay_ms(10);
.................... 
....................             fprintf(CH2,"AT+CMGS=\"");
....................             fprintf(CH2,sms_phonenumber);
....................             
....................             fprintf(CH2,"\"");
....................             putc('\n',CH2);
....................             delay_ms(50);
....................            
....................            printf(SMS_Massage8);  
....................            putc('\n',CH2);
....................           putc(26,CH2);
....................               */
....................          }
....................        }
.................... 
....................       }
05036:  BRA    503E
....................       else if(FaultType.B8 == 1) Ack.B8 = 0;
05038:  BTFSS  x7B.7
0503A:  BRA    503E
0503C:  BCF    x83.7
....................    }
0503E:  BRA    509C
....................    else  //Indicator Function
....................    {
....................       if((Inputt.B8 ^ InputType.B8) == 1)
05040:  MOVLW  00
05042:  BTFSC  x75.7
05044:  MOVLW  01
05046:  MOVWF  xD0
05048:  MOVLW  00
0504A:  BTFSC  x79.7
0504C:  MOVLW  01
0504E:  XORWF  xD0,W
05050:  SUBLW  01
05052:  BNZ   5096
....................       {
....................          Output.B8 = 0;
05054:  BCF    x77.7
....................          // SMS Sending   
....................          if((SendSMS.B8 ==0)&& (functointest_f ==0) && (Ack.B8 ==0))
05056:  BTFSC  x91.7
05058:  BRA    5094
0505A:  BTFSC  32.1
0505C:  BRA    5094
0505E:  BTFSC  x83.7
05060:  BRA    5094
....................          {            
....................             SendSMS.B8 =1;
05062:  BSF    x91.7
....................                strcat(SMS_MassageSUM, SMS_Massage8);
05064:  MOVLW  06
05066:  MOVWF  xD0
05068:  MOVLW  D1
0506A:  MOVWF  xCF
0506C:  MOVLW  06
0506E:  MOVWF  xD2
05070:  MOVLW  71
05072:  MOVWF  xD1
05074:  MOVLB  0
05076:  CALL   430C
....................                strcat(SMS_MassageSUM, spacestring);
0507A:  MOVLW  06
0507C:  MOVLB  7
0507E:  MOVWF  xD0
05080:  MOVLW  D1
05082:  MOVWF  xCF
05084:  MOVLW  07
05086:  MOVWF  xD2
05088:  MOVLW  71
0508A:  MOVWF  xD1
0508C:  MOVLB  0
0508E:  CALL   430C
05092:  MOVLB  7
....................             /*
....................             fprintf(CH2,"AT+CMGF=1"); 
....................             putc('\n',CH2);
....................             delay_ms(10);
.................... 
....................             fprintf(CH2,"AT+CMGS=\"");
....................             fprintf(CH2,sms_phonenumber);
....................             
....................             fprintf(CH2,"\"");
....................             putc('\n',CH2);
....................             delay_ms(50);
....................            
....................            printf(SMS_Massage8);  
....................            putc('\n',CH2);
....................           putc(26,CH2);
....................               */
....................          }
....................       }
05094:  BRA    509C
....................       else
....................       {
....................          Output.B8 = 1;
05096:  BSF    x77.7
....................          SendSMS.B8 =0;
05098:  BCF    x91.7
....................          functointest_f =0;
0509A:  BCF    32.1
....................       }
....................    }
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //input9
....................    if(AlarmIndicator.B9 == 1)    // Alarm Function
0509C:  BTFSS  x82.0
0509E:  BRA    5150
....................    {
....................       if((((Inputt.B9 ^ InputType.B9) == 1) && (FaultType.B9 == 1))|| In.B9 == 1)    // alarm1 occure and "Lock type"
050A0:  MOVLW  00
050A2:  BTFSC  x76.0
050A4:  MOVLW  01
050A6:  MOVWF  xD0
050A8:  MOVLW  00
050AA:  BTFSC  x7A.0
050AC:  MOVLW  01
050AE:  XORWF  xD0,W
050B0:  SUBLW  01
050B2:  BNZ   50B8
050B4:  BTFSC  x7C.0
050B6:  BRA    50BC
050B8:  BTFSS  x86.0
050BA:  BRA    5148
....................       //if(Inputt.B9 == 0)
....................       {
....................          if(Ack.B9 == 0)
050BC:  BTFSC  x84.0
050BE:  BRA    5146
....................          {
....................             if(In.B9 == 0 && AutoAck == 0x0F)   //use auto acknowlegde
050C0:  BTFSC  x86.0
050C2:  BRA    50DC
050C4:  MOVLB  0
050C6:  MOVF   x60,W
050C8:  SUBLW  0F
050CA:  BTFSC  FD8.2
050CC:  BRA    50D2
050CE:  MOVLB  7
050D0:  BRA    50DC
....................             {
....................                TimeBase1s = 100 ;            //reload again
050D2:  MOVLW  64
050D4:  MOVWF  1E
....................                AutoAckDelayTime = AutoAckTime ;
050D6:  MOVFF  61,1F
050DA:  MOVLB  7
....................             }
.................... 
....................             In.B9 = 1;                                 // setbit in1
050DC:  BSF    x86.0
....................             if(FlashingFlag == 0)
050DE:  BTFSC  1C.1
050E0:  BRA    50E6
....................             {
....................                Output.B9 = 0;           //Flash output1
050E2:  BCF    x78.0
....................             }
050E4:  BRA    50E8
....................             else
....................             {
....................                Output.B9 = 1;
050E6:  BSF    x78.0
....................             }
.................... 
....................             if (~AutoTestFlag)
050E8:  BTFSC  1C.4
050EA:  BRA    5108
....................             {
....................                if(OutputBoth.B9 == 0)                  //Both output
050EC:  BTFSC  x80.0
050EE:  BRA    50FA
....................                {
....................                   output_bit(Pbuzzer,1);   //Buzzer
050F0:  BSF    F89.4
050F2:  BCF    F92.4
....................                   output_bit(Pbell,1);     //Bell
050F4:  BSF    F89.3
050F6:  BCF    F92.3
....................                }
050F8:  BRA    5108
....................                else
....................                {
....................                   if(OutputType.B9 == 1) output_bit(Pbuzzer,1);     //Buzzer
050FA:  BTFSS  x7E.0
050FC:  BRA    5104
050FE:  BSF    F89.4
05100:  BCF    F92.4
05102:  BRA    5108
....................                   else output_bit(Pbell,1);                          //Bell
05104:  BSF    F89.3
05106:  BCF    F92.3
....................                }
....................             }
....................             // SMS Sending   
....................             if((SendSMS.B9 ==0)&& (functointest_f ==0) && (Ack.B9 ==0))
05108:  BTFSC  x92.0
0510A:  BRA    5146
0510C:  BTFSC  32.1
0510E:  BRA    5146
05110:  BTFSC  x84.0
05112:  BRA    5146
....................             {               
....................                SendSMS.B9 =1;
05114:  BSF    x92.0
....................                strcat(SMS_MassageSUM, SMS_Massage9);
05116:  MOVLW  06
05118:  MOVWF  xD0
0511A:  MOVLW  D1
0511C:  MOVWF  xCF
0511E:  MOVLW  06
05120:  MOVWF  xD2
05122:  MOVLW  91
05124:  MOVWF  xD1
05126:  MOVLB  0
05128:  CALL   430C
....................                strcat(SMS_MassageSUM, spacestring);
0512C:  MOVLW  06
0512E:  MOVLB  7
05130:  MOVWF  xD0
05132:  MOVLW  D1
05134:  MOVWF  xCF
05136:  MOVLW  07
05138:  MOVWF  xD2
0513A:  MOVLW  71
0513C:  MOVWF  xD1
0513E:  MOVLB  0
05140:  CALL   430C
05144:  MOVLB  7
....................             /*
....................                fprintf(CH2,"AT+CMGF=1"); 
....................                putc('\n',CH2);
....................                delay_ms(10);
.................... 
....................                fprintf(CH2,"AT+CMGS=\"");
....................                fprintf(CH2,sms_phonenumber);
....................                
....................                fprintf(CH2,"\"");
....................                putc('\n',CH2);
....................                delay_ms(50);
....................               
....................               printf(SMS_Massage9);  
....................               putc('\n',CH2);
....................               putc(26,CH2);
....................               */
....................             }
....................             ///////////////////////////////////
....................           }
.................... 
....................       }
05146:  BRA    514E
....................       else if(FaultType.B9 == 1) Ack.B9 = 0;
05148:  BTFSS  x7C.0
0514A:  BRA    514E
0514C:  BCF    x84.0
....................    }
0514E:  BRA    51AC
....................    else  //Indicator Function
....................    {
....................       if((Inputt.B9 ^ InputType.B9) == 1)
05150:  MOVLW  00
05152:  BTFSC  x76.0
05154:  MOVLW  01
05156:  MOVWF  xD0
05158:  MOVLW  00
0515A:  BTFSC  x7A.0
0515C:  MOVLW  01
0515E:  XORWF  xD0,W
05160:  SUBLW  01
05162:  BNZ   51A6
....................       {
....................          Output.B9 = 0;
05164:  BCF    x78.0
....................          // SMS Sending   
....................          if((SendSMS.B9 ==0)&& (functointest_f ==0) && (Ack.B9 ==0))
05166:  BTFSC  x92.0
05168:  BRA    51A4
0516A:  BTFSC  32.1
0516C:  BRA    51A4
0516E:  BTFSC  x84.0
05170:  BRA    51A4
....................          {            
....................             SendSMS.B9 =1;
05172:  BSF    x92.0
....................                strcat(SMS_MassageSUM, SMS_Massage9);
05174:  MOVLW  06
05176:  MOVWF  xD0
05178:  MOVLW  D1
0517A:  MOVWF  xCF
0517C:  MOVLW  06
0517E:  MOVWF  xD2
05180:  MOVLW  91
05182:  MOVWF  xD1
05184:  MOVLB  0
05186:  CALL   430C
....................                strcat(SMS_MassageSUM, spacestring);
0518A:  MOVLW  06
0518C:  MOVLB  7
0518E:  MOVWF  xD0
05190:  MOVLW  D1
05192:  MOVWF  xCF
05194:  MOVLW  07
05196:  MOVWF  xD2
05198:  MOVLW  71
0519A:  MOVWF  xD1
0519C:  MOVLB  0
0519E:  CALL   430C
051A2:  MOVLB  7
....................             /*
....................             fprintf(CH2,"AT+CMGF=1"); 
....................             putc('\n',CH2);
....................             delay_ms(10);
.................... 
....................             fprintf(CH2,"AT+CMGS=\"");
....................             fprintf(CH2,sms_phonenumber);
....................             
....................             fprintf(CH2,"\"");
....................             putc('\n',CH2);
....................             delay_ms(50);
....................            
....................            printf(SMS_Massage9);  
....................            putc('\n',CH2);
....................            putc(26,CH2);
....................               */
....................          }
....................          ///////////////////////////////////
....................       }
051A4:  BRA    51AC
....................       else
....................       {
....................          Output.B9 = 1;
051A6:  BSF    x78.0
....................          SendSMS.B9 =0;
051A8:  BCF    x92.0
....................          functointest_f =0;
051AA:  BCF    32.1
....................       }
....................    }
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //input10
....................    if(AlarmIndicator.B10 == 1)    // Alarm Function
051AC:  BTFSS  x82.1
051AE:  BRA    5260
....................    {
....................       if((((Inputt.B10 ^ InputType.B10) == 1) && (FaultType.B10 == 1))|| In.B10 == 1)    // alarm1 occure and "Lock type"
051B0:  MOVLW  00
051B2:  BTFSC  x76.1
051B4:  MOVLW  01
051B6:  MOVWF  xD0
051B8:  MOVLW  00
051BA:  BTFSC  x7A.1
051BC:  MOVLW  01
051BE:  XORWF  xD0,W
051C0:  SUBLW  01
051C2:  BNZ   51C8
051C4:  BTFSC  x7C.1
051C6:  BRA    51CC
051C8:  BTFSS  x86.1
051CA:  BRA    5258
....................       //if(Inputt.B10 == 0)
....................       {
....................          if(Ack.B10 == 0)
051CC:  BTFSC  x84.1
051CE:  BRA    5256
....................          {
....................             if(In.B10 == 0 && AutoAck == 0x0F)   //use auto acknowlegde
051D0:  BTFSC  x86.1
051D2:  BRA    51EC
051D4:  MOVLB  0
051D6:  MOVF   x60,W
051D8:  SUBLW  0F
051DA:  BTFSC  FD8.2
051DC:  BRA    51E2
051DE:  MOVLB  7
051E0:  BRA    51EC
....................             {
....................                TimeBase1s = 100 ;            //reload again
051E2:  MOVLW  64
051E4:  MOVWF  1E
....................                AutoAckDelayTime = AutoAckTime ;
051E6:  MOVFF  61,1F
051EA:  MOVLB  7
....................             }
.................... 
....................             In.B10 = 1;                                 // setbit in1
051EC:  BSF    x86.1
....................             if(FlashingFlag == 0)
051EE:  BTFSC  1C.1
051F0:  BRA    51F6
....................             {
....................                Output.B10 = 0;           //Flash output1
051F2:  BCF    x78.1
....................             }
051F4:  BRA    51F8
....................             else
....................             {
....................                Output.B10 = 1;
051F6:  BSF    x78.1
....................             }
.................... 
....................             if (~AutoTestFlag)
051F8:  BTFSC  1C.4
051FA:  BRA    5218
....................             {
....................                if(OutputBoth.B10 == 0)                  //Both output
051FC:  BTFSC  x80.1
051FE:  BRA    520A
....................                {
....................                   output_bit(Pbuzzer,1);   //Buzzer
05200:  BSF    F89.4
05202:  BCF    F92.4
....................                   output_bit(Pbell,1);     //Bell
05204:  BSF    F89.3
05206:  BCF    F92.3
....................                }
05208:  BRA    5218
....................                else
....................                {
....................                   if(OutputType.B10 == 1) output_bit(Pbuzzer,1);     //Buzzer
0520A:  BTFSS  x7E.1
0520C:  BRA    5214
0520E:  BSF    F89.4
05210:  BCF    F92.4
05212:  BRA    5218
....................                   else output_bit(Pbell,1);                          //Bell
05214:  BSF    F89.3
05216:  BCF    F92.3
....................                }
....................             }
....................             // SMS Sending   
....................             if((SendSMS.B10 ==0)&& (functointest_f ==0) && (Ack.B10 ==0))
05218:  BTFSC  x92.1
0521A:  BRA    5256
0521C:  BTFSC  32.1
0521E:  BRA    5256
05220:  BTFSC  x84.1
05222:  BRA    5256
....................             {               
....................                SendSMS.B10 =1;
05224:  BSF    x92.1
....................                strcat(SMS_MassageSUM, SMS_Massage10);
05226:  MOVLW  06
05228:  MOVWF  xD0
0522A:  MOVLW  D1
0522C:  MOVWF  xCF
0522E:  MOVLW  06
05230:  MOVWF  xD2
05232:  MOVLW  B1
05234:  MOVWF  xD1
05236:  MOVLB  0
05238:  CALL   430C
....................                strcat(SMS_MassageSUM, spacestring);
0523C:  MOVLW  06
0523E:  MOVLB  7
05240:  MOVWF  xD0
05242:  MOVLW  D1
05244:  MOVWF  xCF
05246:  MOVLW  07
05248:  MOVWF  xD2
0524A:  MOVLW  71
0524C:  MOVWF  xD1
0524E:  MOVLB  0
05250:  CALL   430C
05254:  MOVLB  7
....................             /*
....................                fprintf(CH2,"AT+CMGF=1"); 
....................                putc('\n',CH2);
....................                delay_ms(10);
.................... 
....................                fprintf(CH2,"AT+CMGS=\"");
....................                fprintf(CH2,sms_phonenumber);
....................                
....................                fprintf(CH2,"\"");
....................                putc('\n',CH2);
....................                delay_ms(50);
....................               
....................               printf(SMS_Massage10);  
....................               putc('\n',CH2);
....................               putc(26,CH2);
....................               */
....................             }
....................             ///////////////////////////////////
....................           }
.................... 
....................       }
05256:  BRA    525E
....................       else if(FaultType.B10 == 1) Ack.B10 = 0;
05258:  BTFSS  x7C.1
0525A:  BRA    525E
0525C:  BCF    x84.1
....................    }
0525E:  BRA    52BC
....................    else  //Indicator Function
....................    {
....................       if((Inputt.B10 ^ InputType.B10) == 1)
05260:  MOVLW  00
05262:  BTFSC  x76.1
05264:  MOVLW  01
05266:  MOVWF  xD0
05268:  MOVLW  00
0526A:  BTFSC  x7A.1
0526C:  MOVLW  01
0526E:  XORWF  xD0,W
05270:  SUBLW  01
05272:  BNZ   52B6
....................       {
....................          Output.B10 = 0;
05274:  BCF    x78.1
....................          // SMS Sending   
....................          if((SendSMS.B10 ==0)&& (functointest_f ==0) && (Ack.B10 ==0))
05276:  BTFSC  x92.1
05278:  BRA    52B4
0527A:  BTFSC  32.1
0527C:  BRA    52B4
0527E:  BTFSC  x84.1
05280:  BRA    52B4
....................          {            
....................             SendSMS.B10 =1;
05282:  BSF    x92.1
....................                strcat(SMS_MassageSUM, SMS_Massage10);
05284:  MOVLW  06
05286:  MOVWF  xD0
05288:  MOVLW  D1
0528A:  MOVWF  xCF
0528C:  MOVLW  06
0528E:  MOVWF  xD2
05290:  MOVLW  B1
05292:  MOVWF  xD1
05294:  MOVLB  0
05296:  CALL   430C
....................                strcat(SMS_MassageSUM, spacestring);
0529A:  MOVLW  06
0529C:  MOVLB  7
0529E:  MOVWF  xD0
052A0:  MOVLW  D1
052A2:  MOVWF  xCF
052A4:  MOVLW  07
052A6:  MOVWF  xD2
052A8:  MOVLW  71
052AA:  MOVWF  xD1
052AC:  MOVLB  0
052AE:  CALL   430C
052B2:  MOVLB  7
....................             /*
....................             fprintf(CH2,"AT+CMGF=1"); 
....................             putc('\n',CH2);
....................             delay_ms(10);
.................... 
....................             fprintf(CH2,"AT+CMGS=\"");
....................             fprintf(CH2,sms_phonenumber);
....................             
....................             fprintf(CH2,"\"");
....................             putc('\n',CH2);
....................             delay_ms(50);
....................            
....................            printf(SMS_Massage10);  
....................            putc('\n',CH2);
....................            putc(26,CH2);
....................               */
....................          }
....................          ///////////////////////////////////
....................       }
052B4:  BRA    52BC
....................       else
....................       {
....................          Output.B10 = 1;
052B6:  BSF    x78.1
....................          SendSMS.B10 =0;
052B8:  BCF    x92.1
....................          functointest_f =0;
052BA:  BCF    32.1
....................       }
....................    }
.................... 
.................... 
.................... ////////////////////////////////////////////////////////////////////////////////////////
.................... /////////////////////////// END MANUAL RESET //////////////////////////////////////////
.................... 
.................... ////////////////////////////// AUTO RESET ///////////////////////////////////
.................... /////////////////////////////////////////////////////////////////////////////
.................... 
.................... //if(NoOfPoint >= 10)
.................... //{
.................... 
.................... static unsigned char inputflag = 0;
.................... 
.................... //input1
....................    if((((Inputt.B1 ^ InputType.B1) == 1) && (FaultType.B1 == 0))||Test_fault==1)    // alarm1 occure and " Non Lock type"
052BC:  MOVLW  00
052BE:  BTFSC  x75.0
052C0:  MOVLW  01
052C2:  MOVWF  xD0
052C4:  MOVLW  00
052C6:  BTFSC  x79.0
052C8:  MOVLW  01
052CA:  XORWF  xD0,W
052CC:  SUBLW  01
052CE:  BNZ   52D4
052D0:  BTFSS  x7B.0
052D2:  BRA    52D8
052D4:  BTFSS  1C.5
052D6:  BRA    536C
....................    {
....................       if(In2.B1 == 0 && AutoAck == 0x0F && Ack.B1 == 0)   //use auto acknowlegde
052D8:  BTFSC  x87.0
052DA:  BRA    52F8
052DC:  MOVLB  0
052DE:  MOVF   x60,W
052E0:  SUBLW  0F
052E2:  BTFSC  FD8.2
052E4:  BRA    52EA
052E6:  MOVLB  7
052E8:  BRA    52F8
052EA:  MOVLB  7
052EC:  BTFSC  x83.0
052EE:  BRA    52F8
....................       {
....................             TimeBase1s = 100 ;            //reload again
052F0:  MOVLW  64
052F2:  MOVWF  1E
....................             AutoAckDelayTime = AutoAckTime ;
052F4:  MOVFF  61,1F
....................       }
.................... 
....................       In2.B1 = 1;
052F8:  BSF    x87.0
....................       if(Ack.B1 == 0)
052FA:  BTFSC  x83.0
052FC:  BRA    5328
....................       {
....................          if(FlashingFlag == 0)
052FE:  BTFSC  1C.1
05300:  BRA    5306
....................          {
....................             Output.B1 = 0;           //Flash output1
05302:  BCF    x77.0
....................          }
05304:  BRA    5308
....................          else
....................          {
....................             Output.B1 = 1;
05306:  BSF    x77.0
....................          }
....................          if (~AutoTestFlag)
05308:  BTFSC  1C.4
0530A:  BRA    5328
....................          {
....................              if(OutputBoth.B1 == 0)        //Both output
0530C:  BTFSC  x7F.0
0530E:  BRA    531A
....................              {
....................                output_bit(Pbuzzer,1);   //Buzzer
05310:  BSF    F89.4
05312:  BCF    F92.4
....................                output_bit(Pbell,1);     //Bell
05314:  BSF    F89.3
05316:  BCF    F92.3
....................              }
05318:  BRA    5328
....................              else
....................              {
....................                if(OutputType.B1 == 1) output_bit(Pbuzzer,1);     //Buzzer
0531A:  BTFSS  x7D.0
0531C:  BRA    5324
0531E:  BSF    F89.4
05320:  BCF    F92.4
05322:  BRA    5328
....................                else output_bit(Pbell,1);                          //Bell
05324:  BSF    F89.3
05326:  BCF    F92.3
....................              }
....................          }
....................        }
....................       inputflag =1;
05328:  MOVLW  01
0532A:  MOVWF  xCB
....................       // SMS Sending   
....................       if((SendSMS.B1 ==0) && (functointest_f ==0) && (Ack.B1 ==0))
0532C:  BTFSC  x91.0
0532E:  BRA    536A
05330:  BTFSC  32.1
05332:  BRA    536A
05334:  BTFSC  x83.0
05336:  BRA    536A
....................       {
....................          SendSMS.B1 =1;
05338:  BSF    x91.0
....................          strcat(SMS_MassageSUM, SMS_Massage1);
0533A:  MOVLW  06
0533C:  MOVWF  xD0
0533E:  MOVLW  D1
05340:  MOVWF  xCF
05342:  MOVLW  05
05344:  MOVWF  xD2
05346:  MOVLW  91
05348:  MOVWF  xD1
0534A:  MOVLB  0
0534C:  CALL   430C
....................          strcat(SMS_MassageSUM, spacestring);
05350:  MOVLW  06
05352:  MOVLB  7
05354:  MOVWF  xD0
05356:  MOVLW  D1
05358:  MOVWF  xCF
0535A:  MOVLW  07
0535C:  MOVWF  xD2
0535E:  MOVLW  71
05360:  MOVWF  xD1
05362:  MOVLB  0
05364:  CALL   430C
05368:  MOVLB  7
....................          /*
....................          fprintf(CH2,"AT+CMGS=\"");
....................          fprintf(CH2,sms_phonenumber);
....................          
....................          fprintf(CH2,"\"");
....................          putc('\n',CH2);
....................          delay_ms(50);
....................         
....................         fprintf(CH2,SMS_Massage1);   
....................         putc('\n',CH2);
....................        putc(26,CH2);
....................        */
....................       }
....................    }
0536A:  BRA    53EC
....................    else if(FaultType.B1 == 0)
0536C:  BTFSC  x7B.0
0536E:  BRA    53EC
....................    {
....................       In2.B1 = 0x00;
05370:  BCF    x87.0
....................       Ack.B1 = 0;
05372:  BCF    x83.0
....................       Output.B1 = 1;      //Off LED
05374:  BSF    x77.0
....................       
....................       SendSMS.B1 =0;// Clear SMS
05376:  BCF    x91.0
.................... 
....................       if((OutputType.B1 == 1 || OutputBoth.B1 == 0)&& inputflag ==0)       //If Buzzer or Both
05378:  BTFSC  x7D.0
0537A:  BRA    5380
0537C:  BTFSC  x7F.0
0537E:  BRA    539A
05380:  MOVF   xCB,F
05382:  BNZ   539A
....................       {
....................          if(CheckAutoReset(0x01) == 1);   //Check other Input "Ack" or not if not,do nothing
05384:  MOVLW  01
05386:  MOVWF  xCF
05388:  MOVLB  0
0538A:  CALL   4376
0538E:  DECFSZ 01,W
05390:  BRA    5394
05392:  BRA    5398
....................          else
....................          {
....................             output_bit(Pbuzzer,0);   //Clear Buzzer
05394:  BCF    F89.4
05396:  BCF    F92.4
05398:  MOVLB  7
....................          }
....................       }
.................... 
.................... 
....................       if((OutputType.B1 == 0 || OutputBoth.B1 == 0)&& inputflag ==0)   //If Bell or Both
0539A:  BTFSS  x7D.0
0539C:  BRA    53A2
0539E:  BTFSC  x7F.0
053A0:  BRA    53BC
053A2:  MOVF   xCB,F
053A4:  BNZ   53BC
....................       {
....................          if(CheckAutoReset(0x02) == 1);
053A6:  MOVLW  02
053A8:  MOVWF  xCF
053AA:  MOVLB  0
053AC:  CALL   4376
053B0:  DECFSZ 01,W
053B2:  BRA    53B6
053B4:  BRA    53BA
....................          else
....................          {
....................             output_bit(Pbell,0);      //Clear Bell
053B6:  BCF    F89.3
053B8:  BCF    F92.3
053BA:  MOVLB  7
....................          }
....................       }
....................       // jj modify
....................       if(In2.B1 ==0 && In2.B2 ==0 && In2.B3 ==0 && In2.B4 ==0 && In2.B5 ==0 && In2.B6 ==0 && In2.B7 ==0 && In2.B8 ==0 && In2.B9 ==0 && In2.B10 ==0)
053BC:  BTFSC  x87.0
053BE:  BRA    53EC
053C0:  BTFSC  x87.1
053C2:  BRA    53EC
053C4:  BTFSC  x87.2
053C6:  BRA    53EC
053C8:  BTFSC  x87.3
053CA:  BRA    53EC
053CC:  BTFSC  x87.4
053CE:  BRA    53EC
053D0:  BTFSC  x87.5
053D2:  BRA    53EC
053D4:  BTFSC  x87.6
053D6:  BRA    53EC
053D8:  BTFSC  x87.7
053DA:  BRA    53EC
053DC:  BTFSC  x88.0
053DE:  BRA    53EC
053E0:  BTFSC  x88.1
053E2:  BRA    53EC
....................       {
....................          output_bit(Pbell,0);      //Clear Bell
053E4:  BCF    F89.3
053E6:  BCF    F92.3
....................          output_bit(Pbuzzer,0);   //Clear Buzzer
053E8:  BCF    F89.4
053EA:  BCF    F92.4
....................       }
....................    }
....................    ////////////////////////////////////////////////////////////////////////////////////////////////////
.................... //input2
....................    if((((Inputt.B2 ^ InputType.B2) == 1) && (FaultType.B2 == 0))||Test_fault==1)    // alarm1 occure and " Non Lock type"
053EC:  MOVLW  00
053EE:  BTFSC  x75.1
053F0:  MOVLW  01
053F2:  MOVWF  xD0
053F4:  MOVLW  00
053F6:  BTFSC  x79.1
053F8:  MOVLW  01
053FA:  XORWF  xD0,W
053FC:  SUBLW  01
053FE:  BNZ   5404
05400:  BTFSS  x7B.1
05402:  BRA    5408
05404:  BTFSS  1C.5
05406:  BRA    549C
....................    {
....................       if(In2.B2 == 0 && AutoAck == 0x0F && Ack.B2 == 0)   //use auto acknowlegde
05408:  BTFSC  x87.1
0540A:  BRA    5428
0540C:  MOVLB  0
0540E:  MOVF   x60,W
05410:  SUBLW  0F
05412:  BTFSC  FD8.2
05414:  BRA    541A
05416:  MOVLB  7
05418:  BRA    5428
0541A:  MOVLB  7
0541C:  BTFSC  x83.1
0541E:  BRA    5428
....................       {
....................             TimeBase1s = 100 ;            //reload again
05420:  MOVLW  64
05422:  MOVWF  1E
....................             AutoAckDelayTime = AutoAckTime ;
05424:  MOVFF  61,1F
....................       }
.................... 
....................       In2.B2 = 1;
05428:  BSF    x87.1
....................       if(Ack.B2 == 0)
0542A:  BTFSC  x83.1
0542C:  BRA    5458
....................       {
....................          if(FlashingFlag == 0)
0542E:  BTFSC  1C.1
05430:  BRA    5436
....................             {
....................                Output.B2 = 0;           //Flash output1
05432:  BCF    x77.1
....................             }
05434:  BRA    5438
....................             else
....................             {
....................                Output.B2 = 1;
05436:  BSF    x77.1
....................             }
....................          if (~AutoTestFlag)
05438:  BTFSC  1C.4
0543A:  BRA    5458
....................          {
....................              if(OutputBoth.B2 == 0)        //Both output
0543C:  BTFSC  x7F.1
0543E:  BRA    544A
....................              {
....................                output_bit(Pbuzzer,1);   //Buzzer
05440:  BSF    F89.4
05442:  BCF    F92.4
....................                output_bit(Pbell,1);     //Bell
05444:  BSF    F89.3
05446:  BCF    F92.3
....................              }
05448:  BRA    5458
....................              else
....................              {
....................                if(OutputType.B2 == 1) output_bit(Pbuzzer,1);     //Buzzer
0544A:  BTFSS  x7D.1
0544C:  BRA    5454
0544E:  BSF    F89.4
05450:  BCF    F92.4
05452:  BRA    5458
....................                else output_bit(Pbell,1);                          //Bell
05454:  BSF    F89.3
05456:  BCF    F92.3
....................              }
....................          }
....................        }
....................       inputflag =1;
05458:  MOVLW  01
0545A:  MOVWF  xCB
....................       // SMS Sending   
....................       if((SendSMS.B2 ==0)&& (functointest_f ==0) && (Ack.B2 ==0))
0545C:  BTFSC  x91.1
0545E:  BRA    549A
05460:  BTFSC  32.1
05462:  BRA    549A
05464:  BTFSC  x83.1
05466:  BRA    549A
....................       {
....................          SendSMS.B2 =1;
05468:  BSF    x91.1
....................          strcat(SMS_MassageSUM, SMS_Massage2);
0546A:  MOVLW  06
0546C:  MOVWF  xD0
0546E:  MOVLW  D1
05470:  MOVWF  xCF
05472:  MOVLW  05
05474:  MOVWF  xD2
05476:  MOVLW  B1
05478:  MOVWF  xD1
0547A:  MOVLB  0
0547C:  CALL   430C
....................          strcat(SMS_MassageSUM, spacestring);
05480:  MOVLW  06
05482:  MOVLB  7
05484:  MOVWF  xD0
05486:  MOVLW  D1
05488:  MOVWF  xCF
0548A:  MOVLW  07
0548C:  MOVWF  xD2
0548E:  MOVLW  71
05490:  MOVWF  xD1
05492:  MOVLB  0
05494:  CALL   430C
05498:  MOVLB  7
....................          /*
....................          fprintf(CH2,"AT+CMGS=\"");
....................          fprintf(CH2,sms_phonenumber);
....................          
....................          fprintf(CH2,"\"");
....................          putc('\n',CH2);
....................          delay_ms(50);
....................         
....................         fprintf(CH2,SMS_Massage2); 
....................         putc('\n',CH2);
....................        putc(26,CH2);
....................        */
....................       }
....................    }
0549A:  BRA    551C
....................    else if(FaultType.B2 == 0)
0549C:  BTFSC  x7B.1
0549E:  BRA    551C
....................    {
....................       In2.B2 = 0x00;
054A0:  BCF    x87.1
....................       Ack.B2 = 0;
054A2:  BCF    x83.1
....................       Output.B2 = 1;      //Off LED
054A4:  BSF    x77.1
....................       
....................       SendSMS.B2 =0;// Clear SMS
054A6:  BCF    x91.1
.................... 
....................       if((OutputType.B2 == 1 || OutputBoth.B2 == 0)&& inputflag ==0)       //If Buzzer or Both
054A8:  BTFSC  x7D.1
054AA:  BRA    54B0
054AC:  BTFSC  x7F.1
054AE:  BRA    54CA
054B0:  MOVF   xCB,F
054B2:  BNZ   54CA
....................       {
....................          if(CheckAutoReset(0x01) == 1);   //Check other Input "Ack" or not if not,do nothing
054B4:  MOVLW  01
054B6:  MOVWF  xCF
054B8:  MOVLB  0
054BA:  CALL   4376
054BE:  DECFSZ 01,W
054C0:  BRA    54C4
054C2:  BRA    54C8
....................          else
....................          {
....................             output_bit(Pbuzzer,0);   //Clear Buzzer
054C4:  BCF    F89.4
054C6:  BCF    F92.4
054C8:  MOVLB  7
....................          }
....................       }
.................... 
.................... 
....................       if((OutputType.B2 == 0 || OutputBoth.B2 == 0)&& inputflag ==0)   //If Bell or Both
054CA:  BTFSS  x7D.1
054CC:  BRA    54D2
054CE:  BTFSC  x7F.1
054D0:  BRA    54EC
054D2:  MOVF   xCB,F
054D4:  BNZ   54EC
....................       {
....................          if(CheckAutoReset(0x02) == 1);
054D6:  MOVLW  02
054D8:  MOVWF  xCF
054DA:  MOVLB  0
054DC:  CALL   4376
054E0:  DECFSZ 01,W
054E2:  BRA    54E6
054E4:  BRA    54EA
....................          else
....................          {
....................             output_bit(Pbell,0);      //Clear Bell
054E6:  BCF    F89.3
054E8:  BCF    F92.3
054EA:  MOVLB  7
....................          }
....................       }
....................       // jj modify
....................       if(In2.B1 ==0 && In2.B2 ==0 && In2.B3 ==0 && In2.B4 ==0 && In2.B5 ==0 && In2.B6 ==0 && In2.B7 ==0 && In2.B8 ==0 && In2.B9 ==0 && In2.B10 ==0)
054EC:  BTFSC  x87.0
054EE:  BRA    551C
054F0:  BTFSC  x87.1
054F2:  BRA    551C
054F4:  BTFSC  x87.2
054F6:  BRA    551C
054F8:  BTFSC  x87.3
054FA:  BRA    551C
054FC:  BTFSC  x87.4
054FE:  BRA    551C
05500:  BTFSC  x87.5
05502:  BRA    551C
05504:  BTFSC  x87.6
05506:  BRA    551C
05508:  BTFSC  x87.7
0550A:  BRA    551C
0550C:  BTFSC  x88.0
0550E:  BRA    551C
05510:  BTFSC  x88.1
05512:  BRA    551C
....................       {
....................          output_bit(Pbell,0);      //Clear Bell
05514:  BCF    F89.3
05516:  BCF    F92.3
....................          output_bit(Pbuzzer,0);   //Clear Buzzer
05518:  BCF    F89.4
0551A:  BCF    F92.4
....................       }
....................    }
....................    ////////////////////////////////////////////////////////////////////////////////////////////////////
.................... //input3
....................    if((((Inputt.B3 ^ InputType.B3) == 1) && (FaultType.B3 == 0))||Test_fault==1)    // alarm1 occure and " Non Lock type"
0551C:  MOVLW  00
0551E:  BTFSC  x75.2
05520:  MOVLW  01
05522:  MOVWF  xD0
05524:  MOVLW  00
05526:  BTFSC  x79.2
05528:  MOVLW  01
0552A:  XORWF  xD0,W
0552C:  SUBLW  01
0552E:  BNZ   5534
05530:  BTFSS  x7B.2
05532:  BRA    5538
05534:  BTFSS  1C.5
05536:  BRA    55CC
....................    {
....................       if(In2.B3 == 0 && AutoAck == 0x0F && Ack.B3 == 0)   //use auto acknowlegde
05538:  BTFSC  x87.2
0553A:  BRA    5558
0553C:  MOVLB  0
0553E:  MOVF   x60,W
05540:  SUBLW  0F
05542:  BTFSC  FD8.2
05544:  BRA    554A
05546:  MOVLB  7
05548:  BRA    5558
0554A:  MOVLB  7
0554C:  BTFSC  x83.2
0554E:  BRA    5558
....................       {
....................             TimeBase1s = 100 ;            //reload again
05550:  MOVLW  64
05552:  MOVWF  1E
....................             AutoAckDelayTime = AutoAckTime ;
05554:  MOVFF  61,1F
....................       }
.................... 
....................       In2.B3 = 1;
05558:  BSF    x87.2
....................       if(Ack.B3 == 0)
0555A:  BTFSC  x83.2
0555C:  BRA    5588
....................       {
....................          if(FlashingFlag == 0)
0555E:  BTFSC  1C.1
05560:  BRA    5566
....................             {
....................                Output.B3 = 0;           //Flash output1
05562:  BCF    x77.2
....................             }
05564:  BRA    5568
....................             else
....................             {
....................                Output.B3 = 1;
05566:  BSF    x77.2
....................             }
....................          if (~AutoTestFlag)
05568:  BTFSC  1C.4
0556A:  BRA    5588
....................          {
....................              if(OutputBoth.B3 == 0)        //Both output
0556C:  BTFSC  x7F.2
0556E:  BRA    557A
....................              {
....................                output_bit(Pbuzzer,1);   //Buzzer
05570:  BSF    F89.4
05572:  BCF    F92.4
....................                output_bit(Pbell,1);     //Bell
05574:  BSF    F89.3
05576:  BCF    F92.3
....................              }
05578:  BRA    5588
....................              else
....................              {
....................                if(OutputType.B3 == 1) output_bit(Pbuzzer,1);     //Buzzer
0557A:  BTFSS  x7D.2
0557C:  BRA    5584
0557E:  BSF    F89.4
05580:  BCF    F92.4
05582:  BRA    5588
....................                else output_bit(Pbell,1);                          //Bell
05584:  BSF    F89.3
05586:  BCF    F92.3
....................              }
....................          }
....................        }
....................       inputflag =1;
05588:  MOVLW  01
0558A:  MOVWF  xCB
....................       
....................       // SMS Sending   
....................       if((SendSMS.B3 ==0)&& (functointest_f ==0) && (Ack.B3 ==0))
0558C:  BTFSC  x91.2
0558E:  BRA    55CA
05590:  BTFSC  32.1
05592:  BRA    55CA
05594:  BTFSC  x83.2
05596:  BRA    55CA
....................       {
....................          SendSMS.B3 =1;
05598:  BSF    x91.2
....................          strcat(SMS_MassageSUM, SMS_Massage3);
0559A:  MOVLW  06
0559C:  MOVWF  xD0
0559E:  MOVLW  D1
055A0:  MOVWF  xCF
055A2:  MOVLW  05
055A4:  MOVWF  xD2
055A6:  MOVLW  D1
055A8:  MOVWF  xD1
055AA:  MOVLB  0
055AC:  CALL   430C
....................          strcat(SMS_MassageSUM, spacestring);
055B0:  MOVLW  06
055B2:  MOVLB  7
055B4:  MOVWF  xD0
055B6:  MOVLW  D1
055B8:  MOVWF  xCF
055BA:  MOVLW  07
055BC:  MOVWF  xD2
055BE:  MOVLW  71
055C0:  MOVWF  xD1
055C2:  MOVLB  0
055C4:  CALL   430C
055C8:  MOVLB  7
....................          /*
....................          fprintf(CH2,"AT+CMGS=\"");
....................          fprintf(CH2,sms_phonenumber);
....................          
....................          fprintf(CH2,"\"");
....................          putc('\n',CH2);
....................          delay_ms(50);
....................         
....................         fprintf(CH2,SMS_Massage3); 
....................         putc('\n',CH2);
....................        putc(26,CH2);
....................        */
....................       }
....................    }
055CA:  BRA    564C
....................    else if(FaultType.B3 == 0)
055CC:  BTFSC  x7B.2
055CE:  BRA    564C
....................    {
....................       In2.B3 = 0x00;
055D0:  BCF    x87.2
....................       Ack.B3 = 0;
055D2:  BCF    x83.2
....................       Output.B3 = 1;      //Off LED
055D4:  BSF    x77.2
....................       
....................       SendSMS.B3 =0;// Clear SMS
055D6:  BCF    x91.2
.................... 
....................       if((OutputType.B3 == 1 || OutputBoth.B3 == 0)&& inputflag ==0)       //If Buzzer or Both
055D8:  BTFSC  x7D.2
055DA:  BRA    55E0
055DC:  BTFSC  x7F.2
055DE:  BRA    55FA
055E0:  MOVF   xCB,F
055E2:  BNZ   55FA
....................       {
....................          if(CheckAutoReset(0x01) == 1);   //Check other Input "Ack" or not if not,do nothing
055E4:  MOVLW  01
055E6:  MOVWF  xCF
055E8:  MOVLB  0
055EA:  CALL   4376
055EE:  DECFSZ 01,W
055F0:  BRA    55F4
055F2:  BRA    55F8
....................          else
....................          {
....................             output_bit(Pbuzzer,0);   //Clear Buzzer
055F4:  BCF    F89.4
055F6:  BCF    F92.4
055F8:  MOVLB  7
....................          }
....................       }
.................... 
....................       if((OutputType.B3 == 0 || OutputBoth.B3 == 0)&& inputflag ==0)   //If Bell or Both
055FA:  BTFSS  x7D.2
055FC:  BRA    5602
055FE:  BTFSC  x7F.2
05600:  BRA    561C
05602:  MOVF   xCB,F
05604:  BNZ   561C
....................       {
....................          if(CheckAutoReset(0x02) == 1);
05606:  MOVLW  02
05608:  MOVWF  xCF
0560A:  MOVLB  0
0560C:  CALL   4376
05610:  DECFSZ 01,W
05612:  BRA    5616
05614:  BRA    561A
....................          else
....................          {
....................             output_bit(Pbell,0);      //Clear Bell
05616:  BCF    F89.3
05618:  BCF    F92.3
0561A:  MOVLB  7
....................          }
....................       }
....................       // jj modify
....................       if(In2.B1 ==0 && In2.B2 ==0 && In2.B3 ==0 && In2.B4 ==0 && In2.B5 ==0 && In2.B6 ==0 && In2.B7 ==0 && In2.B8 ==0 && In2.B9 ==0 && In2.B10 ==0)
0561C:  BTFSC  x87.0
0561E:  BRA    564C
05620:  BTFSC  x87.1
05622:  BRA    564C
05624:  BTFSC  x87.2
05626:  BRA    564C
05628:  BTFSC  x87.3
0562A:  BRA    564C
0562C:  BTFSC  x87.4
0562E:  BRA    564C
05630:  BTFSC  x87.5
05632:  BRA    564C
05634:  BTFSC  x87.6
05636:  BRA    564C
05638:  BTFSC  x87.7
0563A:  BRA    564C
0563C:  BTFSC  x88.0
0563E:  BRA    564C
05640:  BTFSC  x88.1
05642:  BRA    564C
....................       {
....................          output_bit(Pbell,0);      //Clear Bell
05644:  BCF    F89.3
05646:  BCF    F92.3
....................          output_bit(Pbuzzer,0);   //Clear Buzzer
05648:  BCF    F89.4
0564A:  BCF    F92.4
....................       }
....................    }
....................    ////////////////////////////////////////////////////////////////////////////////////////////////////
.................... //input4
....................    if((((Inputt.B4 ^ InputType.B4) == 1) && (FaultType.B4 == 0))||Test_fault==1)    // alarm1 occure and " Non Lock type"
0564C:  MOVLW  00
0564E:  BTFSC  x75.3
05650:  MOVLW  01
05652:  MOVWF  xD0
05654:  MOVLW  00
05656:  BTFSC  x79.3
05658:  MOVLW  01
0565A:  XORWF  xD0,W
0565C:  SUBLW  01
0565E:  BNZ   5664
05660:  BTFSS  x7B.3
05662:  BRA    5668
05664:  BTFSS  1C.5
05666:  BRA    56FC
....................    {
....................       if(In2.B4 == 0 && AutoAck == 0x0F && Ack.B4 == 0)   //use auto acknowlegde
05668:  BTFSC  x87.3
0566A:  BRA    5688
0566C:  MOVLB  0
0566E:  MOVF   x60,W
05670:  SUBLW  0F
05672:  BTFSC  FD8.2
05674:  BRA    567A
05676:  MOVLB  7
05678:  BRA    5688
0567A:  MOVLB  7
0567C:  BTFSC  x83.3
0567E:  BRA    5688
....................       {
....................             TimeBase1s = 100 ;            //reload again
05680:  MOVLW  64
05682:  MOVWF  1E
....................             AutoAckDelayTime = AutoAckTime ;
05684:  MOVFF  61,1F
....................       }
.................... 
....................       In2.B4 = 1;
05688:  BSF    x87.3
....................       if(Ack.B4 == 0)
0568A:  BTFSC  x83.3
0568C:  BRA    56B8
....................       {
....................          if(FlashingFlag == 0)
0568E:  BTFSC  1C.1
05690:  BRA    5696
....................             {
....................                Output.B4 = 0;           //Flash output1
05692:  BCF    x77.3
....................             }
05694:  BRA    5698
....................             else
....................             {
....................                Output.B4 = 1;
05696:  BSF    x77.3
....................             }
....................          if (~AutoTestFlag)
05698:  BTFSC  1C.4
0569A:  BRA    56B8
....................          {
....................              if(OutputBoth.B4 == 0)        //Both output
0569C:  BTFSC  x7F.3
0569E:  BRA    56AA
....................              {
....................                output_bit(Pbuzzer,1);   //Buzzer
056A0:  BSF    F89.4
056A2:  BCF    F92.4
....................                output_bit(Pbell,1);     //Bell
056A4:  BSF    F89.3
056A6:  BCF    F92.3
....................              }
056A8:  BRA    56B8
....................              else
....................              {
....................                if(OutputType.B4 == 1) output_bit(Pbuzzer,1);     //Buzzer
056AA:  BTFSS  x7D.3
056AC:  BRA    56B4
056AE:  BSF    F89.4
056B0:  BCF    F92.4
056B2:  BRA    56B8
....................                else output_bit(Pbell,1);                          //Bell
056B4:  BSF    F89.3
056B6:  BCF    F92.3
....................              }
....................          }
....................        }
....................       inputflag =1;
056B8:  MOVLW  01
056BA:  MOVWF  xCB
....................       
....................       // SMS Sending   
....................       if((SendSMS.B4 ==0)&& (functointest_f ==0) && (Ack.B4 ==0))
056BC:  BTFSC  x91.3
056BE:  BRA    56FA
056C0:  BTFSC  32.1
056C2:  BRA    56FA
056C4:  BTFSC  x83.3
056C6:  BRA    56FA
....................       {
....................          SendSMS.B4 =1;
056C8:  BSF    x91.3
....................          strcat(SMS_MassageSUM, SMS_Massage4);
056CA:  MOVLW  06
056CC:  MOVWF  xD0
056CE:  MOVLW  D1
056D0:  MOVWF  xCF
056D2:  MOVLW  05
056D4:  MOVWF  xD2
056D6:  MOVLW  F1
056D8:  MOVWF  xD1
056DA:  MOVLB  0
056DC:  CALL   430C
....................          strcat(SMS_MassageSUM, spacestring);
056E0:  MOVLW  06
056E2:  MOVLB  7
056E4:  MOVWF  xD0
056E6:  MOVLW  D1
056E8:  MOVWF  xCF
056EA:  MOVLW  07
056EC:  MOVWF  xD2
056EE:  MOVLW  71
056F0:  MOVWF  xD1
056F2:  MOVLB  0
056F4:  CALL   430C
056F8:  MOVLB  7
....................          /*
....................          fprintf(CH2,"AT+CMGS=\"");
....................          fprintf(CH2,sms_phonenumber);
....................          
....................          fprintf(CH2,"\"");
....................          putc('\n',CH2);
....................          delay_ms(50);
....................         
....................         fprintf(CH2,SMS_Massage4); 
....................         putc('\n',CH2);
....................        putc(26,CH2);
....................        */
....................       }
....................    }
056FA:  BRA    577C
....................    else if(FaultType.B4 == 0)
056FC:  BTFSC  x7B.3
056FE:  BRA    577C
....................    {
....................       In2.B4 = 0x00;
05700:  BCF    x87.3
....................       Ack.B4 = 0;
05702:  BCF    x83.3
....................       Output.B4 = 1;      //Off LED
05704:  BSF    x77.3
....................       
....................       SendSMS.B4 =0;// Clear SMS
05706:  BCF    x91.3
.................... 
....................       if((OutputType.B4 == 1 || OutputBoth.B4 == 0)&& inputflag ==0)       //If Buzzer or Both
05708:  BTFSC  x7D.3
0570A:  BRA    5710
0570C:  BTFSC  x7F.3
0570E:  BRA    572A
05710:  MOVF   xCB,F
05712:  BNZ   572A
....................       {
....................          if(CheckAutoReset(0x01) == 1);   //Check other Input "Ack" or not if not,do nothing
05714:  MOVLW  01
05716:  MOVWF  xCF
05718:  MOVLB  0
0571A:  CALL   4376
0571E:  DECFSZ 01,W
05720:  BRA    5724
05722:  BRA    5728
....................          else
....................          {
....................             output_bit(Pbuzzer,0);   //Clear Buzzer
05724:  BCF    F89.4
05726:  BCF    F92.4
05728:  MOVLB  7
....................          }
....................       }
.................... 
.................... 
....................       if((OutputType.B4 == 0 || OutputBoth.B4 == 0)&& inputflag ==0)   //If Bell or Both
0572A:  BTFSS  x7D.3
0572C:  BRA    5732
0572E:  BTFSC  x7F.3
05730:  BRA    574C
05732:  MOVF   xCB,F
05734:  BNZ   574C
....................       {
....................          if(CheckAutoReset(0x02) == 1);
05736:  MOVLW  02
05738:  MOVWF  xCF
0573A:  MOVLB  0
0573C:  CALL   4376
05740:  DECFSZ 01,W
05742:  BRA    5746
05744:  BRA    574A
....................          else
....................          {
....................             output_bit(Pbell,0);      //Clear Bell
05746:  BCF    F89.3
05748:  BCF    F92.3
0574A:  MOVLB  7
....................          }
....................       }
....................       // jj modify
....................       if(In2.B1 ==0 && In2.B2 ==0 && In2.B3 ==0 && In2.B4 ==0 && In2.B5 ==0 && In2.B6 ==0 && In2.B7 ==0 && In2.B8 ==0 && In2.B9 ==0 && In2.B10 ==0)
0574C:  BTFSC  x87.0
0574E:  BRA    577C
05750:  BTFSC  x87.1
05752:  BRA    577C
05754:  BTFSC  x87.2
05756:  BRA    577C
05758:  BTFSC  x87.3
0575A:  BRA    577C
0575C:  BTFSC  x87.4
0575E:  BRA    577C
05760:  BTFSC  x87.5
05762:  BRA    577C
05764:  BTFSC  x87.6
05766:  BRA    577C
05768:  BTFSC  x87.7
0576A:  BRA    577C
0576C:  BTFSC  x88.0
0576E:  BRA    577C
05770:  BTFSC  x88.1
05772:  BRA    577C
....................       {
....................          output_bit(Pbell,0);      //Clear Bell
05774:  BCF    F89.3
05776:  BCF    F92.3
....................          output_bit(Pbuzzer,0);   //Clear Buzzer
05778:  BCF    F89.4
0577A:  BCF    F92.4
....................       }
....................    }
....................    ////////////////////////////////////////////////////////////////////////////////////////////////////
.................... //input5
....................    if((((Inputt.B5 ^ InputType.B5) == 1) && (FaultType.B5 == 0))||Test_fault==1)    // alarm1 occure and " Non Lock type"
0577C:  MOVLW  00
0577E:  BTFSC  x75.4
05780:  MOVLW  01
05782:  MOVWF  xD0
05784:  MOVLW  00
05786:  BTFSC  x79.4
05788:  MOVLW  01
0578A:  XORWF  xD0,W
0578C:  SUBLW  01
0578E:  BNZ   5794
05790:  BTFSS  x7B.4
05792:  BRA    5798
05794:  BTFSS  1C.5
05796:  BRA    582C
....................    {
....................       if(In2.B5 == 0 && AutoAck == 0x0F && Ack.B5 == 0)   //use auto acknowlegde
05798:  BTFSC  x87.4
0579A:  BRA    57B8
0579C:  MOVLB  0
0579E:  MOVF   x60,W
057A0:  SUBLW  0F
057A2:  BTFSC  FD8.2
057A4:  BRA    57AA
057A6:  MOVLB  7
057A8:  BRA    57B8
057AA:  MOVLB  7
057AC:  BTFSC  x83.4
057AE:  BRA    57B8
....................       {
....................             TimeBase1s = 100 ;            //reload again
057B0:  MOVLW  64
057B2:  MOVWF  1E
....................             AutoAckDelayTime = AutoAckTime ;
057B4:  MOVFF  61,1F
....................       }
.................... 
....................       In2.B5 = 1;
057B8:  BSF    x87.4
....................       if(Ack.B5 == 0)
057BA:  BTFSC  x83.4
057BC:  BRA    57E8
....................       {
....................          if(FlashingFlag == 0)
057BE:  BTFSC  1C.1
057C0:  BRA    57C6
....................             {
....................                Output.B5 = 0;           //Flash output1
057C2:  BCF    x77.4
....................             }
057C4:  BRA    57C8
....................             else
....................             {
....................                Output.B5 = 1;
057C6:  BSF    x77.4
....................             }
....................          if (~AutoTestFlag)
057C8:  BTFSC  1C.4
057CA:  BRA    57E8
....................          {
....................              if(OutputBoth.B5 == 0)        //Both output
057CC:  BTFSC  x7F.4
057CE:  BRA    57DA
....................              {
....................                output_bit(Pbuzzer,1);   //Buzzer
057D0:  BSF    F89.4
057D2:  BCF    F92.4
....................                output_bit(Pbell,1);     //Bell
057D4:  BSF    F89.3
057D6:  BCF    F92.3
....................              }
057D8:  BRA    57E8
....................              else
....................              {
....................                if(OutputType.B5 == 1) output_bit(Pbuzzer,1);     //Buzzer
057DA:  BTFSS  x7D.4
057DC:  BRA    57E4
057DE:  BSF    F89.4
057E0:  BCF    F92.4
057E2:  BRA    57E8
....................                else output_bit(Pbell,1);                          //Bell
057E4:  BSF    F89.3
057E6:  BCF    F92.3
....................              }
....................          }
....................        }
....................       inputflag =1;
057E8:  MOVLW  01
057EA:  MOVWF  xCB
....................       // SMS Sending   
....................       if((SendSMS.B5 ==0)&& (functointest_f ==0) && (Ack.B5 ==0))
057EC:  BTFSC  x91.4
057EE:  BRA    582A
057F0:  BTFSC  32.1
057F2:  BRA    582A
057F4:  BTFSC  x83.4
057F6:  BRA    582A
....................       {
....................          SendSMS.B5 =1;
057F8:  BSF    x91.4
....................          strcat(SMS_MassageSUM, SMS_Massage5);
057FA:  MOVLW  06
057FC:  MOVWF  xD0
057FE:  MOVLW  D1
05800:  MOVWF  xCF
05802:  MOVLW  06
05804:  MOVWF  xD2
05806:  MOVLW  11
05808:  MOVWF  xD1
0580A:  MOVLB  0
0580C:  CALL   430C
....................          strcat(SMS_MassageSUM, spacestring);
05810:  MOVLW  06
05812:  MOVLB  7
05814:  MOVWF  xD0
05816:  MOVLW  D1
05818:  MOVWF  xCF
0581A:  MOVLW  07
0581C:  MOVWF  xD2
0581E:  MOVLW  71
05820:  MOVWF  xD1
05822:  MOVLB  0
05824:  CALL   430C
05828:  MOVLB  7
....................          /*
....................          fprintf(CH2,"AT+CMGS=\"");
....................          fprintf(CH2,sms_phonenumber);
....................          
....................          fprintf(CH2,"\"");
....................          putc('\n',CH2);
....................          delay_ms(50);
....................         
....................         fprintf(CH2,SMS_Massage5); 
....................         putc('\n',CH2);
....................        putc(26,CH2);
....................        */
....................       }
....................    }
0582A:  BRA    58AC
....................    else if(FaultType.B5 == 0)
0582C:  BTFSC  x7B.4
0582E:  BRA    58AC
....................    {
....................       In2.B5 = 0x00;
05830:  BCF    x87.4
....................       Ack.B5 = 0;
05832:  BCF    x83.4
....................       Output.B5 = 1;      //Off LED
05834:  BSF    x77.4
....................       
....................       SendSMS.B5 =0;// Clear SMS
05836:  BCF    x91.4
.................... 
....................       if((OutputType.B5 == 1 || OutputBoth.B5 == 0)&& inputflag ==0)       //If Buzzer or Both
05838:  BTFSC  x7D.4
0583A:  BRA    5840
0583C:  BTFSC  x7F.4
0583E:  BRA    585A
05840:  MOVF   xCB,F
05842:  BNZ   585A
....................       {
....................          if(CheckAutoReset(0x01) == 1);   //Check other Input "Ack" or not if not,do nothing
05844:  MOVLW  01
05846:  MOVWF  xCF
05848:  MOVLB  0
0584A:  CALL   4376
0584E:  DECFSZ 01,W
05850:  BRA    5854
05852:  BRA    5858
....................          else
....................          {
....................             output_bit(Pbuzzer,0);   //Clear Buzzer
05854:  BCF    F89.4
05856:  BCF    F92.4
05858:  MOVLB  7
....................          }
....................       }
.................... 
.................... 
....................       if((OutputType.B5 == 0 || OutputBoth.B5 == 0)&& inputflag ==0)   //If Bell or Both
0585A:  BTFSS  x7D.4
0585C:  BRA    5862
0585E:  BTFSC  x7F.4
05860:  BRA    587C
05862:  MOVF   xCB,F
05864:  BNZ   587C
....................       {
....................          if(CheckAutoReset(0x02) == 1);
05866:  MOVLW  02
05868:  MOVWF  xCF
0586A:  MOVLB  0
0586C:  CALL   4376
05870:  DECFSZ 01,W
05872:  BRA    5876
05874:  BRA    587A
....................          else
....................          {
....................             output_bit(Pbell,0);      //Clear Bell
05876:  BCF    F89.3
05878:  BCF    F92.3
0587A:  MOVLB  7
....................          }
....................       }
....................       // jj modify
....................       if(In2.B1 ==0 && In2.B2 ==0 && In2.B3 ==0 && In2.B4 ==0 && In2.B5 ==0 && In2.B6 ==0 && In2.B7 ==0 && In2.B8 ==0 && In2.B9 ==0 && In2.B10 ==0)
0587C:  BTFSC  x87.0
0587E:  BRA    58AC
05880:  BTFSC  x87.1
05882:  BRA    58AC
05884:  BTFSC  x87.2
05886:  BRA    58AC
05888:  BTFSC  x87.3
0588A:  BRA    58AC
0588C:  BTFSC  x87.4
0588E:  BRA    58AC
05890:  BTFSC  x87.5
05892:  BRA    58AC
05894:  BTFSC  x87.6
05896:  BRA    58AC
05898:  BTFSC  x87.7
0589A:  BRA    58AC
0589C:  BTFSC  x88.0
0589E:  BRA    58AC
058A0:  BTFSC  x88.1
058A2:  BRA    58AC
....................       {
....................          output_bit(Pbell,0);      //Clear Bell
058A4:  BCF    F89.3
058A6:  BCF    F92.3
....................          output_bit(Pbuzzer,0);   //Clear Buzzer
058A8:  BCF    F89.4
058AA:  BCF    F92.4
....................       }
....................    }
....................    ////////////////////////////////////////////////////////////////////////////////////////////////////
.................... //input6
....................    if((((Inputt.B6 ^ InputType.B6) == 1) && (FaultType.B6 == 0))||Test_fault==1)    // alarm1 occure and " Non Lock type"
058AC:  MOVLW  00
058AE:  BTFSC  x75.5
058B0:  MOVLW  01
058B2:  MOVWF  xD0
058B4:  MOVLW  00
058B6:  BTFSC  x79.5
058B8:  MOVLW  01
058BA:  XORWF  xD0,W
058BC:  SUBLW  01
058BE:  BNZ   58C4
058C0:  BTFSS  x7B.5
058C2:  BRA    58C8
058C4:  BTFSS  1C.5
058C6:  BRA    595C
....................    {
....................       if(In2.B6 == 0 && AutoAck == 0x0F && Ack.B6 == 0)   //use auto acknowlegde
058C8:  BTFSC  x87.5
058CA:  BRA    58E8
058CC:  MOVLB  0
058CE:  MOVF   x60,W
058D0:  SUBLW  0F
058D2:  BTFSC  FD8.2
058D4:  BRA    58DA
058D6:  MOVLB  7
058D8:  BRA    58E8
058DA:  MOVLB  7
058DC:  BTFSC  x83.5
058DE:  BRA    58E8
....................       {
....................             TimeBase1s = 100 ;            //reload again
058E0:  MOVLW  64
058E2:  MOVWF  1E
....................             AutoAckDelayTime = AutoAckTime ;
058E4:  MOVFF  61,1F
....................       }
.................... 
....................       In2.B6 = 1;
058E8:  BSF    x87.5
....................       if(Ack.B6 == 0)
058EA:  BTFSC  x83.5
058EC:  BRA    5918
....................       {
....................          if(FlashingFlag == 0)
058EE:  BTFSC  1C.1
058F0:  BRA    58F6
....................             {
....................                Output.B6 = 0;           //Flash output1
058F2:  BCF    x77.5
....................             }
058F4:  BRA    58F8
....................             else
....................             {
....................                Output.B6 = 1;
058F6:  BSF    x77.5
....................             }
....................          if (~AutoTestFlag)
058F8:  BTFSC  1C.4
058FA:  BRA    5918
....................          {
....................              if(OutputBoth.B6 == 0)        //Both output
058FC:  BTFSC  x7F.5
058FE:  BRA    590A
....................              {
....................                output_bit(Pbuzzer,1);   //Buzzer
05900:  BSF    F89.4
05902:  BCF    F92.4
....................                output_bit(Pbell,1);     //Bell
05904:  BSF    F89.3
05906:  BCF    F92.3
....................              }
05908:  BRA    5918
....................              else
....................              {
....................                if(OutputType.B6 == 1) output_bit(Pbuzzer,1);     //Buzzer
0590A:  BTFSS  x7D.5
0590C:  BRA    5914
0590E:  BSF    F89.4
05910:  BCF    F92.4
05912:  BRA    5918
....................                else output_bit(Pbell,1);                          //Bell
05914:  BSF    F89.3
05916:  BCF    F92.3
....................              }
....................          }
....................        }
....................       inputflag =1;
05918:  MOVLW  01
0591A:  MOVWF  xCB
....................       
....................       // SMS Sending   
....................       if((SendSMS.B6 ==0)&& (functointest_f ==0) && (Ack.B6 ==0))
0591C:  BTFSC  x91.5
0591E:  BRA    595A
05920:  BTFSC  32.1
05922:  BRA    595A
05924:  BTFSC  x83.5
05926:  BRA    595A
....................       {
....................          SendSMS.B6 =1;
05928:  BSF    x91.5
....................          strcat(SMS_MassageSUM, SMS_Massage6);
0592A:  MOVLW  06
0592C:  MOVWF  xD0
0592E:  MOVLW  D1
05930:  MOVWF  xCF
05932:  MOVLW  06
05934:  MOVWF  xD2
05936:  MOVLW  31
05938:  MOVWF  xD1
0593A:  MOVLB  0
0593C:  CALL   430C
....................          strcat(SMS_MassageSUM, spacestring);
05940:  MOVLW  06
05942:  MOVLB  7
05944:  MOVWF  xD0
05946:  MOVLW  D1
05948:  MOVWF  xCF
0594A:  MOVLW  07
0594C:  MOVWF  xD2
0594E:  MOVLW  71
05950:  MOVWF  xD1
05952:  MOVLB  0
05954:  CALL   430C
05958:  MOVLB  7
....................          /*
....................          fprintf(CH2,"AT+CMGS=\"");
....................          fprintf(CH2,sms_phonenumber);
....................          
....................          fprintf(CH2,"\"");
....................          putc('\n',CH2);
....................          delay_ms(50);
....................         
....................         fprintf(CH2,SMS_Massage6);  
....................         putc('\n',CH2);
....................        putc(26,CH2);
....................        */
....................       }
....................    }
0595A:  BRA    59DC
....................    else if(FaultType.B6 == 0)
0595C:  BTFSC  x7B.5
0595E:  BRA    59DC
....................    {
....................       In2.B6 = 0x00;
05960:  BCF    x87.5
....................       Ack.B6 = 0;
05962:  BCF    x83.5
....................       Output.B6 = 1;      //Off LED
05964:  BSF    x77.5
....................       
....................       SendSMS.B6 =0;// Clear SMS
05966:  BCF    x91.5
.................... 
....................       if((OutputType.B6 == 1 || OutputBoth.B6 == 0)&& inputflag ==0)       //If Buzzer or Both
05968:  BTFSC  x7D.5
0596A:  BRA    5970
0596C:  BTFSC  x7F.5
0596E:  BRA    598A
05970:  MOVF   xCB,F
05972:  BNZ   598A
....................       {
....................          if(CheckAutoReset(0x01) == 1);   //Check other Input "Ack" or not if not,do nothing
05974:  MOVLW  01
05976:  MOVWF  xCF
05978:  MOVLB  0
0597A:  CALL   4376
0597E:  DECFSZ 01,W
05980:  BRA    5984
05982:  BRA    5988
....................          else
....................          {
....................             output_bit(Pbuzzer,0);   //Clear Buzzer
05984:  BCF    F89.4
05986:  BCF    F92.4
05988:  MOVLB  7
....................          }
....................       }
.................... 
....................       if((OutputType.B6 == 0 || OutputBoth.B6 == 0)&& inputflag ==0)   //If Bell or Both
0598A:  BTFSS  x7D.5
0598C:  BRA    5992
0598E:  BTFSC  x7F.5
05990:  BRA    59AC
05992:  MOVF   xCB,F
05994:  BNZ   59AC
....................       {
....................          if(CheckAutoReset(0x02) == 1);
05996:  MOVLW  02
05998:  MOVWF  xCF
0599A:  MOVLB  0
0599C:  CALL   4376
059A0:  DECFSZ 01,W
059A2:  BRA    59A6
059A4:  BRA    59AA
....................          else
....................          {
....................             output_bit(Pbell,0);      //Clear Bell
059A6:  BCF    F89.3
059A8:  BCF    F92.3
059AA:  MOVLB  7
....................          }
....................       }
....................       // jj modify
....................       if(In2.B1 ==0 && In2.B2 ==0 && In2.B3 ==0 && In2.B4 ==0 && In2.B5 ==0 && In2.B6 ==0 && In2.B7 ==0 && In2.B8 ==0 && In2.B9 ==0 && In2.B10 ==0)
059AC:  BTFSC  x87.0
059AE:  BRA    59DC
059B0:  BTFSC  x87.1
059B2:  BRA    59DC
059B4:  BTFSC  x87.2
059B6:  BRA    59DC
059B8:  BTFSC  x87.3
059BA:  BRA    59DC
059BC:  BTFSC  x87.4
059BE:  BRA    59DC
059C0:  BTFSC  x87.5
059C2:  BRA    59DC
059C4:  BTFSC  x87.6
059C6:  BRA    59DC
059C8:  BTFSC  x87.7
059CA:  BRA    59DC
059CC:  BTFSC  x88.0
059CE:  BRA    59DC
059D0:  BTFSC  x88.1
059D2:  BRA    59DC
....................       {
....................          output_bit(Pbell,0);      //Clear Bell
059D4:  BCF    F89.3
059D6:  BCF    F92.3
....................          output_bit(Pbuzzer,0);   //Clear Buzzer
059D8:  BCF    F89.4
059DA:  BCF    F92.4
....................       }
....................    }
....................    ////////////////////////////////////////////////////////////////////////////////////////////////////
.................... //input7
....................    if((((Inputt.B7 ^ InputType.B7) == 1) && (FaultType.B7 == 0))||Test_fault==1)    // alarm1 occure and " Non Lock type"
059DC:  MOVLW  00
059DE:  BTFSC  x75.6
059E0:  MOVLW  01
059E2:  MOVWF  xD0
059E4:  MOVLW  00
059E6:  BTFSC  x79.6
059E8:  MOVLW  01
059EA:  XORWF  xD0,W
059EC:  SUBLW  01
059EE:  BNZ   59F4
059F0:  BTFSS  x7B.6
059F2:  BRA    59F8
059F4:  BTFSS  1C.5
059F6:  BRA    5A8C
....................    {
....................       if(In2.B7 == 0 && AutoAck == 0x0F && Ack.B7 == 0)   //use auto acknowlegde
059F8:  BTFSC  x87.6
059FA:  BRA    5A18
059FC:  MOVLB  0
059FE:  MOVF   x60,W
05A00:  SUBLW  0F
05A02:  BTFSC  FD8.2
05A04:  BRA    5A0A
05A06:  MOVLB  7
05A08:  BRA    5A18
05A0A:  MOVLB  7
05A0C:  BTFSC  x83.6
05A0E:  BRA    5A18
....................       {
....................             TimeBase1s = 100 ;            //reload again
05A10:  MOVLW  64
05A12:  MOVWF  1E
....................             AutoAckDelayTime = AutoAckTime ;
05A14:  MOVFF  61,1F
....................       }
.................... 
....................       In2.B7 = 1;
05A18:  BSF    x87.6
....................       if(Ack.B7 == 0)
05A1A:  BTFSC  x83.6
05A1C:  BRA    5A48
....................       {
....................          if(FlashingFlag == 0)
05A1E:  BTFSC  1C.1
05A20:  BRA    5A26
....................             {
....................                Output.B7 = 0;           //Flash output1
05A22:  BCF    x77.6
....................             }
05A24:  BRA    5A28
....................             else
....................             {
....................                Output.B7 = 1;
05A26:  BSF    x77.6
....................             }
....................          if (~AutoTestFlag)
05A28:  BTFSC  1C.4
05A2A:  BRA    5A48
....................          {
....................              if(OutputBoth.B7 == 0)        //Both output
05A2C:  BTFSC  x7F.6
05A2E:  BRA    5A3A
....................              {
....................                output_bit(Pbuzzer,1);   //Buzzer
05A30:  BSF    F89.4
05A32:  BCF    F92.4
....................                output_bit(Pbell,1);     //Bell
05A34:  BSF    F89.3
05A36:  BCF    F92.3
....................              }
05A38:  BRA    5A48
....................              else
....................              {
....................                if(OutputType.B7 == 1) output_bit(Pbuzzer,1);     //Buzzer
05A3A:  BTFSS  x7D.6
05A3C:  BRA    5A44
05A3E:  BSF    F89.4
05A40:  BCF    F92.4
05A42:  BRA    5A48
....................                else output_bit(Pbell,1);                          //Bell
05A44:  BSF    F89.3
05A46:  BCF    F92.3
....................              }
....................          }
....................        }
....................       inputflag =1;
05A48:  MOVLW  01
05A4A:  MOVWF  xCB
....................       
....................       // SMS Sending   
....................       if((SendSMS.B7 ==0)&& (functointest_f ==0) && (Ack.B7 ==0))
05A4C:  BTFSC  x91.6
05A4E:  BRA    5A8A
05A50:  BTFSC  32.1
05A52:  BRA    5A8A
05A54:  BTFSC  x83.6
05A56:  BRA    5A8A
....................       {
....................          SendSMS.B7 =1;
05A58:  BSF    x91.6
....................          strcat(SMS_MassageSUM, SMS_Massage7);
05A5A:  MOVLW  06
05A5C:  MOVWF  xD0
05A5E:  MOVLW  D1
05A60:  MOVWF  xCF
05A62:  MOVLW  06
05A64:  MOVWF  xD2
05A66:  MOVLW  51
05A68:  MOVWF  xD1
05A6A:  MOVLB  0
05A6C:  CALL   430C
....................          strcat(SMS_MassageSUM, spacestring);
05A70:  MOVLW  06
05A72:  MOVLB  7
05A74:  MOVWF  xD0
05A76:  MOVLW  D1
05A78:  MOVWF  xCF
05A7A:  MOVLW  07
05A7C:  MOVWF  xD2
05A7E:  MOVLW  71
05A80:  MOVWF  xD1
05A82:  MOVLB  0
05A84:  CALL   430C
05A88:  MOVLB  7
....................          /*
....................          fprintf(CH2,"AT+CMGS=\"");
....................          fprintf(CH2,sms_phonenumber);
....................          
....................          fprintf(CH2,"\"");
....................          putc('\n',CH2);
....................          delay_ms(50);
....................         
....................         fprintf(CH2,SMS_Massage7);  
....................         putc('\n',CH2);
....................        putc(26,CH2);
....................        */
....................       }
....................    }
05A8A:  BRA    5B0C
....................    else if(FaultType.B7 == 0)
05A8C:  BTFSC  x7B.6
05A8E:  BRA    5B0C
....................    {
....................       In2.B7 = 0x00;
05A90:  BCF    x87.6
....................       Ack.B7 = 0;
05A92:  BCF    x83.6
....................       Output.B7 = 1;      //Off LED
05A94:  BSF    x77.6
....................       
....................       SendSMS.B7 =0;// Clear SMS
05A96:  BCF    x91.6
.................... 
....................       if((OutputType.B7 == 1 || OutputBoth.B7 == 0)&& inputflag ==0)       //If Buzzer or Both
05A98:  BTFSC  x7D.6
05A9A:  BRA    5AA0
05A9C:  BTFSC  x7F.6
05A9E:  BRA    5ABA
05AA0:  MOVF   xCB,F
05AA2:  BNZ   5ABA
....................       {
....................          if(CheckAutoReset(0x01) == 1);   //Check other Input "Ack" or not if not,do nothing
05AA4:  MOVLW  01
05AA6:  MOVWF  xCF
05AA8:  MOVLB  0
05AAA:  CALL   4376
05AAE:  DECFSZ 01,W
05AB0:  BRA    5AB4
05AB2:  BRA    5AB8
....................          else
....................          {
....................             output_bit(Pbuzzer,0);   //Clear Buzzer
05AB4:  BCF    F89.4
05AB6:  BCF    F92.4
05AB8:  MOVLB  7
....................          }
....................       }
.................... 
.................... 
....................       if((OutputType.B7 == 0 || OutputBoth.B7 == 0)&& inputflag ==0)   //If Bell or Both
05ABA:  BTFSS  x7D.6
05ABC:  BRA    5AC2
05ABE:  BTFSC  x7F.6
05AC0:  BRA    5ADC
05AC2:  MOVF   xCB,F
05AC4:  BNZ   5ADC
....................       {
....................          if(CheckAutoReset(0x02) == 1);
05AC6:  MOVLW  02
05AC8:  MOVWF  xCF
05ACA:  MOVLB  0
05ACC:  CALL   4376
05AD0:  DECFSZ 01,W
05AD2:  BRA    5AD6
05AD4:  BRA    5ADA
....................          else
....................          {
....................             output_bit(Pbell,0);      //Clear Bell
05AD6:  BCF    F89.3
05AD8:  BCF    F92.3
05ADA:  MOVLB  7
....................          }
....................       }
....................       // jj modify
....................       if(In2.B1 ==0 && In2.B2 ==0 && In2.B3 ==0 && In2.B4 ==0 && In2.B5 ==0 && In2.B6 ==0 && In2.B7 ==0 && In2.B8 ==0 && In2.B9 ==0 && In2.B10 ==0)
05ADC:  BTFSC  x87.0
05ADE:  BRA    5B0C
05AE0:  BTFSC  x87.1
05AE2:  BRA    5B0C
05AE4:  BTFSC  x87.2
05AE6:  BRA    5B0C
05AE8:  BTFSC  x87.3
05AEA:  BRA    5B0C
05AEC:  BTFSC  x87.4
05AEE:  BRA    5B0C
05AF0:  BTFSC  x87.5
05AF2:  BRA    5B0C
05AF4:  BTFSC  x87.6
05AF6:  BRA    5B0C
05AF8:  BTFSC  x87.7
05AFA:  BRA    5B0C
05AFC:  BTFSC  x88.0
05AFE:  BRA    5B0C
05B00:  BTFSC  x88.1
05B02:  BRA    5B0C
....................       {
....................          output_bit(Pbell,0);      //Clear Bell
05B04:  BCF    F89.3
05B06:  BCF    F92.3
....................          output_bit(Pbuzzer,0);   //Clear Buzzer
05B08:  BCF    F89.4
05B0A:  BCF    F92.4
....................       }
....................    }
....................    ////////////////////////////////////////////////////////////////////////////////////////////////////
.................... //input8
....................    if((((Inputt.B8 ^ InputType.B8) == 1) && (FaultType.B8 == 0))||Test_fault==1)    // alarm1 occure and " Non Lock type"
05B0C:  MOVLW  00
05B0E:  BTFSC  x75.7
05B10:  MOVLW  01
05B12:  MOVWF  xD0
05B14:  MOVLW  00
05B16:  BTFSC  x79.7
05B18:  MOVLW  01
05B1A:  XORWF  xD0,W
05B1C:  SUBLW  01
05B1E:  BNZ   5B24
05B20:  BTFSS  x7B.7
05B22:  BRA    5B28
05B24:  BTFSS  1C.5
05B26:  BRA    5BBC
....................    {
....................       if(In2.B8 == 0 && AutoAck == 0x0F && Ack.B8 == 0)   //use auto acknowlegde
05B28:  BTFSC  x87.7
05B2A:  BRA    5B48
05B2C:  MOVLB  0
05B2E:  MOVF   x60,W
05B30:  SUBLW  0F
05B32:  BTFSC  FD8.2
05B34:  BRA    5B3A
05B36:  MOVLB  7
05B38:  BRA    5B48
05B3A:  MOVLB  7
05B3C:  BTFSC  x83.7
05B3E:  BRA    5B48
....................       {
....................             TimeBase1s = 100 ;            //reload again
05B40:  MOVLW  64
05B42:  MOVWF  1E
....................             AutoAckDelayTime = AutoAckTime ;
05B44:  MOVFF  61,1F
....................       }
.................... 
....................       In2.B8 = 1;
05B48:  BSF    x87.7
....................       if(Ack.B8 == 0)
05B4A:  BTFSC  x83.7
05B4C:  BRA    5B78
....................       {
....................          if(FlashingFlag == 0)
05B4E:  BTFSC  1C.1
05B50:  BRA    5B56
....................             {
....................                Output.B8 = 0;           //Flash output1
05B52:  BCF    x77.7
....................             }
05B54:  BRA    5B58
....................             else
....................             {
....................                Output.B8 = 1;
05B56:  BSF    x77.7
....................             }
....................          if (~AutoTestFlag)
05B58:  BTFSC  1C.4
05B5A:  BRA    5B78
....................          {
....................              if(OutputBoth.B8 == 0)        //Both output
05B5C:  BTFSC  x7F.7
05B5E:  BRA    5B6A
....................              {
....................                output_bit(Pbuzzer,1);   //Buzzer
05B60:  BSF    F89.4
05B62:  BCF    F92.4
....................                output_bit(Pbell,1);     //Bell
05B64:  BSF    F89.3
05B66:  BCF    F92.3
....................              }
05B68:  BRA    5B78
....................              else
....................              {
....................                if(OutputType.B8 == 1) output_bit(Pbuzzer,1);     //Buzzer
05B6A:  BTFSS  x7D.7
05B6C:  BRA    5B74
05B6E:  BSF    F89.4
05B70:  BCF    F92.4
05B72:  BRA    5B78
....................                else output_bit(Pbell,1);                          //Bell
05B74:  BSF    F89.3
05B76:  BCF    F92.3
....................              }
....................          }
....................        }
....................       inputflag =1;
05B78:  MOVLW  01
05B7A:  MOVWF  xCB
....................       
....................       // SMS Sending   
....................       if((SendSMS.B8 ==0) && (functointest_f ==0) && (Ack.B8 ==0))
05B7C:  BTFSC  x91.7
05B7E:  BRA    5BBA
05B80:  BTFSC  32.1
05B82:  BRA    5BBA
05B84:  BTFSC  x83.7
05B86:  BRA    5BBA
....................       {
....................          SendSMS.B8 =1;
05B88:  BSF    x91.7
....................          strcat(SMS_MassageSUM, SMS_Massage8);
05B8A:  MOVLW  06
05B8C:  MOVWF  xD0
05B8E:  MOVLW  D1
05B90:  MOVWF  xCF
05B92:  MOVLW  06
05B94:  MOVWF  xD2
05B96:  MOVLW  71
05B98:  MOVWF  xD1
05B9A:  MOVLB  0
05B9C:  CALL   430C
....................          strcat(SMS_MassageSUM, spacestring);
05BA0:  MOVLW  06
05BA2:  MOVLB  7
05BA4:  MOVWF  xD0
05BA6:  MOVLW  D1
05BA8:  MOVWF  xCF
05BAA:  MOVLW  07
05BAC:  MOVWF  xD2
05BAE:  MOVLW  71
05BB0:  MOVWF  xD1
05BB2:  MOVLB  0
05BB4:  CALL   430C
05BB8:  MOVLB  7
....................          /*
....................          fprintf(CH2,"AT+CMGS=\"");
....................          fprintf(CH2,sms_phonenumber);
....................          
....................          fprintf(CH2,"\"");
....................          putc('\n',CH2);
....................          delay_ms(50);
....................         
....................         fprintf(CH2,SMS_Massage8);   
....................         putc('\n',CH2);
....................         putc(26,CH2);
....................        */
....................       }
....................    }
05BBA:  BRA    5C3C
....................    else if(FaultType.B8 == 0)
05BBC:  BTFSC  x7B.7
05BBE:  BRA    5C3C
....................    {
....................       In2.B8 = 0x00;
05BC0:  BCF    x87.7
....................       Ack.B8 = 0;
05BC2:  BCF    x83.7
....................       Output.B8 = 1;      //Off LED
05BC4:  BSF    x77.7
....................       
....................       SendSMS.B8 =0;// Clear SMS
05BC6:  BCF    x91.7
.................... 
....................       if((OutputType.B8 == 1 || OutputBoth.B8 == 0)&& inputflag ==0)       //If Buzzer or Both
05BC8:  BTFSC  x7D.7
05BCA:  BRA    5BD0
05BCC:  BTFSC  x7F.7
05BCE:  BRA    5BEA
05BD0:  MOVF   xCB,F
05BD2:  BNZ   5BEA
....................       {
....................          if(CheckAutoReset(0x01) == 1);   //Check other Input "Ack" or not if not,do nothing
05BD4:  MOVLW  01
05BD6:  MOVWF  xCF
05BD8:  MOVLB  0
05BDA:  CALL   4376
05BDE:  DECFSZ 01,W
05BE0:  BRA    5BE4
05BE2:  BRA    5BE8
....................          else
....................          {
....................             output_bit(Pbuzzer,0);   //Clear Buzzer
05BE4:  BCF    F89.4
05BE6:  BCF    F92.4
05BE8:  MOVLB  7
....................          }
....................       }
.................... 
.................... 
....................       if((OutputType.B8 == 0 || OutputBoth.B8 == 0)&& inputflag ==0)   //If Bell or Both
05BEA:  BTFSS  x7D.7
05BEC:  BRA    5BF2
05BEE:  BTFSC  x7F.7
05BF0:  BRA    5C0C
05BF2:  MOVF   xCB,F
05BF4:  BNZ   5C0C
....................       {
....................          if(CheckAutoReset(0x02) == 1);
05BF6:  MOVLW  02
05BF8:  MOVWF  xCF
05BFA:  MOVLB  0
05BFC:  CALL   4376
05C00:  DECFSZ 01,W
05C02:  BRA    5C06
05C04:  BRA    5C0A
....................          else
....................          {
....................             output_bit(Pbell,0);      //Clear Bell
05C06:  BCF    F89.3
05C08:  BCF    F92.3
05C0A:  MOVLB  7
....................          }
....................       }
....................       // jj modify
....................       if(In2.B1 ==0 && In2.B2 ==0 && In2.B3 ==0 && In2.B4 ==0 && In2.B5 ==0 && In2.B6 ==0 && In2.B7 ==0 && In2.B8 ==0 && In2.B9 ==0 && In2.B10 ==0)
05C0C:  BTFSC  x87.0
05C0E:  BRA    5C3C
05C10:  BTFSC  x87.1
05C12:  BRA    5C3C
05C14:  BTFSC  x87.2
05C16:  BRA    5C3C
05C18:  BTFSC  x87.3
05C1A:  BRA    5C3C
05C1C:  BTFSC  x87.4
05C1E:  BRA    5C3C
05C20:  BTFSC  x87.5
05C22:  BRA    5C3C
05C24:  BTFSC  x87.6
05C26:  BRA    5C3C
05C28:  BTFSC  x87.7
05C2A:  BRA    5C3C
05C2C:  BTFSC  x88.0
05C2E:  BRA    5C3C
05C30:  BTFSC  x88.1
05C32:  BRA    5C3C
....................       {
....................          output_bit(Pbell,0);      //Clear Bell
05C34:  BCF    F89.3
05C36:  BCF    F92.3
....................          output_bit(Pbuzzer,0);   //Clear Buzzer
05C38:  BCF    F89.4
05C3A:  BCF    F92.4
....................       }
....................    }
....................    ////////////////////////////////////////////////////////////////////////////////////////////////////
.................... //input9
....................    if((((Inputt.B9 ^ InputType.B9) == 1) && (FaultType.B9 == 0))||Test_fault==1)    // alarm1 occure and " Non Lock type"
05C3C:  MOVLW  00
05C3E:  BTFSC  x76.0
05C40:  MOVLW  01
05C42:  MOVWF  xD0
05C44:  MOVLW  00
05C46:  BTFSC  x7A.0
05C48:  MOVLW  01
05C4A:  XORWF  xD0,W
05C4C:  SUBLW  01
05C4E:  BNZ   5C54
05C50:  BTFSS  x7C.0
05C52:  BRA    5C58
05C54:  BTFSS  1C.5
05C56:  BRA    5CEC
....................    {
....................       if(In2.B9 == 0 && AutoAck == 0x0F && Ack.B9 == 0)   //use auto acknowlegde
05C58:  BTFSC  x88.0
05C5A:  BRA    5C78
05C5C:  MOVLB  0
05C5E:  MOVF   x60,W
05C60:  SUBLW  0F
05C62:  BTFSC  FD8.2
05C64:  BRA    5C6A
05C66:  MOVLB  7
05C68:  BRA    5C78
05C6A:  MOVLB  7
05C6C:  BTFSC  x84.0
05C6E:  BRA    5C78
....................       {
....................             TimeBase1s = 100 ;            //reload again
05C70:  MOVLW  64
05C72:  MOVWF  1E
....................             AutoAckDelayTime = AutoAckTime ;
05C74:  MOVFF  61,1F
....................       }
.................... 
....................       In2.B9 = 1;
05C78:  BSF    x88.0
....................       if(Ack.B9 == 0)
05C7A:  BTFSC  x84.0
05C7C:  BRA    5CA8
....................       {
....................          if(FlashingFlag == 0)
05C7E:  BTFSC  1C.1
05C80:  BRA    5C86
....................             {
....................                Output.B9 = 0;           //Flash output1
05C82:  BCF    x78.0
....................             }
05C84:  BRA    5C88
....................             else
....................             {
....................                Output.B9 = 1;
05C86:  BSF    x78.0
....................             }
....................          if (~AutoTestFlag)
05C88:  BTFSC  1C.4
05C8A:  BRA    5CA8
....................          {
....................              if(OutputBoth.B9 == 0)        //Both output
05C8C:  BTFSC  x80.0
05C8E:  BRA    5C9A
....................              {
....................                output_bit(Pbuzzer,1);   //Buzzer
05C90:  BSF    F89.4
05C92:  BCF    F92.4
....................                output_bit(Pbell,1);     //Bell
05C94:  BSF    F89.3
05C96:  BCF    F92.3
....................              }
05C98:  BRA    5CA8
....................              else
....................              {
....................                if(OutputType.B9 == 1) output_bit(Pbuzzer,1);     //Buzzer
05C9A:  BTFSS  x7E.0
05C9C:  BRA    5CA4
05C9E:  BSF    F89.4
05CA0:  BCF    F92.4
05CA2:  BRA    5CA8
....................                else output_bit(Pbell,1);                          //Bell
05CA4:  BSF    F89.3
05CA6:  BCF    F92.3
....................              }
....................          }
....................        }
....................       inputflag =1;
05CA8:  MOVLW  01
05CAA:  MOVWF  xCB
....................       
....................       // SMS Sending   
....................       if((SendSMS.B9 ==0) && (functointest_f ==0) && (Ack.B9 ==0))
05CAC:  BTFSC  x92.0
05CAE:  BRA    5CEA
05CB0:  BTFSC  32.1
05CB2:  BRA    5CEA
05CB4:  BTFSC  x84.0
05CB6:  BRA    5CEA
....................       {
....................          SendSMS.B9 =1;
05CB8:  BSF    x92.0
....................          strcat(SMS_MassageSUM, SMS_Massage9);
05CBA:  MOVLW  06
05CBC:  MOVWF  xD0
05CBE:  MOVLW  D1
05CC0:  MOVWF  xCF
05CC2:  MOVLW  06
05CC4:  MOVWF  xD2
05CC6:  MOVLW  91
05CC8:  MOVWF  xD1
05CCA:  MOVLB  0
05CCC:  CALL   430C
....................          strcat(SMS_MassageSUM, spacestring);
05CD0:  MOVLW  06
05CD2:  MOVLB  7
05CD4:  MOVWF  xD0
05CD6:  MOVLW  D1
05CD8:  MOVWF  xCF
05CDA:  MOVLW  07
05CDC:  MOVWF  xD2
05CDE:  MOVLW  71
05CE0:  MOVWF  xD1
05CE2:  MOVLB  0
05CE4:  CALL   430C
05CE8:  MOVLB  7
....................          /*
....................          fprintf(CH2,"AT+CMGS=\"");
....................          fprintf(CH2,sms_phonenumber);
....................          
....................          fprintf(CH2,"\"");
....................          putc('\n',CH2);
....................          delay_ms(50);
....................         
....................         fprintf(CH2,SMS_Massage9);   
....................         putc('\n',CH2);
....................         putc(26,CH2);
....................        */
....................       }
....................    }
05CEA:  BRA    5D6C
....................    else if(FaultType.B9 == 0)
05CEC:  BTFSC  x7C.0
05CEE:  BRA    5D6C
....................    {
....................       In2.B9 = 0x00;
05CF0:  BCF    x88.0
....................       Ack.B9 = 0;
05CF2:  BCF    x84.0
....................       Output.B9 = 1;      //Off LED
05CF4:  BSF    x78.0
....................       
....................       SendSMS.B9 =0;// Clear SMS
05CF6:  BCF    x92.0
.................... 
....................       if((OutputType.B9 == 1 || OutputBoth.B9 == 0)&& inputflag ==0)       //If Buzzer or Both
05CF8:  BTFSC  x7E.0
05CFA:  BRA    5D00
05CFC:  BTFSC  x80.0
05CFE:  BRA    5D1A
05D00:  MOVF   xCB,F
05D02:  BNZ   5D1A
....................       {
....................          if(CheckAutoReset(0x01) == 1);   //Check other Input "Ack" or not if not,do nothing
05D04:  MOVLW  01
05D06:  MOVWF  xCF
05D08:  MOVLB  0
05D0A:  CALL   4376
05D0E:  DECFSZ 01,W
05D10:  BRA    5D14
05D12:  BRA    5D18
....................          else
....................          {
....................             output_bit(Pbuzzer,0);   //Clear Buzzer
05D14:  BCF    F89.4
05D16:  BCF    F92.4
05D18:  MOVLB  7
....................          }
....................       }
.................... 
....................       if((OutputType.B9 == 0 || OutputBoth.B9 == 0)&& inputflag ==0)   //If Bell or Both
05D1A:  BTFSS  x7E.0
05D1C:  BRA    5D22
05D1E:  BTFSC  x80.0
05D20:  BRA    5D3C
05D22:  MOVF   xCB,F
05D24:  BNZ   5D3C
....................       {
....................          if(CheckAutoReset(0x02) == 1);
05D26:  MOVLW  02
05D28:  MOVWF  xCF
05D2A:  MOVLB  0
05D2C:  CALL   4376
05D30:  DECFSZ 01,W
05D32:  BRA    5D36
05D34:  BRA    5D3A
....................          else
....................          {
....................             output_bit(Pbell,0);      //Clear Bell
05D36:  BCF    F89.3
05D38:  BCF    F92.3
05D3A:  MOVLB  7
....................          }
....................       }
....................       // jj modify
....................       if(In2.B1 ==0 && In2.B2 ==0 && In2.B3 ==0 && In2.B4 ==0 && In2.B5 ==0 && In2.B6 ==0 && In2.B7 ==0 && In2.B8 ==0 && In2.B9 ==0 && In2.B10 ==0)
05D3C:  BTFSC  x87.0
05D3E:  BRA    5D6C
05D40:  BTFSC  x87.1
05D42:  BRA    5D6C
05D44:  BTFSC  x87.2
05D46:  BRA    5D6C
05D48:  BTFSC  x87.3
05D4A:  BRA    5D6C
05D4C:  BTFSC  x87.4
05D4E:  BRA    5D6C
05D50:  BTFSC  x87.5
05D52:  BRA    5D6C
05D54:  BTFSC  x87.6
05D56:  BRA    5D6C
05D58:  BTFSC  x87.7
05D5A:  BRA    5D6C
05D5C:  BTFSC  x88.0
05D5E:  BRA    5D6C
05D60:  BTFSC  x88.1
05D62:  BRA    5D6C
....................       {
....................          output_bit(Pbell,0);      //Clear Bell
05D64:  BCF    F89.3
05D66:  BCF    F92.3
....................          output_bit(Pbuzzer,0);   //Clear Buzzer
05D68:  BCF    F89.4
05D6A:  BCF    F92.4
....................       }
....................    }
....................    ////////////////////////////////////////////////////////////////////////////////////////////////////
.................... //input10
....................    if((((Inputt.B10 ^ InputType.B10) == 1) && (FaultType.B10 == 0))||Test_fault==1)    // alarm1 occure and " Non Lock type"
05D6C:  MOVLW  00
05D6E:  BTFSC  x76.1
05D70:  MOVLW  01
05D72:  MOVWF  xD0
05D74:  MOVLW  00
05D76:  BTFSC  x7A.1
05D78:  MOVLW  01
05D7A:  XORWF  xD0,W
05D7C:  SUBLW  01
05D7E:  BNZ   5D84
05D80:  BTFSS  x7C.1
05D82:  BRA    5D88
05D84:  BTFSS  1C.5
05D86:  BRA    5E1C
....................    {
....................       if(In2.B10 == 0 && AutoAck == 0x0F && Ack.B10 == 0)   //use auto acknowlegde
05D88:  BTFSC  x88.1
05D8A:  BRA    5DA8
05D8C:  MOVLB  0
05D8E:  MOVF   x60,W
05D90:  SUBLW  0F
05D92:  BTFSC  FD8.2
05D94:  BRA    5D9A
05D96:  MOVLB  7
05D98:  BRA    5DA8
05D9A:  MOVLB  7
05D9C:  BTFSC  x84.1
05D9E:  BRA    5DA8
....................       {
....................             TimeBase1s = 100 ;            //reload again
05DA0:  MOVLW  64
05DA2:  MOVWF  1E
....................             AutoAckDelayTime = AutoAckTime ;
05DA4:  MOVFF  61,1F
....................       }
.................... 
....................       In2.B10 = 1;
05DA8:  BSF    x88.1
....................       if(Ack.B10 == 0)
05DAA:  BTFSC  x84.1
05DAC:  BRA    5DD8
....................       {
....................          if(FlashingFlag == 0)
05DAE:  BTFSC  1C.1
05DB0:  BRA    5DB6
....................          {
....................             Output.B10 = 0;           //Flash output1
05DB2:  BCF    x78.1
....................          }
05DB4:  BRA    5DB8
....................          else
....................          {
....................             Output.B10 = 1;
05DB6:  BSF    x78.1
....................          }
....................          if (~AutoTestFlag)
05DB8:  BTFSC  1C.4
05DBA:  BRA    5DD8
....................          {
....................              if(OutputBoth.B10 == 0)        //Both output
05DBC:  BTFSC  x80.1
05DBE:  BRA    5DCA
....................              {
....................                output_bit(Pbuzzer,1);   //Buzzer
05DC0:  BSF    F89.4
05DC2:  BCF    F92.4
....................                output_bit(Pbell,1);     //Bell
05DC4:  BSF    F89.3
05DC6:  BCF    F92.3
....................              }
05DC8:  BRA    5DD8
....................              else
....................              {
....................                if(OutputType.B10 == 1) output_bit(Pbuzzer,1);     //Buzzer
05DCA:  BTFSS  x7E.1
05DCC:  BRA    5DD4
05DCE:  BSF    F89.4
05DD0:  BCF    F92.4
05DD2:  BRA    5DD8
....................                else output_bit(Pbell,1);                          //Bell
05DD4:  BSF    F89.3
05DD6:  BCF    F92.3
....................              }
....................          }
....................        }
....................       inputflag =1;
05DD8:  MOVLW  01
05DDA:  MOVWF  xCB
....................       
....................       // SMS Sending   
....................       if((SendSMS.B10 ==0) && (functointest_f ==0) && (Ack.B10 ==0))
05DDC:  BTFSC  x92.1
05DDE:  BRA    5E1A
05DE0:  BTFSC  32.1
05DE2:  BRA    5E1A
05DE4:  BTFSC  x84.1
05DE6:  BRA    5E1A
....................       {
....................          SendSMS.B10 =1;
05DE8:  BSF    x92.1
....................          strcat(SMS_MassageSUM, SMS_Massage10);
05DEA:  MOVLW  06
05DEC:  MOVWF  xD0
05DEE:  MOVLW  D1
05DF0:  MOVWF  xCF
05DF2:  MOVLW  06
05DF4:  MOVWF  xD2
05DF6:  MOVLW  B1
05DF8:  MOVWF  xD1
05DFA:  MOVLB  0
05DFC:  CALL   430C
....................          strcat(SMS_MassageSUM, spacestring);
05E00:  MOVLW  06
05E02:  MOVLB  7
05E04:  MOVWF  xD0
05E06:  MOVLW  D1
05E08:  MOVWF  xCF
05E0A:  MOVLW  07
05E0C:  MOVWF  xD2
05E0E:  MOVLW  71
05E10:  MOVWF  xD1
05E12:  MOVLB  0
05E14:  CALL   430C
05E18:  MOVLB  7
....................          /*
....................          fprintf(CH2,"AT+CMGS=\"");
....................          fprintf(CH2,sms_phonenumber);
....................          
....................          fprintf(CH2,"\"");
....................          putc('\n',CH2);
....................          delay_ms(50);
....................         
....................         fprintf(CH2,SMS_Massage10);   
....................         putc('\n',CH2);
....................         putc(26,CH2);
....................        */
....................       }
....................    }
05E1A:  BRA    5E9C
....................    else if(FaultType.B10 == 0)
05E1C:  BTFSC  x7C.1
05E1E:  BRA    5E9C
....................    {
....................       In2.B10 = 0x00;
05E20:  BCF    x88.1
....................       Ack.B10 = 0;
05E22:  BCF    x84.1
....................       Output.B10 = 1;      //Off LED
05E24:  BSF    x78.1
....................       
....................       SendSMS.B10 =0;// Clear SMS
05E26:  BCF    x92.1
.................... 
....................       if((OutputType.B10 == 1 || OutputBoth.B10 == 0)&& inputflag ==0)       //If Buzzer or Both
05E28:  BTFSC  x7E.1
05E2A:  BRA    5E30
05E2C:  BTFSC  x80.1
05E2E:  BRA    5E4A
05E30:  MOVF   xCB,F
05E32:  BNZ   5E4A
....................       {
....................          if(CheckAutoReset(0x01) == 1);   //Check other Input "Ack" or not if not,do nothing
05E34:  MOVLW  01
05E36:  MOVWF  xCF
05E38:  MOVLB  0
05E3A:  CALL   4376
05E3E:  DECFSZ 01,W
05E40:  BRA    5E44
05E42:  BRA    5E48
....................          else
....................          {
....................             output_bit(Pbuzzer,0);   //Clear Buzzer
05E44:  BCF    F89.4
05E46:  BCF    F92.4
05E48:  MOVLB  7
....................          }
....................       }
.................... 
.................... 
....................       if((OutputType.B10 == 0 || OutputBoth.B10 == 0)&& inputflag ==0)   //If Bell or Both
05E4A:  BTFSS  x7E.1
05E4C:  BRA    5E52
05E4E:  BTFSC  x80.1
05E50:  BRA    5E6C
05E52:  MOVF   xCB,F
05E54:  BNZ   5E6C
....................       {
....................          if(CheckAutoReset(0x02) == 1);
05E56:  MOVLW  02
05E58:  MOVWF  xCF
05E5A:  MOVLB  0
05E5C:  CALL   4376
05E60:  DECFSZ 01,W
05E62:  BRA    5E66
05E64:  BRA    5E6A
....................          else
....................          {
....................             output_bit(Pbell,0);      //Clear Bell
05E66:  BCF    F89.3
05E68:  BCF    F92.3
05E6A:  MOVLB  7
....................          }
....................       }
....................       // jj modify
....................       if(In2.B1 ==0 && In2.B2 ==0 && In2.B3 ==0 && In2.B4 ==0 && In2.B5 ==0 && In2.B6 ==0 && In2.B7 ==0 && In2.B8 ==0 && In2.B9 ==0 && In2.B10 ==0)
05E6C:  BTFSC  x87.0
05E6E:  BRA    5E9C
05E70:  BTFSC  x87.1
05E72:  BRA    5E9C
05E74:  BTFSC  x87.2
05E76:  BRA    5E9C
05E78:  BTFSC  x87.3
05E7A:  BRA    5E9C
05E7C:  BTFSC  x87.4
05E7E:  BRA    5E9C
05E80:  BTFSC  x87.5
05E82:  BRA    5E9C
05E84:  BTFSC  x87.6
05E86:  BRA    5E9C
05E88:  BTFSC  x87.7
05E8A:  BRA    5E9C
05E8C:  BTFSC  x88.0
05E8E:  BRA    5E9C
05E90:  BTFSC  x88.1
05E92:  BRA    5E9C
....................       {
....................          output_bit(Pbell,0);      //Clear Bell
05E94:  BCF    F89.3
05E96:  BCF    F92.3
....................          output_bit(Pbuzzer,0);   //Clear Buzzer
05E98:  BCF    F89.4
05E9A:  BCF    F92.4
....................       }
....................    }
05E9C:  MOVLB  0
05E9E:  GOTO   68FE (RETURN)
....................    
.................... 
.................... }
.................... 
.................... //////////////////////////////////////////////////////////////////////////////////////////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////////
.................... 
.................... void Send_Ouput(void)
.................... {
.................... 
....................    if(T_test == 0x00)
05EA2:  MOVF   31,F
05EA4:  BTFSS  FD8.2
05EA6:  BRA    60DC
....................    {
....................      
....................            if(Output.B1)//++++++++++++B1+++++++++++++++++++++
05EA8:  MOVLB  7
05EAA:  BTFSS  x77.0
05EAC:  BRA    5EB4
....................            {
....................              bit_clear(Green1_8,0); bit_clear(Red1_8,0);
05EAE:  BCF    54.0
05EB0:  BCF    50.0
....................            }
05EB2:  BRA    5EDC
....................            else
....................            {
....................              if((RED_Colour.B1 )&&(GREEN_Colour.B1 ==0 ))//Red
05EB4:  BTFSS  x8D.0
05EB6:  BRA    5EC2
05EB8:  BTFSC  x8F.0
05EBA:  BRA    5EC2
....................              {
....................                bit_set(Red1_8,0); bit_clear(Green1_8,0);
05EBC:  BSF    50.0
05EBE:  BCF    54.0
....................              }
05EC0:  BRA    5EDC
....................              else if((RED_Colour.B1==0 )&&(GREEN_Colour.B1))//Green
05EC2:  BTFSC  x8D.0
05EC4:  BRA    5ED0
05EC6:  BTFSS  x8F.0
05EC8:  BRA    5ED0
....................              {
....................                bit_clear(Red1_8,0); bit_set(Green1_8,0); 
05ECA:  BCF    50.0
05ECC:  BSF    54.0
....................              }
05ECE:  BRA    5EDC
....................              else if((RED_Colour.B1)&&(GREEN_Colour.B1))//Ambian
05ED0:  BTFSS  x8D.0
05ED2:  BRA    5EDC
05ED4:  BTFSS  x8F.0
05ED6:  BRA    5EDC
....................              {
....................                bit_set(Red1_8,0); bit_set(Green1_8,0) ; 
05ED8:  BSF    50.0
05EDA:  BSF    54.0
....................              }  
....................            }
....................            ////////////////////////////////////////////////////////
....................            if(Output.B2)//++++++++++++B2+++++++++++++++++++++
05EDC:  BTFSS  x77.1
05EDE:  BRA    5EE6
....................            {
....................              bit_clear(Green1_8,1); bit_clear(Red1_8,1);
05EE0:  BCF    54.1
05EE2:  BCF    50.1
....................            }
05EE4:  BRA    5F0E
....................            else
....................            {
....................              if((RED_Colour.B2 )&&(GREEN_Colour.B2 ==0 ))//Red
05EE6:  BTFSS  x8D.1
05EE8:  BRA    5EF4
05EEA:  BTFSC  x8F.1
05EEC:  BRA    5EF4
....................              {
....................                bit_set(Red1_8,1); bit_clear(Green1_8,1);
05EEE:  BSF    50.1
05EF0:  BCF    54.1
....................              }
05EF2:  BRA    5F0E
....................              else if((RED_Colour.B2==0 )&&(GREEN_Colour.B2))//Green
05EF4:  BTFSC  x8D.1
05EF6:  BRA    5F02
05EF8:  BTFSS  x8F.1
05EFA:  BRA    5F02
....................              {
....................                bit_clear(Red1_8,1); bit_set(Green1_8,1); 
05EFC:  BCF    50.1
05EFE:  BSF    54.1
....................              }
05F00:  BRA    5F0E
....................              else if((RED_Colour.B2)&&(GREEN_Colour.B2))//Ambian
05F02:  BTFSS  x8D.1
05F04:  BRA    5F0E
05F06:  BTFSS  x8F.1
05F08:  BRA    5F0E
....................              {
....................                bit_set(Red1_8,1); bit_set(Green1_8,1) ; 
05F0A:  BSF    50.1
05F0C:  BSF    54.1
....................              }  
....................            }
....................            ////////////////////////////////////////////////////////
....................            if(Output.B3)//++++++++++++B3+++++++++++++++++++++
05F0E:  BTFSS  x77.2
05F10:  BRA    5F18
....................            {
....................              bit_clear(Green1_8,2); bit_clear(Red1_8,2);
05F12:  BCF    54.2
05F14:  BCF    50.2
....................            }
05F16:  BRA    5F40
....................            else
....................            {
....................              if((RED_Colour.B3 )&&(GREEN_Colour.B3 ==0 ))//Red
05F18:  BTFSS  x8D.2
05F1A:  BRA    5F26
05F1C:  BTFSC  x8F.2
05F1E:  BRA    5F26
....................              {
....................                bit_set(Red1_8,2); bit_clear(Green1_8,2);
05F20:  BSF    50.2
05F22:  BCF    54.2
....................              }
05F24:  BRA    5F40
....................              else if((RED_Colour.B3==0 )&&(GREEN_Colour.B3))//Green
05F26:  BTFSC  x8D.2
05F28:  BRA    5F34
05F2A:  BTFSS  x8F.2
05F2C:  BRA    5F34
....................              {
....................                bit_clear(Red1_8,2); bit_set(Green1_8,2); 
05F2E:  BCF    50.2
05F30:  BSF    54.2
....................              }
05F32:  BRA    5F40
....................              else if((RED_Colour.B3)&&(GREEN_Colour.B3))//Ambian
05F34:  BTFSS  x8D.2
05F36:  BRA    5F40
05F38:  BTFSS  x8F.2
05F3A:  BRA    5F40
....................              {
....................                bit_set(Red1_8,2); bit_set(Green1_8,2) ; 
05F3C:  BSF    50.2
05F3E:  BSF    54.2
....................              }  
....................            }
....................            ////////////////////////////////////////////////////////
....................            if(Output.B4)//++++++++++++B4+++++++++++++++++++++
05F40:  BTFSS  x77.3
05F42:  BRA    5F4A
....................            {
....................              bit_clear(Green1_8,3); bit_clear(Red1_8,3);
05F44:  BCF    54.3
05F46:  BCF    50.3
....................            }
05F48:  BRA    5F72
....................            else
....................            {
....................              if((RED_Colour.B4 )&&(GREEN_Colour.B4 ==0 ))//Red
05F4A:  BTFSS  x8D.3
05F4C:  BRA    5F58
05F4E:  BTFSC  x8F.3
05F50:  BRA    5F58
....................              {
....................                bit_set(Red1_8,3); bit_clear(Green1_8,3);
05F52:  BSF    50.3
05F54:  BCF    54.3
....................              }
05F56:  BRA    5F72
....................              else if((RED_Colour.B4==0 )&&(GREEN_Colour.B4))//Green
05F58:  BTFSC  x8D.3
05F5A:  BRA    5F66
05F5C:  BTFSS  x8F.3
05F5E:  BRA    5F66
....................              {
....................                bit_clear(Red1_8,3); bit_set(Green1_8,3); 
05F60:  BCF    50.3
05F62:  BSF    54.3
....................              }
05F64:  BRA    5F72
....................              else if((RED_Colour.B4)&&(GREEN_Colour.B4))//Ambian
05F66:  BTFSS  x8D.3
05F68:  BRA    5F72
05F6A:  BTFSS  x8F.3
05F6C:  BRA    5F72
....................              {
....................                bit_set(Red1_8,3); bit_set(Green1_8,3) ; 
05F6E:  BSF    50.3
05F70:  BSF    54.3
....................              }  
....................            }
....................            ////////////////////////////////////////////////////////
....................            if(Output.B5)//++++++++++++B5+++++++++++++++++++++
05F72:  BTFSS  x77.4
05F74:  BRA    5F7C
....................            {
....................              bit_clear(Green1_8,4); bit_clear(Red1_8,4);
05F76:  BCF    54.4
05F78:  BCF    50.4
....................            }
05F7A:  BRA    5FA4
....................            else
....................            {
....................              if((RED_Colour.B5 )&&(GREEN_Colour.B5 ==0 ))//Red
05F7C:  BTFSS  x8D.4
05F7E:  BRA    5F8A
05F80:  BTFSC  x8F.4
05F82:  BRA    5F8A
....................              {
....................                bit_set(Red1_8,4); bit_clear(Green1_8,4);
05F84:  BSF    50.4
05F86:  BCF    54.4
....................              }
05F88:  BRA    5FA4
....................              else if((RED_Colour.B5==0 )&&(GREEN_Colour.B5))//Green
05F8A:  BTFSC  x8D.4
05F8C:  BRA    5F98
05F8E:  BTFSS  x8F.4
05F90:  BRA    5F98
....................              {
....................                bit_clear(Red1_8,4); bit_set(Green1_8,4); 
05F92:  BCF    50.4
05F94:  BSF    54.4
....................              }
05F96:  BRA    5FA4
....................              else if((RED_Colour.B5)&&(GREEN_Colour.B5))//Ambian
05F98:  BTFSS  x8D.4
05F9A:  BRA    5FA4
05F9C:  BTFSS  x8F.4
05F9E:  BRA    5FA4
....................              {
....................                bit_set(Red1_8,4); bit_set(Green1_8,4) ; 
05FA0:  BSF    50.4
05FA2:  BSF    54.4
....................              }  
....................            }
....................            ////////////////////////////////////////////////////////
....................            if(Output.B6)//++++++++++++B6+++++++++++++++++++++
05FA4:  BTFSS  x77.5
05FA6:  BRA    5FAE
....................            {
....................              bit_clear(Green1_8,5); bit_clear(Red1_8,5);
05FA8:  BCF    54.5
05FAA:  BCF    50.5
....................            }
05FAC:  BRA    5FD6
....................            else
....................            {
....................              if((RED_Colour.B6 )&&(GREEN_Colour.B6 ==0 ))//Red
05FAE:  BTFSS  x8D.5
05FB0:  BRA    5FBC
05FB2:  BTFSC  x8F.5
05FB4:  BRA    5FBC
....................              {
....................                bit_set(Red1_8,5); bit_clear(Green1_8,5);
05FB6:  BSF    50.5
05FB8:  BCF    54.5
....................              }
05FBA:  BRA    5FD6
....................              else if((RED_Colour.B6==0 )&&(GREEN_Colour.B6))//Green
05FBC:  BTFSC  x8D.5
05FBE:  BRA    5FCA
05FC0:  BTFSS  x8F.5
05FC2:  BRA    5FCA
....................              {
....................                bit_clear(Red1_8,5); bit_set(Green1_8,5); 
05FC4:  BCF    50.5
05FC6:  BSF    54.5
....................              }
05FC8:  BRA    5FD6
....................              else if((RED_Colour.B6)&&(GREEN_Colour.B6))//Ambian
05FCA:  BTFSS  x8D.5
05FCC:  BRA    5FD6
05FCE:  BTFSS  x8F.5
05FD0:  BRA    5FD6
....................              {
....................                bit_set(Red1_8,5); bit_set(Green1_8,5) ; 
05FD2:  BSF    50.5
05FD4:  BSF    54.5
....................              }  
....................            }
....................            ////////////////////////////////////////////////////////
....................            if(Output.B7)//++++++++++++B7+++++++++++++++++++++
05FD6:  BTFSS  x77.6
05FD8:  BRA    5FE0
....................            {
....................              bit_clear(Green1_8,6); bit_clear(Red1_8,6);
05FDA:  BCF    54.6
05FDC:  BCF    50.6
....................            }
05FDE:  BRA    6008
....................            else
....................            {
....................              if((RED_Colour.B7 )&&(GREEN_Colour.B7 ==0 ))//Red
05FE0:  BTFSS  x8D.6
05FE2:  BRA    5FEE
05FE4:  BTFSC  x8F.6
05FE6:  BRA    5FEE
....................              {
....................                bit_set(Red1_8,6); bit_clear(Green1_8,6);
05FE8:  BSF    50.6
05FEA:  BCF    54.6
....................              }
05FEC:  BRA    6008
....................              else if((RED_Colour.B7==0 )&&(GREEN_Colour.B7))//Green
05FEE:  BTFSC  x8D.6
05FF0:  BRA    5FFC
05FF2:  BTFSS  x8F.6
05FF4:  BRA    5FFC
....................              {
....................                bit_clear(Red1_8,6); bit_set(Green1_8,6); 
05FF6:  BCF    50.6
05FF8:  BSF    54.6
....................              }
05FFA:  BRA    6008
....................              else if((RED_Colour.B7)&&(GREEN_Colour.B7))//Ambian
05FFC:  BTFSS  x8D.6
05FFE:  BRA    6008
06000:  BTFSS  x8F.6
06002:  BRA    6008
....................              {
....................                bit_set(Red1_8,6); bit_set(Green1_8,6) ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          
06004:  BSF    50.6
06006:  BSF    54.6
....................              }  
....................            }
....................            ////////////////////////////////////////////////////////
....................            if(Output.B8)//++++++++++++B8+++++++++++++++++++++
06008:  BTFSS  x77.7
0600A:  BRA    6012
....................            {
....................              bit_clear(Green1_8,7); bit_clear(Red1_8,7);
0600C:  BCF    54.7
0600E:  BCF    50.7
....................            }
06010:  BRA    603A
....................            else
....................            {
....................              if((RED_Colour.B8 )&&(GREEN_Colour.B8 ==0 ))//Red
06012:  BTFSS  x8D.7
06014:  BRA    6020
06016:  BTFSC  x8F.7
06018:  BRA    6020
....................              {
....................                bit_set(Red1_8,7); bit_clear(Green1_8,7);
0601A:  BSF    50.7
0601C:  BCF    54.7
....................              }
0601E:  BRA    603A
....................              else if((RED_Colour.B8==0 )&&(GREEN_Colour.B8))//Green
06020:  BTFSC  x8D.7
06022:  BRA    602E
06024:  BTFSS  x8F.7
06026:  BRA    602E
....................              {
....................                bit_clear(Red1_8,7); bit_set(Green1_8,7); 
06028:  BCF    50.7
0602A:  BSF    54.7
....................              }
0602C:  BRA    603A
....................              else if((RED_Colour.B8)&&(GREEN_Colour.B8))//Ambian
0602E:  BTFSS  x8D.7
06030:  BRA    603A
06032:  BTFSS  x8F.7
06034:  BRA    603A
....................              {
....................                bit_set(Red1_8,7); bit_set(Green1_8,7) ; 
06036:  BSF    50.7
06038:  BSF    54.7
....................              }  
....................            }
....................            ////////////////////////////////////////////////////////
....................            ////////////////////////////////////////////////////////
....................            if(Output.B9)//++++++++++++B9+++++++++++++++++++++
0603A:  BTFSS  x78.0
0603C:  BRA    6044
....................            {
....................              bit_clear(Green9_10,0); bit_clear(Red9_10,0);
0603E:  BCF    55.0
06040:  BCF    51.0
....................            }
06042:  BRA    606C
....................            else
....................            {
....................              if((RED_Colour.B9 )&&(GREEN_Colour.B9 ==0 ))//Red
06044:  BTFSS  x8E.0
06046:  BRA    6052
06048:  BTFSC  x90.0
0604A:  BRA    6052
....................              {
....................                bit_set(Red9_10,0); bit_clear(Green9_10,0);
0604C:  BSF    51.0
0604E:  BCF    55.0
....................              }
06050:  BRA    606C
....................              else if((RED_Colour.B9==0 )&&(GREEN_Colour.B9))//Green
06052:  BTFSC  x8E.0
06054:  BRA    6060
06056:  BTFSS  x90.0
06058:  BRA    6060
....................              {
....................                bit_clear(Red9_10,0); bit_set(Green9_10,0); 
0605A:  BCF    51.0
0605C:  BSF    55.0
....................              }
0605E:  BRA    606C
....................              else if((RED_Colour.B9)&&(GREEN_Colour.B9))//Ambian
06060:  BTFSS  x8E.0
06062:  BRA    606C
06064:  BTFSS  x90.0
06066:  BRA    606C
....................              {
....................                bit_set(Red9_10,0); bit_set(Green9_10,0) ; 
06068:  BSF    51.0
0606A:  BSF    55.0
....................              }  
....................            }
....................            ////////////////////////////////////////////////////////
....................             if(Output.B10)//++++++++++++B10+++++++++++++++++++++
0606C:  BTFSS  x78.1
0606E:  BRA    6076
....................            {
....................              bit_clear(Green9_10,1); bit_clear(Red9_10,1);
06070:  BCF    55.1
06072:  BCF    51.1
....................            }
06074:  BRA    609E
....................            else
....................            {
....................              if((RED_Colour.B10 )&&(GREEN_Colour.B10 ==0 ))//Red
06076:  BTFSS  x8E.1
06078:  BRA    6084
0607A:  BTFSC  x90.1
0607C:  BRA    6084
....................              {
....................                bit_set(Red9_10,1); bit_clear(Green9_10,1);
0607E:  BSF    51.1
06080:  BCF    55.1
....................              }
06082:  BRA    609E
....................              else if((RED_Colour.B10==0 )&&(GREEN_Colour.B10))//Green
06084:  BTFSC  x8E.1
06086:  BRA    6092
06088:  BTFSS  x90.1
0608A:  BRA    6092
....................              {
....................                bit_clear(Red9_10,1); bit_set(Green9_10,1); 
0608C:  BCF    51.1
0608E:  BSF    55.1
....................              }
06090:  BRA    609E
....................              else if((RED_Colour.B10)&&(GREEN_Colour.B10))//Ambian
06092:  BTFSS  x8E.1
06094:  BRA    609E
06096:  BTFSS  x90.1
06098:  BRA    609E
....................              {
....................                bit_set(Red9_10,1); bit_set(Green9_10,1) ; 
0609A:  BSF    51.1
0609C:  BSF    55.1
....................              }  
....................            }
....................              
....................            IO_OUTPUT_A(IO_DEVICE_2, Red1_8);
0609E:  MOVLW  04
060A0:  MOVWF  xD7
060A2:  MOVFF  50,7D8
060A6:  MOVLB  0
060A8:  CALL   1EBE
....................            IO_OUTPUT_B(IO_DEVICE_2, Red9_10);
060AC:  MOVLW  04
060AE:  MOVLB  7
060B0:  MOVWF  xD7
060B2:  MOVFF  51,7D8
060B6:  MOVLB  0
060B8:  CALL   1ED4
....................                    
....................            IO_OUTPUT_A(IO_DEVICE_3, Green1_8);
060BC:  MOVLW  06
060BE:  MOVLB  7
060C0:  MOVWF  xD7
060C2:  MOVFF  54,7D8
060C6:  MOVLB  0
060C8:  CALL   1EBE
....................            IO_OUTPUT_B(IO_DEVICE_3, Green9_10);                                             
060CC:  MOVLW  06
060CE:  MOVLB  7
060D0:  MOVWF  xD7
060D2:  MOVFF  55,7D8
060D6:  MOVLB  0
060D8:  CALL   1ED4
....................    }
060DC:  GOTO   6904 (RETURN)
.................... 
.................... }
.................... //////////////////////////////////////////////////////////////////
.................... void ForceAllAlarm(void)
.................... {
....................    if(NoOfPoint == 10)
*
041B2:  MOVF   x63,W
041B4:  SUBLW  0A
041B6:  BNZ   41F8
....................    {
....................       Inputt.B1 = ~InputType.B1;
041B8:  MOVLB  7
041BA:  BCF    x75.0
041BC:  BTFSS  x79.0
041BE:  BSF    x75.0
....................       Inputt.B2 = ~InputType.B2;
041C0:  BCF    x75.1
041C2:  BTFSS  x79.1
041C4:  BSF    x75.1
....................       Inputt.B3 = ~InputType.B3;
041C6:  BCF    x75.2
041C8:  BTFSS  x79.2
041CA:  BSF    x75.2
....................       Inputt.B4 = ~InputType.B4;
041CC:  BCF    x75.3
041CE:  BTFSS  x79.3
041D0:  BSF    x75.3
....................       Inputt.B5 = ~InputType.B5;
041D2:  BCF    x75.4
041D4:  BTFSS  x79.4
041D6:  BSF    x75.4
....................       Inputt.B6 = ~InputType.B6;
041D8:  BCF    x75.5
041DA:  BTFSS  x79.5
041DC:  BSF    x75.5
....................       Inputt.B7 = ~InputType.B7;
041DE:  BCF    x75.6
041E0:  BTFSS  x79.6
041E2:  BSF    x75.6
....................       Inputt.B8 = ~InputType.B8;
041E4:  BCF    x75.7
041E6:  BTFSS  x79.7
041E8:  BSF    x75.7
....................       Inputt.B9 = ~InputType.B9;
041EA:  BCF    x76.0
041EC:  BTFSS  x7A.0
041EE:  BSF    x76.0
....................       Inputt.B10 = ~InputType.B10;
041F0:  BCF    x76.1
041F2:  BTFSS  x7A.1
041F4:  BSF    x76.1
041F6:  MOVLB  0
....................    } 
.................... 
....................    Ack.B1 = 0;
041F8:  MOVLB  7
041FA:  BCF    x83.0
....................    Ack.B2 = 0;
041FC:  BCF    x83.1
....................    Ack.B3 = 0;
041FE:  BCF    x83.2
....................    Ack.B4 = 0;
04200:  BCF    x83.3
....................    Ack.B5 = 0;
04202:  BCF    x83.4
....................    Ack.B6 = 0;
04204:  BCF    x83.5
....................    Ack.B7 = 0;
04206:  BCF    x83.6
....................    Ack.B8 = 0;
04208:  BCF    x83.7
....................    Ack.B9 = 0;
0420A:  BCF    x84.0
....................    Ack.B10 = 0;
0420C:  BCF    x84.1
0420E:  MOVLB  0
04210:  GOTO   42E8 (RETURN)
.................... 
.................... }
.................... 
.................... 
....................  ////////////////////////////////////////////////////////////////////////////////////////////////////
....................  ////////////////////////////////////////////////////////////////////////////////////////////////////
.................... ///////////// Check Test ////////////////
.................... void check_test(void)
.................... {
....................    int8 output_temp[8];
....................    
....................    output_temp[0] = Output1_8;
04214:  MOVFF  35,7CF
....................    output_temp[1] = output9_16;
04218:  MOVFF  36,7D0
.................... 
.................... 
....................        if((input(Ptest) == 0 && Test == 0)|| AutoTestFlag == 1) delay_ms(50);
0421C:  BSF    F94.2
0421E:  BTFSC  F82.2
04220:  BRA    4226
04222:  BTFSS  1C.6
04224:  BRA    422A
04226:  BTFSS  1C.4
04228:  BRA    4236
0422A:  MOVLW  32
0422C:  MOVLB  7
0422E:  MOVWF  xD8
04230:  MOVLB  0
04232:  CALL   068A
....................        if((input(Ptest) == 0 && Test == 0)|| AutoTestFlag == 1)
04236:  BSF    F94.2
04238:  BTFSC  F82.2
0423A:  BRA    4240
0423C:  BTFSS  1C.6
0423E:  BRA    4244
04240:  BTFSS  1C.4
04242:  BRA    42D0
....................        {
....................            if((input(Ptest) == 0 && Test == 0)|| AutoTestFlag ==1)
04244:  BSF    F94.2
04246:  BTFSC  F82.2
04248:  BRA    424E
0424A:  BTFSS  1C.6
0424C:  BRA    4252
0424E:  BTFSS  1C.4
04250:  BRA    42CE
....................            {
....................              restart_wdt();
04252:  CLRWDT
....................              if(T_test == 0) T_test = 0x06;    //3 second for time base 500 ms
04254:  MOVF   31,F
04256:  BNZ   425C
04258:  MOVLW  06
0425A:  MOVWF  31
....................               Test = 1;
0425C:  BSF    1C.6
....................               IO_OUTPUT_A(IO_DEVICE_2, 0xFF);
0425E:  MOVLW  04
04260:  MOVLB  7
04262:  MOVWF  xD7
04264:  SETF   xD8
04266:  MOVLB  0
04268:  CALL   1EBE
....................               IO_OUTPUT_B(IO_DEVICE_2, 0xFF);
0426C:  MOVLW  04
0426E:  MOVLB  7
04270:  MOVWF  xD7
04272:  SETF   xD8
04274:  MOVLB  0
04276:  CALL   1ED4
....................                          
....................               IO_OUTPUT_A(IO_DEVICE_3, 0xFF);
0427A:  MOVLW  06
0427C:  MOVLB  7
0427E:  MOVWF  xD7
04280:  SETF   xD8
04282:  MOVLB  0
04284:  CALL   1EBE
....................               IO_OUTPUT_B(IO_DEVICE_3, 0xFF);
04288:  MOVLW  06
0428A:  MOVLB  7
0428C:  MOVWF  xD7
0428E:  SETF   xD8
04290:  MOVLB  0
04292:  CALL   1ED4
....................               
....................               IO_OUTPUT_A(IO_DEVICE_4, 0xFF);
04296:  MOVLW  08
04298:  MOVLB  7
0429A:  MOVWF  xD7
0429C:  SETF   xD8
0429E:  MOVLB  0
042A0:  CALL   1EBE
....................               IO_OUTPUT_B(IO_DEVICE_4, 0xFF);
042A4:  MOVLW  08
042A6:  MOVLB  7
042A8:  MOVWF  xD7
042AA:  SETF   xD8
042AC:  MOVLB  0
042AE:  CALL   1ED4
....................                         
....................               IO_OUTPUT_A(IO_DEVICE_5, 0xFF);
042B2:  MOVLW  0A
042B4:  MOVLB  7
042B6:  MOVWF  xD7
042B8:  SETF   xD8
042BA:  MOVLB  0
042BC:  CALL   1EBE
....................               IO_OUTPUT_B(IO_DEVICE_5, 0xFF);
042C0:  MOVLW  0A
042C2:  MOVLB  7
042C4:  MOVWF  xD7
042C6:  SETF   xD8
042C8:  MOVLB  0
042CA:  CALL   1ED4
....................              
....................            }
....................        }
042CE:  BRA    42E0
....................        else if(input(Ptest) == 1 && Test == 1)
042D0:  BSF    F94.2
042D2:  BTFSS  F82.2
042D4:  BRA    42E0
042D6:  BTFSS  1C.6
042D8:  BRA    42E0
....................        {
....................            T_test = 0x00;
042DA:  CLRF   31
....................            Test = 0;
042DC:  BCF    1C.6
....................            Test_fault = 0;
042DE:  BCF    1C.5
....................        }
.................... 
.................... 
....................        if(Test_fault == 1)
042E0:  BTFSS  1C.5
042E2:  BRA    42F2
....................        {
....................           functointest_f = 1;
042E4:  BSF    32.1
....................           ForceAllAlarm();
042E6:  BRA    41B2
....................           //Anal_Function();
....................           //Test_fault = 0;
....................           if(Input(Ptest) == 1)
042E8:  BSF    F94.2
042EA:  BTFSS  F82.2
042EC:  BRA    42F0
....................           {
....................             Test_fault = 0;
042EE:  BCF    1C.5
....................           }
....................        }
042F0:  BRA    4308
....................        else if(input(Ptest) == 1 && Test == 1)
042F2:  BSF    F94.2
042F4:  BTFSS  F82.2
042F6:  BRA    4308
042F8:  BTFSS  1C.6
042FA:  BRA    4308
....................        {
....................           if(NoOfPoint >= 16)
042FC:  MOVF   x63,W
042FE:  SUBLW  0F
04300:  BC    4302
....................           {
....................              //PCF8575_write(0xFF,output_temp[0],Input1_8_Wr_addr);
....................              //PCF8575_write(0xFF,output_temp[1],Input9_16_Wr_addr);
....................              //IO_OUTPUT_B(IO_DEVICE_0, output_temp[0]);
....................              //IO_OUTPUT_B(IO_DEVICE_1, output_temp[1]); 
....................           }
....................           
.................... 
....................           T_test = 0x00;
04302:  CLRF   31
....................           Test = 0;
04304:  BCF    1C.6
....................           Test_fault = 0;
04306:  BCF    1C.5
....................        }
04308:  GOTO   68F4 (RETURN)
.................... }
.................... 
.................... 
.................... /////////////// Check acknowledge ////////////////////////////
.................... 
.................... void check_ack(void)
.................... {
.................... 
....................    if((input(Pack) == 0 && Ack_F == 0) || AutoAckFlag == 1) delay_ms(50); //Acknowledge function
*
03F72:  BSF    F94.0
03F74:  BTFSC  F82.0
03F76:  BRA    3F7C
03F78:  BTFSS  1C.7
03F7A:  BRA    3F80
03F7C:  BTFSS  1C.2
03F7E:  BRA    3F8C
03F80:  MOVLW  32
03F82:  MOVLB  7
03F84:  MOVWF  xD8
03F86:  MOVLB  0
03F88:  CALL   068A
....................    if((input(Pack) == 0 && Ack_F == 0) || AutoAckFlag == 1)
03F8C:  BSF    F94.0
03F8E:  BTFSC  F82.0
03F90:  BRA    3F96
03F92:  BTFSS  1C.7
03F94:  BRA    3F9A
03F96:  BTFSS  1C.2
03F98:  BRA    4068
....................    {
....................             AutoAckFlag = 0;
03F9A:  BCF    1C.2
....................             AutoAckDelayTime = 0x00;
03F9C:  CLRF   1F
....................       
....................            if((In.B1 == 1 )||(In2.B1 == 1 ))
03F9E:  MOVLB  7
03FA0:  BTFSC  x85.0
03FA2:  BRA    3FA8
03FA4:  BTFSS  x87.0
03FA6:  BRA    3FB2
....................            {
....................              Ack.B1 = 1;
03FA8:  BSF    x83.0
....................              In.B1 = 0;
03FAA:  BCF    x85.0
....................              In2.B1 = 0;      //for auto reset
03FAC:  BCF    x87.0
....................              Output.B1 = 0;
03FAE:  BCF    x77.0
....................              SendSMS.B1 =0;
03FB0:  BCF    x91.0
....................            }
.................... 
....................            if((In.B2 == 1)||(In2.B2 == 1))
03FB2:  BTFSC  x85.1
03FB4:  BRA    3FBA
03FB6:  BTFSS  x87.1
03FB8:  BRA    3FC4
....................            {
....................              Ack.B2 = 1;
03FBA:  BSF    x83.1
....................              In.B2 = 0;
03FBC:  BCF    x85.1
....................              In2.B2 = 0;      //for auto reset
03FBE:  BCF    x87.1
....................              Output.B2 = 0;
03FC0:  BCF    x77.1
....................              SendSMS.B2 =0;
03FC2:  BCF    x91.1
....................            }
.................... 
....................            if((In.B3 == 1)||(In2.B3 == 1))
03FC4:  BTFSC  x85.2
03FC6:  BRA    3FCC
03FC8:  BTFSS  x87.2
03FCA:  BRA    3FD6
....................            {
....................              Ack.B3 = 1;
03FCC:  BSF    x83.2
....................              In.B3 = 0;
03FCE:  BCF    x85.2
....................              In2.B3 = 0;      //for auto reset
03FD0:  BCF    x87.2
....................              Output.B3 = 0;
03FD2:  BCF    x77.2
....................              SendSMS.B3 =0;
03FD4:  BCF    x91.2
....................            }
.................... 
....................            if((In.B4 == 1)||(In2.B4 == 1))
03FD6:  BTFSC  x85.3
03FD8:  BRA    3FDE
03FDA:  BTFSS  x87.3
03FDC:  BRA    3FE8
....................            {
....................              Ack.B4 = 1;
03FDE:  BSF    x83.3
....................              In.B4 = 0;
03FE0:  BCF    x85.3
....................              In2.B4 = 0;      //for auto reset
03FE2:  BCF    x87.3
....................              Output.B4 = 0;
03FE4:  BCF    x77.3
....................              SendSMS.B4 =0;
03FE6:  BCF    x91.3
....................            }
.................... 
....................            if((In.B5 == 1)||(In2.B5 == 1))
03FE8:  BTFSC  x85.4
03FEA:  BRA    3FF0
03FEC:  BTFSS  x87.4
03FEE:  BRA    3FFA
....................            {
....................              Ack.B5 = 1;
03FF0:  BSF    x83.4
....................              In.B5 = 0;
03FF2:  BCF    x85.4
....................              In2.B5 = 0;      //for auto reset
03FF4:  BCF    x87.4
....................              Output.B5 = 0;
03FF6:  BCF    x77.4
....................              SendSMS.B5 =0;
03FF8:  BCF    x91.4
....................            }
.................... 
....................            if((In.B6 == 1 )||(In2.B6 == 1 ))
03FFA:  BTFSC  x85.5
03FFC:  BRA    4002
03FFE:  BTFSS  x87.5
04000:  BRA    400C
....................            {
....................              Ack.B6 = 1;
04002:  BSF    x83.5
....................              In.B6 = 0;
04004:  BCF    x85.5
....................              In2.B6 = 0;      //for auto reset
04006:  BCF    x87.5
....................              Output.B6 = 0;
04008:  BCF    x77.5
....................              SendSMS.B6 =0;
0400A:  BCF    x91.5
....................            }
....................            if((In.B7 == 1 )||(In2.B7 == 1 ))
0400C:  BTFSC  x85.6
0400E:  BRA    4014
04010:  BTFSS  x87.6
04012:  BRA    401E
....................            {
....................              Ack.B7 = 1;
04014:  BSF    x83.6
....................              In.B7 = 0;
04016:  BCF    x85.6
....................              In2.B7 = 0;      //for auto reset
04018:  BCF    x87.6
....................              Output.B7 = 0;
0401A:  BCF    x77.6
....................              SendSMS.B7 =0;
0401C:  BCF    x91.6
....................            }
....................            if((In.B8 == 1 )||(In2.B8 == 1 ))
0401E:  BTFSC  x85.7
04020:  BRA    4026
04022:  BTFSS  x87.7
04024:  BRA    4030
....................            {
....................              Ack.B8 = 1;
04026:  BSF    x83.7
....................              In.B8 = 0;
04028:  BCF    x85.7
....................              In2.B8 = 0;      //for auto reset
0402A:  BCF    x87.7
....................              Output.B8 = 0;
0402C:  BCF    x77.7
....................              SendSMS.B8 =0;
0402E:  BCF    x91.7
....................            }
....................            if((In.B9 == 1 )||(In2.B9 == 1 ))
04030:  BTFSC  x86.0
04032:  BRA    4038
04034:  BTFSS  x88.0
04036:  BRA    4042
....................            {
....................              Ack.B9 = 1;
04038:  BSF    x84.0
....................              In.B9 = 0;
0403A:  BCF    x86.0
....................              In2.B9 = 0;      //for auto reset
0403C:  BCF    x88.0
....................              Output.B9 = 0;
0403E:  BCF    x78.0
....................              SendSMS.B9 =0;
04040:  BCF    x92.0
....................            }
....................            if((In.B10 == 1)||(In2.B10 == 1))
04042:  BTFSC  x86.1
04044:  BRA    404A
04046:  BTFSS  x88.1
04048:  BRA    4054
....................            {
....................              Ack.B10 = 1;
0404A:  BSF    x84.1
....................              In.B10 = 0;
0404C:  BCF    x86.1
....................              In2.B10 = 0;      //for auto reset
0404E:  BCF    x88.1
....................              Output.B10 = 0;
04050:  BCF    x78.1
....................              SendSMS.B10 =0;
04052:  BCF    x92.1
....................            }
....................          if(functointest_f){
04054:  BTFSS  32.1
04056:  BRA    405A
....................                functointest_f = 0;
04058:  BCF    32.1
....................             }
....................             Ack_F = 1;
0405A:  BSF    1C.7
....................             output_bit(Pbuzzer,0);   //Buzzer
0405C:  BCF    F89.4
0405E:  BCF    F92.4
....................             output_bit(Pbell,0);     //Bell
04060:  BCF    F89.3
04062:  BCF    F92.3
....................    }
04064:  BRA    4076
04066:  MOVLB  0
....................    else if(input(Pack) == 1 && Ack_F == 1)
04068:  BSF    F94.0
0406A:  BTFSS  F82.0
0406C:  BRA    4074
0406E:  BTFSS  1C.7
04070:  BRA    4074
....................    {
....................       Ack_F = 0;
04072:  BCF    1C.7
04074:  MOVLB  7
....................    }
04076:  MOVLB  0
04078:  GOTO   68EC (RETURN)
.................... 
.................... }
.................... 
.................... ///////////////////// Check Reset ///////////////////////////////////
.................... void check_reset(void)
.................... {
....................     if((input(Preset) == 0 && Reset_F == 0)|| AutoResetFlag ==1) delay_ms(50);
0407C:  BSF    F94.1
0407E:  BTFSC  F82.1
04080:  BRA    4086
04082:  BTFSS  32.0
04084:  BRA    408A
04086:  BTFSS  1C.3
04088:  BRA    4096
0408A:  MOVLW  32
0408C:  MOVLB  7
0408E:  MOVWF  xD8
04090:  MOVLB  0
04092:  CALL   068A
....................     if((input(Preset) == 0 && Reset_F == 0)|| AutoResetFlag ==1)
04096:  BSF    F94.1
04098:  BTFSC  F82.1
0409A:  BRA    40A0
0409C:  BTFSS  32.0
0409E:  BRA    40A4
040A0:  BTFSS  1C.3
040A2:  BRA    419E
....................     {
....................        AutoResetFlag = 0;
040A4:  BCF    1C.3
....................        
....................        if((Inputt.B1 ^ InputType.B1) == 0 && In.B1 == 0) Output.B1 = 1;
040A6:  MOVLW  00
040A8:  MOVLB  7
040AA:  BTFSC  x75.0
040AC:  MOVLW  01
040AE:  MOVWF  xD0
040B0:  MOVLW  00
040B2:  BTFSC  x79.0
040B4:  MOVLW  01
040B6:  XORWF  xD0,W
040B8:  BNZ   40C0
040BA:  BTFSC  x85.0
040BC:  BRA    40C0
040BE:  BSF    x77.0
....................        if((Inputt.B2 ^ InputType.B2) == 0 && In.B2 == 0) Output.B2 = 1;
040C0:  MOVLW  00
040C2:  BTFSC  x75.1
040C4:  MOVLW  01
040C6:  MOVWF  xD0
040C8:  MOVLW  00
040CA:  BTFSC  x79.1
040CC:  MOVLW  01
040CE:  XORWF  xD0,W
040D0:  BNZ   40D8
040D2:  BTFSC  x85.1
040D4:  BRA    40D8
040D6:  BSF    x77.1
....................        if((Inputt.B3 ^ InputType.B3) == 0 && In.B3 == 0) Output.B3 = 1;
040D8:  MOVLW  00
040DA:  BTFSC  x75.2
040DC:  MOVLW  01
040DE:  MOVWF  xD0
040E0:  MOVLW  00
040E2:  BTFSC  x79.2
040E4:  MOVLW  01
040E6:  XORWF  xD0,W
040E8:  BNZ   40F0
040EA:  BTFSC  x85.2
040EC:  BRA    40F0
040EE:  BSF    x77.2
....................        if((Inputt.B4 ^ InputType.B4) == 0 && In.B4 == 0) Output.B4 = 1;
040F0:  MOVLW  00
040F2:  BTFSC  x75.3
040F4:  MOVLW  01
040F6:  MOVWF  xD0
040F8:  MOVLW  00
040FA:  BTFSC  x79.3
040FC:  MOVLW  01
040FE:  XORWF  xD0,W
04100:  BNZ   4108
04102:  BTFSC  x85.3
04104:  BRA    4108
04106:  BSF    x77.3
....................        if((Inputt.B5 ^ InputType.B5) == 0 && In.B5 == 0) Output.B5 = 1;
04108:  MOVLW  00
0410A:  BTFSC  x75.4
0410C:  MOVLW  01
0410E:  MOVWF  xD0
04110:  MOVLW  00
04112:  BTFSC  x79.4
04114:  MOVLW  01
04116:  XORWF  xD0,W
04118:  BNZ   4120
0411A:  BTFSC  x85.4
0411C:  BRA    4120
0411E:  BSF    x77.4
....................        if((Inputt.B6 ^ InputType.B6) == 0 && In.B6 == 0) Output.B6 = 1;
04120:  MOVLW  00
04122:  BTFSC  x75.5
04124:  MOVLW  01
04126:  MOVWF  xD0
04128:  MOVLW  00
0412A:  BTFSC  x79.5
0412C:  MOVLW  01
0412E:  XORWF  xD0,W
04130:  BNZ   4138
04132:  BTFSC  x85.5
04134:  BRA    4138
04136:  BSF    x77.5
....................        if((Inputt.B7 ^ InputType.B7) == 0 && In.B7 == 0) Output.B7 = 1;
04138:  MOVLW  00
0413A:  BTFSC  x75.6
0413C:  MOVLW  01
0413E:  MOVWF  xD0
04140:  MOVLW  00
04142:  BTFSC  x79.6
04144:  MOVLW  01
04146:  XORWF  xD0,W
04148:  BNZ   4150
0414A:  BTFSC  x85.6
0414C:  BRA    4150
0414E:  BSF    x77.6
....................        if((Inputt.B8 ^ InputType.B8) == 0 && In.B8 == 0) Output.B8 = 1;
04150:  MOVLW  00
04152:  BTFSC  x75.7
04154:  MOVLW  01
04156:  MOVWF  xD0
04158:  MOVLW  00
0415A:  BTFSC  x79.7
0415C:  MOVLW  01
0415E:  XORWF  xD0,W
04160:  BNZ   4168
04162:  BTFSC  x85.7
04164:  BRA    4168
04166:  BSF    x77.7
....................        if((Inputt.B9 ^ InputType.B9) == 0 && In.B9 == 0) Output.B9 = 1;
04168:  MOVLW  00
0416A:  BTFSC  x76.0
0416C:  MOVLW  01
0416E:  MOVWF  xD0
04170:  MOVLW  00
04172:  BTFSC  x7A.0
04174:  MOVLW  01
04176:  XORWF  xD0,W
04178:  BNZ   4180
0417A:  BTFSC  x86.0
0417C:  BRA    4180
0417E:  BSF    x78.0
....................        if((Inputt.B10 ^ InputType.B10) == 0 && In.B10 == 0) Output.B10 = 1;
04180:  MOVLW  00
04182:  BTFSC  x76.1
04184:  MOVLW  01
04186:  MOVWF  xD0
04188:  MOVLW  00
0418A:  BTFSC  x7A.1
0418C:  MOVLW  01
0418E:  XORWF  xD0,W
04190:  BNZ   4198
04192:  BTFSC  x86.1
04194:  BRA    4198
04196:  BSF    x78.1
.................... 
....................        Reset_F = 1;
04198:  BSF    32.0
....................     }
0419A:  BRA    41AC
0419C:  MOVLB  0
....................     else if(input(Preset) == 1 && Reset_F == 1)
0419E:  BSF    F94.1
041A0:  BTFSS  F82.1
041A2:  BRA    41AA
041A4:  BTFSS  32.0
041A6:  BRA    41AA
....................     {
....................        Reset_F = 0;
041A8:  BCF    32.0
041AA:  MOVLB  7
....................     }
041AC:  MOVLB  0
041AE:  GOTO   68F0 (RETURN)
.................... }
.................... //////////////////////////////////////////////////////////////////////////////
.................... ////////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////Check Auto Reset function ///////////////////////////////////
.................... ////////////////////////////////////////////////////////////////////////////////////
.................... int1 CheckAutoReset(unsigned char DatType)
.................... {
....................    int1 check;     /// "1" = true  //Other Alarm active or not "ACK"
.................... 
....................    if(DatType == 0x01) // Buzzer
*
04376:  MOVLB  7
04378:  DECFSZ xCF,W
0437A:  BRA    45CC
....................    {
....................       check = (In.B1 | In2.B1) & ~Ack.B1 & (OutputType.B1 | OutputBoth.B1);
0437C:  MOVLW  00
0437E:  BTFSC  x85.0
04380:  MOVLW  01
04382:  MOVWF  xD2
04384:  MOVLW  00
04386:  BTFSC  x87.0
04388:  MOVLW  01
0438A:  IORWF  xD2,W
0438C:  MOVWF  xD1
0438E:  MOVLW  00
04390:  BTFSS  x83.0
04392:  MOVLW  01
04394:  ANDWF  xD1,F
04396:  MOVLW  00
04398:  BTFSC  x7D.0
0439A:  MOVLW  01
0439C:  MOVWF  xD4
0439E:  MOVLW  00
043A0:  BTFSC  x7F.0
043A2:  MOVLW  01
043A4:  IORWF  xD4,W
043A6:  ANDWF  xD1,W
043A8:  BCF    xD0.0
043AA:  BTFSC  FE8.0
043AC:  BSF    xD0.0
....................       check = check | ((In.B2 | In2.B2) & ~Ack.B2 & (OutputType.B2 | OutputBoth.B2));
043AE:  MOVLW  00
043B0:  BTFSC  xD0.0
043B2:  MOVLW  01
043B4:  MOVWF  xD1
043B6:  MOVLW  00
043B8:  BTFSC  x85.1
043BA:  MOVLW  01
043BC:  MOVWF  xD3
043BE:  MOVLW  00
043C0:  BTFSC  x87.1
043C2:  MOVLW  01
043C4:  IORWF  xD3,W
043C6:  MOVWF  xD2
043C8:  MOVLW  00
043CA:  BTFSS  x83.1
043CC:  MOVLW  01
043CE:  ANDWF  xD2,F
043D0:  MOVLW  00
043D2:  BTFSC  x7D.1
043D4:  MOVLW  01
043D6:  MOVWF  xD5
043D8:  MOVLW  00
043DA:  BTFSC  x7F.1
043DC:  MOVLW  01
043DE:  IORWF  xD5,W
043E0:  ANDWF  xD2,W
043E2:  IORWF  xD1,W
043E4:  BCF    xD0.0
043E6:  BTFSC  FE8.0
043E8:  BSF    xD0.0
....................       check = check | ((In.B3 | In2.B3) & ~Ack.B3 & (OutputType.B3 | OutputBoth.B3));
043EA:  MOVLW  00
043EC:  BTFSC  xD0.0
043EE:  MOVLW  01
043F0:  MOVWF  xD1
043F2:  MOVLW  00
043F4:  BTFSC  x85.2
043F6:  MOVLW  01
043F8:  MOVWF  xD3
043FA:  MOVLW  00
043FC:  BTFSC  x87.2
043FE:  MOVLW  01
04400:  IORWF  xD3,W
04402:  MOVWF  xD2
04404:  MOVLW  00
04406:  BTFSS  x83.2
04408:  MOVLW  01
0440A:  ANDWF  xD2,F
0440C:  MOVLW  00
0440E:  BTFSC  x7D.2
04410:  MOVLW  01
04412:  MOVWF  xD5
04414:  MOVLW  00
04416:  BTFSC  x7F.2
04418:  MOVLW  01
0441A:  IORWF  xD5,W
0441C:  ANDWF  xD2,W
0441E:  IORWF  xD1,W
04420:  BCF    xD0.0
04422:  BTFSC  FE8.0
04424:  BSF    xD0.0
....................       check = check | ((In.B4 | In2.B4) & ~Ack.B4 & (OutputType.B4 | OutputBoth.B4));
04426:  MOVLW  00
04428:  BTFSC  xD0.0
0442A:  MOVLW  01
0442C:  MOVWF  xD1
0442E:  MOVLW  00
04430:  BTFSC  x85.3
04432:  MOVLW  01
04434:  MOVWF  xD3
04436:  MOVLW  00
04438:  BTFSC  x87.3
0443A:  MOVLW  01
0443C:  IORWF  xD3,W
0443E:  MOVWF  xD2
04440:  MOVLW  00
04442:  BTFSS  x83.3
04444:  MOVLW  01
04446:  ANDWF  xD2,F
04448:  MOVLW  00
0444A:  BTFSC  x7D.3
0444C:  MOVLW  01
0444E:  MOVWF  xD5
04450:  MOVLW  00
04452:  BTFSC  x7F.3
04454:  MOVLW  01
04456:  IORWF  xD5,W
04458:  ANDWF  xD2,W
0445A:  IORWF  xD1,W
0445C:  BCF    xD0.0
0445E:  BTFSC  FE8.0
04460:  BSF    xD0.0
....................       check = check | ((In.B5 | In2.B5) & ~Ack.B5 & (OutputType.B5 | OutputBoth.B5));
04462:  MOVLW  00
04464:  BTFSC  xD0.0
04466:  MOVLW  01
04468:  MOVWF  xD1
0446A:  MOVLW  00
0446C:  BTFSC  x85.4
0446E:  MOVLW  01
04470:  MOVWF  xD3
04472:  MOVLW  00
04474:  BTFSC  x87.4
04476:  MOVLW  01
04478:  IORWF  xD3,W
0447A:  MOVWF  xD2
0447C:  MOVLW  00
0447E:  BTFSS  x83.4
04480:  MOVLW  01
04482:  ANDWF  xD2,F
04484:  MOVLW  00
04486:  BTFSC  x7D.4
04488:  MOVLW  01
0448A:  MOVWF  xD5
0448C:  MOVLW  00
0448E:  BTFSC  x7F.4
04490:  MOVLW  01
04492:  IORWF  xD5,W
04494:  ANDWF  xD2,W
04496:  IORWF  xD1,W
04498:  BCF    xD0.0
0449A:  BTFSC  FE8.0
0449C:  BSF    xD0.0
....................       check = check | ((In.B6 | In2.B6) & ~Ack.B6 & (OutputType.B6 | OutputBoth.B6));
0449E:  MOVLW  00
044A0:  BTFSC  xD0.0
044A2:  MOVLW  01
044A4:  MOVWF  xD1
044A6:  MOVLW  00
044A8:  BTFSC  x85.5
044AA:  MOVLW  01
044AC:  MOVWF  xD3
044AE:  MOVLW  00
044B0:  BTFSC  x87.5
044B2:  MOVLW  01
044B4:  IORWF  xD3,W
044B6:  MOVWF  xD2
044B8:  MOVLW  00
044BA:  BTFSS  x83.5
044BC:  MOVLW  01
044BE:  ANDWF  xD2,F
044C0:  MOVLW  00
044C2:  BTFSC  x7D.5
044C4:  MOVLW  01
044C6:  MOVWF  xD5
044C8:  MOVLW  00
044CA:  BTFSC  x7F.5
044CC:  MOVLW  01
044CE:  IORWF  xD5,W
044D0:  ANDWF  xD2,W
044D2:  IORWF  xD1,W
044D4:  BCF    xD0.0
044D6:  BTFSC  FE8.0
044D8:  BSF    xD0.0
....................       check = check | ((In.B7 | In2.B7) & ~Ack.B7 & (OutputType.B7 | OutputBoth.B7));
044DA:  MOVLW  00
044DC:  BTFSC  xD0.0
044DE:  MOVLW  01
044E0:  MOVWF  xD1
044E2:  MOVLW  00
044E4:  BTFSC  x85.6
044E6:  MOVLW  01
044E8:  MOVWF  xD3
044EA:  MOVLW  00
044EC:  BTFSC  x87.6
044EE:  MOVLW  01
044F0:  IORWF  xD3,W
044F2:  MOVWF  xD2
044F4:  MOVLW  00
044F6:  BTFSS  x83.6
044F8:  MOVLW  01
044FA:  ANDWF  xD2,F
044FC:  MOVLW  00
044FE:  BTFSC  x7D.6
04500:  MOVLW  01
04502:  MOVWF  xD5
04504:  MOVLW  00
04506:  BTFSC  x7F.6
04508:  MOVLW  01
0450A:  IORWF  xD5,W
0450C:  ANDWF  xD2,W
0450E:  IORWF  xD1,W
04510:  BCF    xD0.0
04512:  BTFSC  FE8.0
04514:  BSF    xD0.0
....................       check = check | ((In.B8 | In2.B8) & ~Ack.B8 & (OutputType.B8 | OutputBoth.B8));
04516:  MOVLW  00
04518:  BTFSC  xD0.0
0451A:  MOVLW  01
0451C:  MOVWF  xD1
0451E:  MOVLW  00
04520:  BTFSC  x85.7
04522:  MOVLW  01
04524:  MOVWF  xD3
04526:  MOVLW  00
04528:  BTFSC  x87.7
0452A:  MOVLW  01
0452C:  IORWF  xD3,W
0452E:  MOVWF  xD2
04530:  MOVLW  00
04532:  BTFSS  x83.7
04534:  MOVLW  01
04536:  ANDWF  xD2,F
04538:  MOVLW  00
0453A:  BTFSC  x7D.7
0453C:  MOVLW  01
0453E:  MOVWF  xD5
04540:  MOVLW  00
04542:  BTFSC  x7F.7
04544:  MOVLW  01
04546:  IORWF  xD5,W
04548:  ANDWF  xD2,W
0454A:  IORWF  xD1,W
0454C:  BCF    xD0.0
0454E:  BTFSC  FE8.0
04550:  BSF    xD0.0
....................       check = check | ((In.B9 | In2.B9) & ~Ack.B9 & (OutputType.B9 | OutputBoth.B9));
04552:  MOVLW  00
04554:  BTFSC  xD0.0
04556:  MOVLW  01
04558:  MOVWF  xD1
0455A:  MOVLW  00
0455C:  BTFSC  x86.0
0455E:  MOVLW  01
04560:  MOVWF  xD3
04562:  MOVLW  00
04564:  BTFSC  x88.0
04566:  MOVLW  01
04568:  IORWF  xD3,W
0456A:  MOVWF  xD2
0456C:  MOVLW  00
0456E:  BTFSS  x84.0
04570:  MOVLW  01
04572:  ANDWF  xD2,F
04574:  MOVLW  00
04576:  BTFSC  x7E.0
04578:  MOVLW  01
0457A:  MOVWF  xD5
0457C:  MOVLW  00
0457E:  BTFSC  x80.0
04580:  MOVLW  01
04582:  IORWF  xD5,W
04584:  ANDWF  xD2,W
04586:  IORWF  xD1,W
04588:  BCF    xD0.0
0458A:  BTFSC  FE8.0
0458C:  BSF    xD0.0
....................       check = check | ((In.B10 | In2.B10) & ~Ack.B10 & (OutputType.B10 | OutputBoth.B10));
0458E:  MOVLW  00
04590:  BTFSC  xD0.0
04592:  MOVLW  01
04594:  MOVWF  xD1
04596:  MOVLW  00
04598:  BTFSC  x86.1
0459A:  MOVLW  01
0459C:  MOVWF  xD3
0459E:  MOVLW  00
045A0:  BTFSC  x88.1
045A2:  MOVLW  01
045A4:  IORWF  xD3,W
045A6:  MOVWF  xD2
045A8:  MOVLW  00
045AA:  BTFSS  x84.1
045AC:  MOVLW  01
045AE:  ANDWF  xD2,F
045B0:  MOVLW  00
045B2:  BTFSC  x7E.1
045B4:  MOVLW  01
045B6:  MOVWF  xD5
045B8:  MOVLW  00
045BA:  BTFSC  x80.1
045BC:  MOVLW  01
045BE:  IORWF  xD5,W
045C0:  ANDWF  xD2,W
045C2:  IORWF  xD1,W
045C4:  BCF    xD0.0
045C6:  BTFSC  FE8.0
045C8:  BSF    xD0.0
.................... 
....................    }
045CA:  BRA    4822
....................    else if(DatType == 0x02)             //Bell
045CC:  MOVF   xCF,W
045CE:  SUBLW  02
045D0:  BTFSS  FD8.2
045D2:  BRA    4822
....................    {
....................       check = (In.B1 | In2.B1) & ~Ack.B1 & (~OutputType.B1 | OutputBoth.B1);
045D4:  MOVLW  00
045D6:  BTFSC  x85.0
045D8:  MOVLW  01
045DA:  MOVWF  xD2
045DC:  MOVLW  00
045DE:  BTFSC  x87.0
045E0:  MOVLW  01
045E2:  IORWF  xD2,W
045E4:  MOVWF  xD1
045E6:  MOVLW  00
045E8:  BTFSS  x83.0
045EA:  MOVLW  01
045EC:  ANDWF  xD1,F
045EE:  MOVLW  00
045F0:  BTFSS  x7D.0
045F2:  MOVLW  01
045F4:  MOVWF  xD4
045F6:  MOVLW  00
045F8:  BTFSC  x7F.0
045FA:  MOVLW  01
045FC:  IORWF  xD4,W
045FE:  ANDWF  xD1,W
04600:  BCF    xD0.0
04602:  BTFSC  FE8.0
04604:  BSF    xD0.0
....................       check = check | ((In.B2 | In2.B2) & ~Ack.B2 & (~OutputType.B2 | OutputBoth.B2));
04606:  MOVLW  00
04608:  BTFSC  xD0.0
0460A:  MOVLW  01
0460C:  MOVWF  xD1
0460E:  MOVLW  00
04610:  BTFSC  x85.1
04612:  MOVLW  01
04614:  MOVWF  xD3
04616:  MOVLW  00
04618:  BTFSC  x87.1
0461A:  MOVLW  01
0461C:  IORWF  xD3,W
0461E:  MOVWF  xD2
04620:  MOVLW  00
04622:  BTFSS  x83.1
04624:  MOVLW  01
04626:  ANDWF  xD2,F
04628:  MOVLW  00
0462A:  BTFSS  x7D.1
0462C:  MOVLW  01
0462E:  MOVWF  xD5
04630:  MOVLW  00
04632:  BTFSC  x7F.1
04634:  MOVLW  01
04636:  IORWF  xD5,W
04638:  ANDWF  xD2,W
0463A:  IORWF  xD1,W
0463C:  BCF    xD0.0
0463E:  BTFSC  FE8.0
04640:  BSF    xD0.0
....................       check = check | ((In.B3 | In2.B3) & ~Ack.B3 & (~OutputType.B3 | OutputBoth.B3));
04642:  MOVLW  00
04644:  BTFSC  xD0.0
04646:  MOVLW  01
04648:  MOVWF  xD1
0464A:  MOVLW  00
0464C:  BTFSC  x85.2
0464E:  MOVLW  01
04650:  MOVWF  xD3
04652:  MOVLW  00
04654:  BTFSC  x87.2
04656:  MOVLW  01
04658:  IORWF  xD3,W
0465A:  MOVWF  xD2
0465C:  MOVLW  00
0465E:  BTFSS  x83.2
04660:  MOVLW  01
04662:  ANDWF  xD2,F
04664:  MOVLW  00
04666:  BTFSS  x7D.2
04668:  MOVLW  01
0466A:  MOVWF  xD5
0466C:  MOVLW  00
0466E:  BTFSC  x7F.2
04670:  MOVLW  01
04672:  IORWF  xD5,W
04674:  ANDWF  xD2,W
04676:  IORWF  xD1,W
04678:  BCF    xD0.0
0467A:  BTFSC  FE8.0
0467C:  BSF    xD0.0
....................       check = check | ((In.B4 | In2.B4) & ~Ack.B4 & (~OutputType.B4 | OutputBoth.B4));
0467E:  MOVLW  00
04680:  BTFSC  xD0.0
04682:  MOVLW  01
04684:  MOVWF  xD1
04686:  MOVLW  00
04688:  BTFSC  x85.3
0468A:  MOVLW  01
0468C:  MOVWF  xD3
0468E:  MOVLW  00
04690:  BTFSC  x87.3
04692:  MOVLW  01
04694:  IORWF  xD3,W
04696:  MOVWF  xD2
04698:  MOVLW  00
0469A:  BTFSS  x83.3
0469C:  MOVLW  01
0469E:  ANDWF  xD2,F
046A0:  MOVLW  00
046A2:  BTFSS  x7D.3
046A4:  MOVLW  01
046A6:  MOVWF  xD5
046A8:  MOVLW  00
046AA:  BTFSC  x7F.3
046AC:  MOVLW  01
046AE:  IORWF  xD5,W
046B0:  ANDWF  xD2,W
046B2:  IORWF  xD1,W
046B4:  BCF    xD0.0
046B6:  BTFSC  FE8.0
046B8:  BSF    xD0.0
....................       check = check | ((In.B5 | In2.B5) & ~Ack.B5 & (~OutputType.B5 | OutputBoth.B5));
046BA:  MOVLW  00
046BC:  BTFSC  xD0.0
046BE:  MOVLW  01
046C0:  MOVWF  xD1
046C2:  MOVLW  00
046C4:  BTFSC  x85.4
046C6:  MOVLW  01
046C8:  MOVWF  xD3
046CA:  MOVLW  00
046CC:  BTFSC  x87.4
046CE:  MOVLW  01
046D0:  IORWF  xD3,W
046D2:  MOVWF  xD2
046D4:  MOVLW  00
046D6:  BTFSS  x83.4
046D8:  MOVLW  01
046DA:  ANDWF  xD2,F
046DC:  MOVLW  00
046DE:  BTFSS  x7D.4
046E0:  MOVLW  01
046E2:  MOVWF  xD5
046E4:  MOVLW  00
046E6:  BTFSC  x7F.4
046E8:  MOVLW  01
046EA:  IORWF  xD5,W
046EC:  ANDWF  xD2,W
046EE:  IORWF  xD1,W
046F0:  BCF    xD0.0
046F2:  BTFSC  FE8.0
046F4:  BSF    xD0.0
....................       check = check | ((In.B6 | In2.B6) & ~Ack.B6 & (~OutputType.B6 | OutputBoth.B6));
046F6:  MOVLW  00
046F8:  BTFSC  xD0.0
046FA:  MOVLW  01
046FC:  MOVWF  xD1
046FE:  MOVLW  00
04700:  BTFSC  x85.5
04702:  MOVLW  01
04704:  MOVWF  xD3
04706:  MOVLW  00
04708:  BTFSC  x87.5
0470A:  MOVLW  01
0470C:  IORWF  xD3,W
0470E:  MOVWF  xD2
04710:  MOVLW  00
04712:  BTFSS  x83.5
04714:  MOVLW  01
04716:  ANDWF  xD2,F
04718:  MOVLW  00
0471A:  BTFSS  x7D.5
0471C:  MOVLW  01
0471E:  MOVWF  xD5
04720:  MOVLW  00
04722:  BTFSC  x7F.5
04724:  MOVLW  01
04726:  IORWF  xD5,W
04728:  ANDWF  xD2,W
0472A:  IORWF  xD1,W
0472C:  BCF    xD0.0
0472E:  BTFSC  FE8.0
04730:  BSF    xD0.0
....................       check = check | ((In.B7 | In2.B7) & ~Ack.B7 & (~OutputType.B7 | OutputBoth.B7));
04732:  MOVLW  00
04734:  BTFSC  xD0.0
04736:  MOVLW  01
04738:  MOVWF  xD1
0473A:  MOVLW  00
0473C:  BTFSC  x85.6
0473E:  MOVLW  01
04740:  MOVWF  xD3
04742:  MOVLW  00
04744:  BTFSC  x87.6
04746:  MOVLW  01
04748:  IORWF  xD3,W
0474A:  MOVWF  xD2
0474C:  MOVLW  00
0474E:  BTFSS  x83.6
04750:  MOVLW  01
04752:  ANDWF  xD2,F
04754:  MOVLW  00
04756:  BTFSS  x7D.6
04758:  MOVLW  01
0475A:  MOVWF  xD5
0475C:  MOVLW  00
0475E:  BTFSC  x7F.6
04760:  MOVLW  01
04762:  IORWF  xD5,W
04764:  ANDWF  xD2,W
04766:  IORWF  xD1,W
04768:  BCF    xD0.0
0476A:  BTFSC  FE8.0
0476C:  BSF    xD0.0
....................       check = check | ((In.B8 | In2.B8) & ~Ack.B8 & (~OutputType.B8 | OutputBoth.B8));
0476E:  MOVLW  00
04770:  BTFSC  xD0.0
04772:  MOVLW  01
04774:  MOVWF  xD1
04776:  MOVLW  00
04778:  BTFSC  x85.7
0477A:  MOVLW  01
0477C:  MOVWF  xD3
0477E:  MOVLW  00
04780:  BTFSC  x87.7
04782:  MOVLW  01
04784:  IORWF  xD3,W
04786:  MOVWF  xD2
04788:  MOVLW  00
0478A:  BTFSS  x83.7
0478C:  MOVLW  01
0478E:  ANDWF  xD2,F
04790:  MOVLW  00
04792:  BTFSS  x7D.7
04794:  MOVLW  01
04796:  MOVWF  xD5
04798:  MOVLW  00
0479A:  BTFSC  x7F.7
0479C:  MOVLW  01
0479E:  IORWF  xD5,W
047A0:  ANDWF  xD2,W
047A2:  IORWF  xD1,W
047A4:  BCF    xD0.0
047A6:  BTFSC  FE8.0
047A8:  BSF    xD0.0
....................       check = check | ((In.B9 | In2.B9) & ~Ack.B9 & (~OutputType.B9 | OutputBoth.B9));
047AA:  MOVLW  00
047AC:  BTFSC  xD0.0
047AE:  MOVLW  01
047B0:  MOVWF  xD1
047B2:  MOVLW  00
047B4:  BTFSC  x86.0
047B6:  MOVLW  01
047B8:  MOVWF  xD3
047BA:  MOVLW  00
047BC:  BTFSC  x88.0
047BE:  MOVLW  01
047C0:  IORWF  xD3,W
047C2:  MOVWF  xD2
047C4:  MOVLW  00
047C6:  BTFSS  x84.0
047C8:  MOVLW  01
047CA:  ANDWF  xD2,F
047CC:  MOVLW  00
047CE:  BTFSS  x7E.0
047D0:  MOVLW  01
047D2:  MOVWF  xD5
047D4:  MOVLW  00
047D6:  BTFSC  x80.0
047D8:  MOVLW  01
047DA:  IORWF  xD5,W
047DC:  ANDWF  xD2,W
047DE:  IORWF  xD1,W
047E0:  BCF    xD0.0
047E2:  BTFSC  FE8.0
047E4:  BSF    xD0.0
....................       check = check | ((In.B10 | In2.B10) & ~Ack.B10 & (~OutputType.B10 | OutputBoth.B10));
047E6:  MOVLW  00
047E8:  BTFSC  xD0.0
047EA:  MOVLW  01
047EC:  MOVWF  xD1
047EE:  MOVLW  00
047F0:  BTFSC  x86.1
047F2:  MOVLW  01
047F4:  MOVWF  xD3
047F6:  MOVLW  00
047F8:  BTFSC  x88.1
047FA:  MOVLW  01
047FC:  IORWF  xD3,W
047FE:  MOVWF  xD2
04800:  MOVLW  00
04802:  BTFSS  x84.1
04804:  MOVLW  01
04806:  ANDWF  xD2,F
04808:  MOVLW  00
0480A:  BTFSS  x7E.1
0480C:  MOVLW  01
0480E:  MOVWF  xD5
04810:  MOVLW  00
04812:  BTFSC  x80.1
04814:  MOVLW  01
04816:  IORWF  xD5,W
04818:  ANDWF  xD2,W
0481A:  IORWF  xD1,W
0481C:  BCF    xD0.0
0481E:  BTFSC  FE8.0
04820:  BSF    xD0.0
.................... 
....................    }
....................    return(check);
04822:  MOVLW  00
04824:  BTFSC  xD0.0
04826:  MOVLW  01
04828:  MOVWF  01
0482A:  MOVLB  0
0482C:  RETURN 0
.................... }
.................... 
.................... ///////////////////////////////////////////////////////////////////////////////////////////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... 
.................... void main()
*
06236:  CLRF   FF8
06238:  BCF    FD0.7
0623A:  BSF    07.7
0623C:  MOVLW  70
0623E:  MOVWF  FD3
06240:  BCF    F9B.6
06242:  BCF    F9B.7
06244:  BSF    FB8.3
06246:  MOVLW  A0
06248:  MOVWF  FAF
0624A:  MOVLW  01
0624C:  MOVWF  FB0
0624E:  MOVLW  A6
06250:  MOVWF  FAC
06252:  MOVLW  90
06254:  MOVWF  FAB
06256:  BCF    F93.0
06258:  BSF    F8A.0
0625A:  CLRF   1B
0625C:  BCF    1C.0
0625E:  MOVLW  19
06260:  MOVWF  1D
06262:  BCF    1C.1
06264:  MOVLW  64
06266:  MOVWF  1E
06268:  CLRF   1F
0626A:  BCF    1C.2
0626C:  BCF    1C.3
0626E:  BCF    1C.4
06270:  CLRF   30
06272:  BCF    1C.5
06274:  CLRF   31
06276:  BCF    1C.6
06278:  BCF    1C.7
0627A:  BCF    32.0
0627C:  BCF    32.1
0627E:  BCF    32.2
06280:  BCF    32.3
06282:  CLRF   33
06284:  BCF    32.4
06286:  BCF    32.5
06288:  MOVLW  11
0628A:  MOVWF  x66
0628C:  MOVLW  12
0628E:  MOVWF  x67
06290:  MOVLW  13
06292:  MOVWF  x68
06294:  MOVLW  14
06296:  MOVWF  x69
06298:  MOVLW  16
0629A:  MOVWF  x6A
0629C:  MOVLW  17
0629E:  MOVWF  x6B
062A0:  MOVLW  18
062A2:  MOVWF  x6C
062A4:  MOVLW  19
062A6:  MOVWF  x6D
062A8:  MOVLW  20
062AA:  MOVWF  x6E
062AC:  BCF    32.6
062AE:  CLRF   x72
062B0:  CLRF   x71
062B2:  MOVLW  01
062B4:  MOVLB  3
062B6:  MOVWF  x76
062B8:  MOVLW  F4
062BA:  MOVWF  x75
062BC:  CLRF   x78
062BE:  CLRF   x77
062C0:  CLRF   x7A
062C2:  CLRF   x79
062C4:  CLRF   x7B
062C6:  MOVLB  5
062C8:  CLRF   x80
062CA:  CLRF   x7F
062CC:  CLRF   x81
062CE:  MOVLB  7
062D0:  CLRF   xC9
062D2:  CLRF   xC8
062D4:  MOVLB  F
062D6:  CLRF   x38
062D8:  CLRF   x39
062DA:  CLRF   x3A
062DC:  CLRF   F77
062DE:  CLRF   F78
062E0:  CLRF   F79
062E2:  CLRF   19
062E4:  CLRF   1A
062E6:  MOVLW  3E
062E8:  MOVLB  6
062EA:  MOVWF  xD1
062EC:  MOVWF  xD2
062EE:  CLRF   xD3
062F0:  MOVLW  20
062F2:  MOVLB  7
062F4:  MOVWF  x71
062F6:  CLRF   x72
062F8:  MOVLW  3E
062FA:  MOVWF  xC5
062FC:  MOVWF  xC6
062FE:  CLRF   xC7
06300:  CLRF   xCA
06302:  CLRF   xCB
.................... {
....................    
....................    
....................    delay_ms(50);
06304:  MOVLW  32
06306:  MOVWF  xD8
06308:  MOVLB  0
0630A:  CALL   068A
....................    output_bit(Pled,0);   //power on watchdog signal
0630E:  BCF    F8A.5
06310:  BCF    F93.5
.................... 
....................    //jj
....................    //setup_adc_ports(NO_ANALOGS|VSS_VDD);
....................    //setup_adc(ADC_OFF|ADC_TAD_MUL_0);
....................    
....................    //setup_spi(FALSE);
....................    
....................    setup_timer_0(RTCC_INTERNAL);
06312:  MOVLW  80
06314:  MOVWF  FD5
....................    //setup_timer_1(T1_DISABLED);
....................    setup_timer_2(T2_DIV_BY_16,196,16);         //10ms
06316:  MOVLW  78
06318:  IORLW  06
0631A:  MOVWF  FBA
0631C:  MOVLW  C4
0631E:  MOVWF  FBB
....................    setup_timer_1(T1_INTERNAL|T1_DIV_BY_8);    //104ms
06320:  MOVLW  37
06322:  MOVWF  FCD
06324:  CLRF   FCC
....................    //setup_timer_3(T3_DISABLED|T3_DIV_BY_1);
....................    //setup_comparator(NC_NC_NC_NC);
....................    //setup_vref(FALSE);
....................   // enable_interrupts(INT_TIMER1);
....................    enable_interrupts(INT_TIMER2);
06326:  BSF    F9D.1
....................    enable_interrupts(INT_RDA);
06328:  BSF    F9D.5
.................... 
....................    setup_spi(SPI_MASTER  | SPI_L_TO_H | SPI_XMIT_L_TO_H| SPI_CLK_DIV_4 ); //master1
0632A:  BCF    FC6.5
0632C:  BCF    F94.5
0632E:  BSF    F94.4
06330:  BCF    F94.3
06332:  MOVLW  20
06334:  MOVWF  FC6
06336:  MOVLW  40
06338:  MOVWF  FC7
....................  
....................    IO_INIT();   //initializes the MCP23S17 chip.//----------jj
0633A:  GOTO   06EC
....................   
....................    IO_SET_TRIS_A(IO_DEVICE_0, 0xFF); //addr.0 Set PortA As Input
0633E:  MOVLB  7
06340:  CLRF   xCF
06342:  SETF   xD0
06344:  MOVLB  0
06346:  CALL   0782
....................    IO_SET_TRIS_B(IO_DEVICE_0, 0xFF); //addr.0 Set PortB As Input
0634A:  MOVLB  7
0634C:  CLRF   xCF
0634E:  SETF   xD0
06350:  MOVLB  0
06352:  CALL   0794
....................    IO_SET_TRIS_A(IO_DEVICE_1, 0xFF); //addr.1 Set PortA As Input 
06356:  MOVLW  02
06358:  MOVLB  7
0635A:  MOVWF  xCF
0635C:  SETF   xD0
0635E:  MOVLB  0
06360:  CALL   0782
....................    IO_SET_TRIS_B(IO_DEVICE_1, 0xFF); //addr.1 Set PortB As Input
06364:  MOVLW  02
06366:  MOVLB  7
06368:  MOVWF  xCF
0636A:  SETF   xD0
0636C:  MOVLB  0
0636E:  CALL   0794
....................    //  jj
....................    IO_WRITE_REGISTER(IO_DEVICE_0, GPPUA, 0xFF); // Input Pullup
06372:  MOVLB  7
06374:  CLRF   xD9
06376:  MOVLW  06
06378:  MOVWF  xDA
0637A:  SETF   xDB
0637C:  MOVLB  0
0637E:  CALL   06BA
....................    IO_WRITE_REGISTER(IO_DEVICE_0, GPPUB, 0xFF); // Input Pullup
06382:  MOVLB  7
06384:  CLRF   xD9
06386:  MOVLW  16
06388:  MOVWF  xDA
0638A:  SETF   xDB
0638C:  MOVLB  0
0638E:  CALL   06BA
....................    IO_WRITE_REGISTER(IO_DEVICE_1, GPPUA, 0xFF); // Input Pullup
06392:  MOVLW  02
06394:  MOVLB  7
06396:  MOVWF  xD9
06398:  MOVLW  06
0639A:  MOVWF  xDA
0639C:  SETF   xDB
0639E:  MOVLB  0
063A0:  CALL   06BA
....................    IO_WRITE_REGISTER(IO_DEVICE_1, GPPUB, 0xFF); // Input Pullup
063A4:  MOVLW  02
063A6:  MOVLB  7
063A8:  MOVWF  xD9
063AA:  MOVLW  16
063AC:  MOVWF  xDA
063AE:  SETF   xDB
063B0:  MOVLB  0
063B2:  CALL   06BA
....................    //  jj
....................    IO_SET_TRIS_A(IO_DEVICE_2, 0x00); //addr.2 Set PortA As Output 
063B6:  MOVLW  04
063B8:  MOVLB  7
063BA:  MOVWF  xCF
063BC:  CLRF   xD0
063BE:  MOVLB  0
063C0:  CALL   0782
....................    IO_SET_TRIS_B(IO_DEVICE_2, 0x00); //addr.2 Set PortB As Output
063C4:  MOVLW  04
063C6:  MOVLB  7
063C8:  MOVWF  xCF
063CA:  CLRF   xD0
063CC:  MOVLB  0
063CE:  CALL   0794
....................    IO_SET_TRIS_A(IO_DEVICE_3, 0x00); //addr.3 Set PortA As Output 
063D2:  MOVLW  06
063D4:  MOVLB  7
063D6:  MOVWF  xCF
063D8:  CLRF   xD0
063DA:  MOVLB  0
063DC:  CALL   0782
....................    IO_SET_TRIS_B(IO_DEVICE_3, 0x00); //addr.3 Set PortB As Output
063E0:  MOVLW  06
063E2:  MOVLB  7
063E4:  MOVWF  xCF
063E6:  CLRF   xD0
063E8:  MOVLB  0
063EA:  CALL   0794
....................    
....................    
....................    FlashingFlag = 1;
063EE:  BSF    1C.1
....................    sequence = end_sq;
063F0:  MOVFF  66,6F
....................    Address = 1;
063F4:  MOVLW  01
063F6:  MOVWF  x70
.................... 
....................    Output.B1 = 1;
063F8:  MOVLB  7
063FA:  BSF    x77.0
....................    Output.B2 = 1;
063FC:  BSF    x77.1
....................    Output.B3 = 1;
063FE:  BSF    x77.2
....................    Output.B4 = 1;
06400:  BSF    x77.3
....................    Output.B5 = 1;
06402:  BSF    x77.4
....................    Output.B6 = 1;
06404:  BSF    x77.5
....................    Output.B7 = 1;
06406:  BSF    x77.6
....................    Output.B8 = 1;
06408:  BSF    x77.7
....................    Output.B9 = 1;
0640A:  BSF    x78.0
....................    Output.B10 = 1;
0640C:  BSF    x78.1
.................... 
....................    ////////////////////
....................    In.B1 = 0;
0640E:  BCF    x85.0
....................    In.B2 = 0;
06410:  BCF    x85.1
....................    In.B3 = 0;
06412:  BCF    x85.2
....................    In.B4 = 0;
06414:  BCF    x85.3
....................    In.B5 = 0;
06416:  BCF    x85.4
....................    In.B6 = 0;
06418:  BCF    x85.5
....................    In.B7 = 0;
0641A:  BCF    x85.6
....................    In.B8 = 0;
0641C:  BCF    x85.7
....................    In.B9 = 0;
0641E:  BCF    x86.0
....................    In.B10 = 0;
06420:  BCF    x86.1
.................... 
....................    ////////////////////////
....................    Ack.B1 = 0;
06422:  BCF    x83.0
....................    Ack.B2 = 0;
06424:  BCF    x83.1
....................    Ack.B3 = 0;
06426:  BCF    x83.2
....................    Ack.B4 = 0;
06428:  BCF    x83.3
....................    Ack.B5 = 0;
0642A:  BCF    x83.4
....................    Ack.B6 = 0;
0642C:  BCF    x83.5
....................    Ack.B7 = 0;
0642E:  BCF    x83.6
....................    Ack.B8 = 0;
06430:  BCF    x83.7
....................    Ack.B9 = 0;
06432:  BCF    x84.0
....................    Ack.B10 = 0;
06434:  BCF    x84.1
.................... 
....................     /////// read setting //////////
.................... 
....................    if(read_eeprom(0x00) == 0x0F)
06436:  MOVFF  FF2,7CF
0643A:  BCF    FF2.7
0643C:  CLRF   FAA
0643E:  CLRF   FA9
06440:  BCF    FA6.6
06442:  BCF    FA6.7
06444:  BSF    FA6.0
06446:  MOVF   FA8,W
06448:  BTFSC  xCF.7
0644A:  BSF    FF2.7
0644C:  SUBLW  0F
0644E:  BNZ   645A
....................    {
....................       Read_Config();
06450:  MOVLB  0
06452:  CALL   07A8
....................    }
06456:  BRA    667E
06458:  MOVLB  7
....................    else
....................    {
....................       FlashingRateTime = 25;
0645A:  MOVLW  19
0645C:  MOVWF  1D
....................       AutoAck = 0xF0; //not use auto ack
0645E:  MOVLW  F0
06460:  MOVLB  0
06462:  MOVWF  x60
....................       Address = 0x01;
06464:  MOVLW  01
06466:  MOVWF  x70
.................... 
....................       AutoAckTime = 5;
06468:  MOVLW  05
0646A:  MOVWF  x61
....................       FlashingRate = 25;
0646C:  MOVLW  19
0646E:  MOVWF  x62
....................       NoOfPoint = 10;
06470:  MOVLW  0A
06472:  MOVWF  x63
....................       char i;
....................       for(i =0; i<=NoOfPoint; i++)
06474:  MOVLB  7
06476:  CLRF   xCC
06478:  MOVF   xCC,W
0647A:  MOVLB  0
0647C:  SUBWF  x63,W
0647E:  BNC   649E
....................       {
....................          FaultDelayTime[i] = 0;
06480:  BCF    FD8.0
06482:  MOVLB  7
06484:  RLCF   xCC,W
06486:  CLRF   03
06488:  ADDLW  AD
0648A:  MOVWF  FE9
0648C:  MOVLW  07
0648E:  ADDWFC 03,W
06490:  MOVWF  FEA
06492:  CLRF   FEC
06494:  MOVF   FED,F
06496:  CLRF   FEF
06498:  INCF   xCC,F
0649A:  BRA    6478
0649C:  MOVLB  0
....................       }
.................... 
....................       InputType.B1 = 1;
0649E:  MOVLB  7
064A0:  BSF    x79.0
....................       InputType.B2 = 1;
064A2:  BSF    x79.1
....................       InputType.B3 = 1;
064A4:  BSF    x79.2
....................       InputType.B4 = 1;
064A6:  BSF    x79.3
....................       InputType.B5 = 1;
064A8:  BSF    x79.4
....................       InputType.B6 = 1;
064AA:  BSF    x79.5
....................       InputType.B7 = 1;
064AC:  BSF    x79.6
....................       InputType.B8 = 1;
064AE:  BSF    x79.7
....................       InputType.B9 = 1;
064B0:  BSF    x7A.0
....................       InputType.B10 = 1;
064B2:  BSF    x7A.1
.................... 
....................       FaultNCNO[1] = 1;
064B4:  BSF    xC3.1
....................       FaultNCNO[2] = 1;
064B6:  BSF    xC3.2
....................       FaultNCNO[3] = 1;
064B8:  BSF    xC3.3
....................       FaultNCNO[4] = 1;
064BA:  BSF    xC3.4
....................       FaultNCNO[5] = 1;
064BC:  BSF    xC3.5
....................       FaultNCNO[6] = 1;
064BE:  BSF    xC3.6
....................       FaultNCNO[7] = 1;
064C0:  BSF    xC3.7
....................       FaultNCNO[8] = 1;
064C2:  BSF    xC4.0
....................       FaultNCNO[9] = 1;
064C4:  BSF    xC4.1
....................       FaultNCNO[10] = 1;
064C6:  BSF    xC4.2
....................       
....................       /////////////////////////////
....................       FaultType.B1 = 1;
064C8:  BSF    x7B.0
....................       FaultType.B2= 1;
064CA:  BSF    x7B.1
....................       FaultType.B3 = 1;
064CC:  BSF    x7B.2
....................       FaultType.B4 = 1;
064CE:  BSF    x7B.3
....................       FaultType.B5 = 1;
064D0:  BSF    x7B.4
....................       FaultType.B6 = 1;
064D2:  BSF    x7B.5
....................       FaultType.B7 = 1;
064D4:  BSF    x7B.6
....................       FaultType.B8 = 1;
064D6:  BSF    x7B.7
....................       FaultType.B9 = 1;
064D8:  BSF    x7C.0
....................       FaultType.B10 = 1;
064DA:  BSF    x7C.1
.................... 
....................       ////////////////////////////
....................       OutputType.B1 = 1;
064DC:  BSF    x7D.0
....................       OutputType.B2 = 1;
064DE:  BSF    x7D.1
....................       OutputType.B3 = 1;
064E0:  BSF    x7D.2
....................       OutputType.B4 = 1;
064E2:  BSF    x7D.3
....................       OutputType.B5 = 1;
064E4:  BSF    x7D.4
....................       OutputType.B6 = 1;
064E6:  BSF    x7D.5
....................       OutputType.B7 = 1;
064E8:  BSF    x7D.6
....................       OutputType.B8 = 1;
064EA:  BSF    x7D.7
....................       OutputType.B9 = 1;
064EC:  BSF    x7E.0
....................       OutputType.B10 = 1;
064EE:  BSF    x7E.1
.................... 
....................       /////////////////////////////
....................       OutputBoth.B1 = 1;
064F0:  BSF    x7F.0
....................       OutputBoth.B2 = 1;
064F2:  BSF    x7F.1
....................       OutputBoth.B3 = 1;
064F4:  BSF    x7F.2
....................       OutputBoth.B4 = 1;
064F6:  BSF    x7F.3
....................       OutputBoth.B5 = 1;
064F8:  BSF    x7F.4
....................       OutputBoth.B6 = 1;
064FA:  BSF    x7F.5
....................       OutputBoth.B7 = 1;
064FC:  BSF    x7F.6
....................       OutputBoth.B8 = 1;
064FE:  BSF    x7F.7
....................       OutputBoth.B9 = 1;
06500:  BSF    x80.0
....................       OutputBoth.B10 = 1;
06502:  BSF    x80.1
.................... 
....................       //////////////////////////////////////////////
....................       AlarmIndicator.B1 = 1;
06504:  BSF    x81.0
....................       AlarmIndicator.B2 = 1;
06506:  BSF    x81.1
....................       AlarmIndicator.B3 = 1;
06508:  BSF    x81.2
....................       AlarmIndicator.B4 = 1;
0650A:  BSF    x81.3
....................       AlarmIndicator.B5 = 1;
0650C:  BSF    x81.4
....................       AlarmIndicator.B6 = 1;
0650E:  BSF    x81.5
....................       AlarmIndicator.B7 = 1;
06510:  BSF    x81.6
....................       AlarmIndicator.B8 = 1;
06512:  BSF    x81.7
....................       AlarmIndicator.B9 = 1;
06514:  BSF    x82.0
....................       AlarmIndicator.B10 = 1;
06516:  BSF    x82.1
.................... 
....................       ///////////// JACK///////////////////
....................       EEpDat = read_eeprom(0x10);
06518:  MOVFF  FF2,7CF
0651C:  BCF    FF2.7
0651E:  CLRF   FAA
06520:  MOVLW  10
06522:  MOVWF  FA9
06524:  BCF    FA6.6
06526:  BCF    FA6.7
06528:  BSF    FA6.0
0652A:  MOVF   FA8,W
0652C:  BTFSC  xCF.7
0652E:  BSF    FF2.7
06530:  MOVWF  3C
....................       //Red1_8 = EEpDat;
....................       RED_Colour.B1 = EEpDat;
06532:  BCF    x8D.0
06534:  BTFSC  3C.0
06536:  BSF    x8D.0
....................       RED_Colour.B2 = EEpDat >> 1;
06538:  BCF    FD8.0
0653A:  RRCF   3C,W
0653C:  BCF    x8D.1
0653E:  BTFSC  FE8.0
06540:  BSF    x8D.1
....................       RED_Colour.B3 = EEpDat >> 2;
06542:  RRCF   3C,W
06544:  MOVWF  00
06546:  RRCF   00,F
06548:  MOVLW  3F
0654A:  ANDWF  00,F
0654C:  BCF    x8D.2
0654E:  BTFSC  00.0
06550:  BSF    x8D.2
....................       RED_Colour.B4 = EEpDat >> 3;
06552:  RRCF   3C,W
06554:  MOVWF  00
06556:  RRCF   00,F
06558:  RRCF   00,F
0655A:  MOVLW  1F
0655C:  ANDWF  00,F
0655E:  BCF    x8D.3
06560:  BTFSC  00.0
06562:  BSF    x8D.3
....................       RED_Colour.B5 = EEpDat >> 4;
06564:  SWAPF  3C,W
06566:  MOVWF  00
06568:  MOVLW  0F
0656A:  ANDWF  00,F
0656C:  BCF    x8D.4
0656E:  BTFSC  00.0
06570:  BSF    x8D.4
....................       RED_Colour.B6 = EEpDat >> 5;
06572:  SWAPF  3C,W
06574:  MOVWF  00
06576:  RRCF   00,F
06578:  MOVLW  07
0657A:  ANDWF  00,F
0657C:  BCF    x8D.5
0657E:  BTFSC  00.0
06580:  BSF    x8D.5
....................       RED_Colour.B7 = EEpDat >> 6;
06582:  SWAPF  3C,W
06584:  MOVWF  00
06586:  RRCF   00,F
06588:  RRCF   00,F
0658A:  MOVLW  03
0658C:  ANDWF  00,F
0658E:  BCF    x8D.6
06590:  BTFSC  00.0
06592:  BSF    x8D.6
....................       RED_Colour.B8 = EEpDat >> 7;
06594:  CLRF   00
06596:  BTFSC  3C.7
06598:  BSF    00.0
0659A:  BCF    x8D.7
0659C:  BTFSC  00.0
0659E:  BSF    x8D.7
....................       
....................       EEpDat = read_eeprom(0x11);
065A0:  MOVFF  FF2,7CF
065A4:  BCF    FF2.7
065A6:  CLRF   FAA
065A8:  MOVLW  11
065AA:  MOVWF  FA9
065AC:  BCF    FA6.6
065AE:  BCF    FA6.7
065B0:  BSF    FA6.0
065B2:  MOVF   FA8,W
065B4:  BTFSC  xCF.7
065B6:  BSF    FF2.7
065B8:  MOVWF  3C
....................       //Green9_10 = EEpDat;
....................       RED_Colour.B9 = EEpDat;
065BA:  BCF    x8E.0
065BC:  BTFSC  3C.0
065BE:  BSF    x8E.0
....................       RED_Colour.B10 = EEpDat >> 1;
065C0:  BCF    FD8.0
065C2:  RRCF   3C,W
065C4:  BCF    x8E.1
065C6:  BTFSC  FE8.0
065C8:  BSF    x8E.1
....................           
....................       EEpDat = read_eeprom(0x14);
065CA:  MOVFF  FF2,7CF
065CE:  BCF    FF2.7
065D0:  CLRF   FAA
065D2:  MOVLW  14
065D4:  MOVWF  FA9
065D6:  BCF    FA6.6
065D8:  BCF    FA6.7
065DA:  BSF    FA6.0
065DC:  MOVF   FA8,W
065DE:  BTFSC  xCF.7
065E0:  BSF    FF2.7
065E2:  MOVWF  3C
....................       //Green1_8 = EEpDat;
....................       GREEN_Colour.B1 = EEpDat;
065E4:  BCF    x8F.0
065E6:  BTFSC  3C.0
065E8:  BSF    x8F.0
....................       GREEN_Colour.B2 = EEpDat >> 1;
065EA:  BCF    FD8.0
065EC:  RRCF   3C,W
065EE:  BCF    x8F.1
065F0:  BTFSC  FE8.0
065F2:  BSF    x8F.1
....................       GREEN_Colour.B3 = EEpDat >> 2;
065F4:  RRCF   3C,W
065F6:  MOVWF  00
065F8:  RRCF   00,F
065FA:  MOVLW  3F
065FC:  ANDWF  00,F
065FE:  BCF    x8F.2
06600:  BTFSC  00.0
06602:  BSF    x8F.2
....................       GREEN_Colour.B4 = EEpDat >> 3;
06604:  RRCF   3C,W
06606:  MOVWF  00
06608:  RRCF   00,F
0660A:  RRCF   00,F
0660C:  MOVLW  1F
0660E:  ANDWF  00,F
06610:  BCF    x8F.3
06612:  BTFSC  00.0
06614:  BSF    x8F.3
....................       GREEN_Colour.B5 = EEpDat >> 4;
06616:  SWAPF  3C,W
06618:  MOVWF  00
0661A:  MOVLW  0F
0661C:  ANDWF  00,F
0661E:  BCF    x8F.4
06620:  BTFSC  00.0
06622:  BSF    x8F.4
....................       GREEN_Colour.B6 = EEpDat >> 5;
06624:  SWAPF  3C,W
06626:  MOVWF  00
06628:  RRCF   00,F
0662A:  MOVLW  07
0662C:  ANDWF  00,F
0662E:  BCF    x8F.5
06630:  BTFSC  00.0
06632:  BSF    x8F.5
....................       GREEN_Colour.B7 = EEpDat >> 6;
06634:  SWAPF  3C,W
06636:  MOVWF  00
06638:  RRCF   00,F
0663A:  RRCF   00,F
0663C:  MOVLW  03
0663E:  ANDWF  00,F
06640:  BCF    x8F.6
06642:  BTFSC  00.0
06644:  BSF    x8F.6
....................       GREEN_Colour.B8 = EEpDat >> 7;
06646:  CLRF   00
06648:  BTFSC  3C.7
0664A:  BSF    00.0
0664C:  BCF    x8F.7
0664E:  BTFSC  00.0
06650:  BSF    x8F.7
....................       
....................       EEpDat = read_eeprom(0x15);
06652:  MOVFF  FF2,7CF
06656:  BCF    FF2.7
06658:  CLRF   FAA
0665A:  MOVLW  15
0665C:  MOVWF  FA9
0665E:  BCF    FA6.6
06660:  BCF    FA6.7
06662:  BSF    FA6.0
06664:  MOVF   FA8,W
06666:  BTFSC  xCF.7
06668:  BSF    FF2.7
0666A:  MOVWF  3C
....................       //Green9_10 = EEpDat;
....................       GREEN_Colour.B9 = EEpDat;
0666C:  BCF    x90.0
0666E:  BTFSC  3C.0
06670:  BSF    x90.0
....................       GREEN_Colour.B10 = EEpDat >> 1;
06672:  BCF    FD8.0
06674:  RRCF   3C,W
06676:  BCF    x90.1
06678:  BTFSC  FE8.0
0667A:  BSF    x90.1
0667C:  MOVLB  0
....................    ///////////// JACK/////////////////////////////////////
....................       
....................    }
....................    
....................   
....................    set_tris_a (0b00000000); //PORTA SET TO OUTPUT
0667E:  MOVLW  00
06680:  MOVWF  F92
....................    set_tris_b (0b00000000); //PORTA SET TO OUTPUT
06682:  MOVWF  F93
....................    enable_interrupts(GLOBAL);
06684:  MOVLW  C0
06686:  IORWF  FF2,F
....................    setup_wdt(WDT_ON);
06688:  BSF    FD1.0
....................    Read_input(); restart_wdt();
0668A:  CALL   16D2
0668E:  CLRWDT
....................    output_bit(Pbuzzer,0);   //Clear Buzzer
06690:  BCF    F89.4
06692:  BCF    F92.4
....................    output_bit(Pbell,0);     //Clear Bell
06694:  BCF    F89.3
06696:  BCF    F92.3
....................    output_bit(P485ctrl,0);
06698:  BCF    F8A.3
0669A:  BCF    F93.3
....................    //output_bit(PIN_B4,1); //jj
....................    //Send_Ouput();
....................    IO_OUTPUT_A(IO_DEVICE_2, 0xff);
0669C:  MOVLW  04
0669E:  MOVLB  7
066A0:  MOVWF  xD7
066A2:  SETF   xD8
066A4:  MOVLB  0
066A6:  CALL   1EBE
....................    IO_OUTPUT_B(IO_DEVICE_2, 0xff);
066AA:  MOVLW  04
066AC:  MOVLB  7
066AE:  MOVWF  xD7
066B0:  SETF   xD8
066B2:  MOVLB  0
066B4:  CALL   1ED4
....................             
....................    IO_OUTPUT_A(IO_DEVICE_3, 0xff);
066B8:  MOVLW  06
066BA:  MOVLB  7
066BC:  MOVWF  xD7
066BE:  SETF   xD8
066C0:  MOVLB  0
066C2:  CALL   1EBE
....................    IO_OUTPUT_B(IO_DEVICE_3, 0xff);
066C6:  MOVLW  06
066C8:  MOVLB  7
066CA:  MOVWF  xD7
066CC:  SETF   xD8
066CE:  MOVLB  0
066D0:  CALL   1ED4
....................   
....................    //IO_OUTPUT_A(IO_DEVICE_5, 0xff);  
....................    //IO_OUTPUT_B(IO_DEVICE_5, 0xff);         
....................    //IO_OUTPUT_A(IO_DEVICE_4, 0xff);
....................    //IO_OUTPUT_B(IO_DEVICE_4, 0xff);
....................    
....................    delay_ms(500);
066D4:  MOVLW  02
066D6:  MOVLB  7
066D8:  MOVWF  xCF
066DA:  MOVLW  FA
066DC:  MOVWF  xD8
066DE:  MOVLB  0
066E0:  CALL   068A
066E4:  MOVLB  7
066E6:  DECFSZ xCF,F
066E8:  BRA    66DA
....................    
....................    // jj
....................    char i;
....................    for(i=1;i<=10;i++)
066EA:  MOVLW  01
066EC:  MOVWF  xCD
066EE:  MOVF   xCD,W
066F0:  SUBLW  0A
066F2:  BTFSS  FD8.0
066F4:  BRA    67FA
....................    {
....................       FaultAgo[i] = 0;
066F6:  MOVFF  7CD,7D3
066FA:  CLRF   xD4
066FC:  MOVLW  07
066FE:  MOVWF  xD6
06700:  MOVLW  93
06702:  MOVWF  xD5
06704:  MOVLB  0
06706:  CALL   1634
....................       FaultNow[i] = 0;
0670A:  MOVFF  7CD,7D3
0670E:  MOVLB  7
06710:  CLRF   xD4
06712:  MOVLW  07
06714:  MOVWF  xD6
06716:  MOVLW  95
06718:  MOVWF  xD5
0671A:  MOVLB  0
0671C:  CALL   1634
....................       ReleaseTime[i] = 0;
06720:  BCF    FD8.0
06722:  MOVLB  7
06724:  RLCF   xCD,W
06726:  CLRF   03
06728:  ADDLW  97
0672A:  MOVWF  FE9
0672C:  MOVLW  07
0672E:  ADDWFC 03,W
06730:  MOVWF  FEA
06732:  CLRF   FEC
06734:  MOVF   FED,F
06736:  CLRF   FEF
....................       
....................       if(FaultNCNO[i] ==NO)
06738:  MOVFF  7CD,7D3
0673C:  MOVLW  07
0673E:  MOVWF  xD5
06740:  MOVLW  C3
06742:  MOVWF  xD4
06744:  MOVLB  0
06746:  CALL   15DC
0674A:  MOVF   01,W
0674C:  ANDLW  01
0674E:  SUBLW  01
06750:  BNZ   67A6
....................       {
....................          switch(i)
06752:  MOVLW  01
06754:  MOVLB  7
06756:  SUBWF  xCD,W
06758:  ADDLW  F6
0675A:  BC    67A2
0675C:  ADDLW  0A
0675E:  MOVLB  0
06760:  GOTO   6A18
....................          {
....................             case 1:
....................                Inputt.B1 = 0; 
06764:  MOVLB  7
06766:  BCF    x75.0
....................             break;
06768:  BRA    67A2
....................             case 2:
....................                Inputt.B2 = 0; 
0676A:  MOVLB  7
0676C:  BCF    x75.1
....................             break;
0676E:  BRA    67A2
....................             case 3:
....................                Inputt.B3 = 0; 
06770:  MOVLB  7
06772:  BCF    x75.2
....................             break;
06774:  BRA    67A2
....................             case 4:
....................                Inputt.B4 = 0; 
06776:  MOVLB  7
06778:  BCF    x75.3
....................             break;
0677A:  BRA    67A2
....................             case 5:
....................                Inputt.B5 = 0; 
0677C:  MOVLB  7
0677E:  BCF    x75.4
....................             break;
06780:  BRA    67A2
....................             case 6:
....................                Inputt.B6 = 0; 
06782:  MOVLB  7
06784:  BCF    x75.5
....................             break;
06786:  BRA    67A2
....................             case 7:
....................                Inputt.B7 = 0; 
06788:  MOVLB  7
0678A:  BCF    x75.6
....................              break;
0678C:  BRA    67A2
....................              case 8:
....................                Inputt.B8 = 0; 
0678E:  MOVLB  7
06790:  BCF    x75.7
....................             break;
06792:  BRA    67A2
....................             case 9:
....................                Inputt.B9 = 0; 
06794:  MOVLB  7
06796:  BCF    x76.0
....................             break;
06798:  BRA    67A2
....................             case 10:
....................                Inputt.B10 = 0; 
0679A:  MOVLB  7
0679C:  BCF    x76.1
....................             break;
0679E:  BRA    67A2
067A0:  MOVLB  7
....................           
....................          }                 
....................       }
067A2:  BRA    67F6
067A4:  MOVLB  0
....................       else
....................       {
....................          switch(i)
067A6:  MOVLW  01
067A8:  MOVLB  7
067AA:  SUBWF  xCD,W
067AC:  ADDLW  F6
067AE:  BC    67F6
067B0:  ADDLW  0A
067B2:  MOVLB  0
067B4:  GOTO   6A46
....................          {
....................             case 1:
....................                Inputt.B1 = 1; 
067B8:  MOVLB  7
067BA:  BSF    x75.0
....................             break;
067BC:  BRA    67F6
....................             case 2:
....................                Inputt.B2 = 1; 
067BE:  MOVLB  7
067C0:  BSF    x75.1
....................             break;
067C2:  BRA    67F6
....................             case 3:
....................                Inputt.B3 = 1; 
067C4:  MOVLB  7
067C6:  BSF    x75.2
....................             break;
067C8:  BRA    67F6
....................             case 4:
....................                Inputt.B4 = 1; 
067CA:  MOVLB  7
067CC:  BSF    x75.3
....................             break;
067CE:  BRA    67F6
....................             case 5:
....................                Inputt.B5 = 1; 
067D0:  MOVLB  7
067D2:  BSF    x75.4
....................             break;
067D4:  BRA    67F6
....................             case 6:
....................                Inputt.B6 = 1; 
067D6:  MOVLB  7
067D8:  BSF    x75.5
....................             break;
067DA:  BRA    67F6
....................             case 7:
....................                Inputt.B7 = 1; 
067DC:  MOVLB  7
067DE:  BSF    x75.6
....................              break;
067E0:  BRA    67F6
....................              case 8:
....................                Inputt.B8 = 1; 
067E2:  MOVLB  7
067E4:  BSF    x75.7
....................             break;
067E6:  BRA    67F6
....................             case 9:
....................                Inputt.B9 = 1; 
067E8:  MOVLB  7
067EA:  BSF    x76.0
....................             break;
067EC:  BRA    67F6
....................             case 10:
....................                Inputt.B10 = 1; 
067EE:  MOVLB  7
067F0:  BSF    x76.1
....................             break;
067F2:  BRA    67F6
067F4:  MOVLB  7
....................        
....................          }                 
....................       } 
067F6:  INCF   xCD,F
067F8:  BRA    66EE
....................       
....................    }
....................    
....................       //GSM SIM900 Init
....................    delay_ms(1000);
067FA:  MOVLW  04
067FC:  MOVWF  xCF
067FE:  MOVLW  FA
06800:  MOVWF  xD8
06802:  MOVLB  0
06804:  CALL   068A
06808:  MOVLB  7
0680A:  DECFSZ xCF,F
0680C:  BRA    67FE
....................    fprintf(CH2,"AT+CMGF=1"); 
0680E:  MOVLW  80
06810:  MOVWF  FF6
06812:  MOVLW  06
06814:  MOVWF  FF7
06816:  MOVLB  0
06818:  CALL   1F30
....................    putc('\n',CH2);
0681C:  MOVLW  0A
0681E:  MOVLB  7
06820:  MOVWF  xD1
06822:  MOVLB  0
06824:  CALL   1EEA
....................    delay_ms(50);
06828:  MOVLW  32
0682A:  MOVLB  7
0682C:  MOVWF  xD8
0682E:  MOVLB  0
06830:  CALL   068A
....................    
....................    SendSMS.B1 =0;
06834:  MOVLB  7
06836:  BCF    x91.0
....................    SendSMS.B2 =0;
06838:  BCF    x91.1
....................    SendSMS.B3 =0;
0683A:  BCF    x91.2
....................    SendSMS.B4 =0;
0683C:  BCF    x91.3
....................    SendSMS.B5 =0;
0683E:  BCF    x91.4
....................    SendSMS.B6 =0;
06840:  BCF    x91.5
....................    SendSMS.B7 =0;
06842:  BCF    x91.6
....................    SendSMS.B8 =0;
06844:  BCF    x91.7
....................    SendSMS.B9 =0;
06846:  BCF    x92.0
....................    SendSMS.B10 =0;
06848:  BCF    x92.1
....................    
....................    char m;
....................    for(m=0; m<10; m++)
0684A:  CLRF   xCE
0684C:  MOVF   xCE,W
0684E:  SUBLW  09
06850:  BNC   6884
....................    {
....................       sms_phonenumber[m] = read_eeprom(0x32 + m);
06852:  CLRF   03
06854:  MOVF   xCE,W
06856:  ADDLW  82
06858:  MOVWF  FE9
0685A:  MOVLW  05
0685C:  ADDWFC 03,W
0685E:  MOVWF  FEA
06860:  MOVLW  32
06862:  ADDWF  xCE,W
06864:  MOVWF  xD1
06866:  MOVFF  FF2,7D2
0686A:  BCF    FF2.7
0686C:  CLRF   FAA
0686E:  MOVFF  7D1,FA9
06872:  BCF    FA6.6
06874:  BCF    FA6.7
06876:  BSF    FA6.0
06878:  MOVF   FA8,W
0687A:  BTFSC  xD2.7
0687C:  BSF    FF2.7
0687E:  MOVWF  FEF
06880:  INCF   xCE,F
06882:  BRA    684C
....................    }
....................    sms_phonenumber[m] = '\0' ; // end string
06884:  CLRF   03
06886:  MOVF   xCE,W
06888:  ADDLW  82
0688A:  MOVWF  FE9
0688C:  MOVLW  05
0688E:  ADDWFC 03,W
06890:  MOVWF  FEA
06892:  CLRF   FEF
.................... 
....................    delay_ms(500);
06894:  MOVLW  02
06896:  MOVWF  xCF
06898:  MOVLW  FA
0689A:  MOVWF  xD8
0689C:  MOVLB  0
0689E:  CALL   068A
068A2:  MOVLB  7
068A4:  DECFSZ xCF,F
068A6:  BRA    6898
....................    functointest_f =0;
068A8:  BCF    32.1
....................    
....................    while(TRUE)
....................    {
.................... 
....................       IO_OUTPUT_A(IO_DEVICE_0, 0xFF); //jj 
068AA:  CLRF   xD7
068AC:  SETF   xD8
068AE:  MOVLB  0
068B0:  CALL   1EBE
....................       IO_OUTPUT_B(IO_DEVICE_0, 0xFF); //jj 
068B4:  MOVLB  7
068B6:  CLRF   xD7
068B8:  SETF   xD8
068BA:  MOVLB  0
068BC:  CALL   1ED4
....................       IO_OUTPUT_A(IO_DEVICE_1, 0xFF); //jj 
068C0:  MOVLW  02
068C2:  MOVLB  7
068C4:  MOVWF  xD7
068C6:  SETF   xD8
068C8:  MOVLB  0
068CA:  CALL   1EBE
....................       IO_OUTPUT_B(IO_DEVICE_1, 0xFF); //jj 
068CE:  MOVLW  02
068D0:  MOVLB  7
068D2:  MOVWF  xD7
068D4:  SETF   xD8
068D6:  MOVLB  0
068D8:  CALL   1ED4
....................       restart_wdt();
068DC:  CLRWDT
.................... 
....................       if(recieve_completed == 1)
068DE:  BTFSS  32.6
068E0:  BRA    68E8
....................       {
....................          Modbus_Function();
068E2:  GOTO   216A
....................          recieve_completed = 0 ;
068E6:  BCF    32.6
....................       }
....................       
....................    
....................       check_ack();
068E8:  GOTO   3F72
....................       check_reset();
068EC:  GOTO   407C
....................       check_test();
068F0:  GOTO   4214
....................       restart_wdt();
068F4:  CLRWDT
....................       
....................       if(StartRead)
068F6:  BTFSS  32.4
068F8:  BRA    6A12
....................       {
....................          
....................          Anal_Function(); restart_wdt();
068FA:  GOTO   482E
068FE:  CLRWDT
....................          Send_Ouput(); restart_wdt();
06900:  GOTO   5EA2
06904:  CLRWDT
....................          Read_input(); restart_wdt();//Must be first
06906:  CALL   16D2
0690A:  CLRWDT
....................          //Driver595(); restart_wdt();
....................          if(send_SMS_period){
0690C:  MOVLB  7
0690E:  MOVF   x73,F
06910:  BZ    691A
....................             send_SMS_period =0;
06912:  CLRF   x73
....................             sendsum_sms();
06914:  MOVLB  0
06916:  BRA    6180
06918:  MOVLB  7
....................          }
....................          
....................          output_toggle(PIN_A0);
0691A:  BCF    F92.0
0691C:  BTG    F89.0
....................          
....................          if(RefreshConfigData)
0691E:  BTFSS  32.5
06920:  BRA    6A14
....................          {
....................             RefreshConfigData =0;
06922:  BCF    32.5
....................             Read_Config();
06924:  MOVLB  0
06926:  CALL   07A8
....................             //IO_INIT();   //initializes the MCP23S17 chip.//----------jj
....................      
....................             IO_SET_TRIS_A(IO_DEVICE_0, 0xFF); //addr.0 Set PortA As Input
0692A:  MOVLB  7
0692C:  CLRF   xCF
0692E:  SETF   xD0
06930:  MOVLB  0
06932:  CALL   0782
....................             IO_SET_TRIS_B(IO_DEVICE_0, 0xFF); //addr.0 Set PortB As Input
06936:  MOVLB  7
06938:  CLRF   xCF
0693A:  SETF   xD0
0693C:  MOVLB  0
0693E:  CALL   0794
....................             IO_SET_TRIS_A(IO_DEVICE_1, 0xFF); //addr.1 Set PortA As Input 
06942:  MOVLW  02
06944:  MOVLB  7
06946:  MOVWF  xCF
06948:  SETF   xD0
0694A:  MOVLB  0
0694C:  CALL   0782
....................             IO_SET_TRIS_B(IO_DEVICE_1, 0xFF); //addr.1 Set PortB As Input
06950:  MOVLW  02
06952:  MOVLB  7
06954:  MOVWF  xCF
06956:  SETF   xD0
06958:  MOVLB  0
0695A:  CALL   0794
....................             //  jj
....................             IO_WRITE_REGISTER(IO_DEVICE_0, GPPUA, 0xFF); // Input Pullup
0695E:  MOVLB  7
06960:  CLRF   xD9
06962:  MOVLW  06
06964:  MOVWF  xDA
06966:  SETF   xDB
06968:  MOVLB  0
0696A:  CALL   06BA
....................             IO_WRITE_REGISTER(IO_DEVICE_0, GPPUB, 0xFF); // Input Pullup
0696E:  MOVLB  7
06970:  CLRF   xD9
06972:  MOVLW  16
06974:  MOVWF  xDA
06976:  SETF   xDB
06978:  MOVLB  0
0697A:  CALL   06BA
....................             IO_WRITE_REGISTER(IO_DEVICE_1, GPPUA, 0xFF); // Input Pullup
0697E:  MOVLW  02
06980:  MOVLB  7
06982:  MOVWF  xD9
06984:  MOVLW  06
06986:  MOVWF  xDA
06988:  SETF   xDB
0698A:  MOVLB  0
0698C:  CALL   06BA
....................             IO_WRITE_REGISTER(IO_DEVICE_1, GPPUB, 0xFF); // Input Pullup
06990:  MOVLW  02
06992:  MOVLB  7
06994:  MOVWF  xD9
06996:  MOVLW  16
06998:  MOVWF  xDA
0699A:  SETF   xDB
0699C:  MOVLB  0
0699E:  CALL   06BA
....................             //  jj
....................             IO_SET_TRIS_A(IO_DEVICE_2, 0x00); //addr.2 Set PortA As Output 
069A2:  MOVLW  04
069A4:  MOVLB  7
069A6:  MOVWF  xCF
069A8:  CLRF   xD0
069AA:  MOVLB  0
069AC:  CALL   0782
....................             IO_SET_TRIS_B(IO_DEVICE_2, 0x00); //addr.2 Set PortB As Output
069B0:  MOVLW  04
069B2:  MOVLB  7
069B4:  MOVWF  xCF
069B6:  CLRF   xD0
069B8:  MOVLB  0
069BA:  CALL   0794
....................             IO_SET_TRIS_A(IO_DEVICE_3, 0x00); //addr.3 Set PortA As Output 
069BE:  MOVLW  06
069C0:  MOVLB  7
069C2:  MOVWF  xCF
069C4:  CLRF   xD0
069C6:  MOVLB  0
069C8:  CALL   0782
....................             IO_SET_TRIS_B(IO_DEVICE_3, 0x00); //addr.3 Set PortB As Output
069CC:  MOVLW  06
069CE:  MOVLB  7
069D0:  MOVWF  xCF
069D2:  CLRF   xD0
069D4:  MOVLB  0
069D6:  CALL   0794
....................             IO_SET_TRIS_A(IO_DEVICE_4, 0x00); //addr.4 Set PortA As Output 
069DA:  MOVLW  08
069DC:  MOVLB  7
069DE:  MOVWF  xCF
069E0:  CLRF   xD0
069E2:  MOVLB  0
069E4:  CALL   0782
....................             IO_SET_TRIS_B(IO_DEVICE_4, 0x00); //addr.4 Set PortB As Output 
069E8:  MOVLW  08
069EA:  MOVLB  7
069EC:  MOVWF  xCF
069EE:  CLRF   xD0
069F0:  MOVLB  0
069F2:  CALL   0794
....................             IO_SET_TRIS_A(IO_DEVICE_5, 0x00); //addr.5 Set PortA As Output 
069F6:  MOVLW  0A
069F8:  MOVLB  7
069FA:  MOVWF  xCF
069FC:  CLRF   xD0
069FE:  MOVLB  0
06A00:  CALL   0782
....................             IO_SET_TRIS_B(IO_DEVICE_5, 0x00); //addr.5 Set PortB As Output
06A04:  MOVLW  0A
06A06:  MOVLB  7
06A08:  MOVWF  xCF
06A0A:  CLRF   xD0
06A0C:  MOVLB  0
06A0E:  CALL   0794
06A12:  MOVLB  7
....................          }
....................       }
06A14:  BRA    68AA
....................       
....................       
....................       
....................    }
....................    
.................... }
06A16:  SLEEP 

Configuration Fuses:
   Word  1: E800   INTRC_IO NOPLLEN PRIMARY FCMEN IESO
   Word  2: 1B1F   NOPUT BROWNOUT BORV19 WDT WDT64
   Word  3: BF00   CCP2C1 PBADEN CCP3B5 HFOFST TIMER3C0 CCP2B5 MCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
